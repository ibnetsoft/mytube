{% extends "base.html" %}

{% block content %}
<div class="h-[calc(100vh-140px)] flex flex-col gap-3 p-2">
    <!-- 1. Top Control Toolbar -->
    <div
        class="flex items-center gap-3 p-2 bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 shrink-0 flex-wrap">

        <!-- Script Status Badge -->
        <span id="scriptStatusBadge"
            class="text-[10px] flex items-center gap-1 px-2 py-1 rounded-full bg-gray-100 text-gray-400 font-normal">
            <span>üîÑ</span> {{ t('status_checking_script') }}
        </span>

        <div class="h-4 w-px bg-gray-300 dark:bg-gray-600 mx-1"></div>

        <!-- Provider -->
        <div class="flex items-center gap-2">
            <span class="text-xs font-bold text-gray-700 dark:text-gray-300">{{ t('label_service') }}</span>
            <select id="providerSelect"
                class="text-xs border-gray-300 dark:border-gray-600 rounded-md py-1 px-2 focus:ring-primary focus:border-primary bg-gray-50 dark:bg-gray-700 dark:text-white">
                <option value="gemini">Gemini (Î¨¥Î£å)</option>
                <option value="openai">OpenAI (Ïú†Î£å)</option>
                <option value="elevenlabs" selected>ElevenLabs</option>
                <option value="google_cloud">Google Cloud</option>
            </select>
        </div>

        <div class="h-4 w-px bg-gray-300 dark:bg-gray-600 mx-1"></div>

        <!-- Voice (Single Mode) -->
        <div class="flex items-center gap-2" id="singleVoiceControls">
            <span class="text-xs font-bold text-gray-700 dark:text-gray-300">{{ t('label_voice') }}</span>
            <select id="voiceSelect"
                class="text-xs border-gray-300 dark:border-gray-600 rounded-md py-1 px-2 focus:ring-primary focus:border-primary bg-gray-50 dark:bg-gray-700 dark:text-white w-40">
                <option value="">{{ t('status_loading') }}</option>
            </select>
        </div>

        <div class="h-4 w-px bg-gray-300 dark:bg-gray-600 mx-1"></div>

        <!-- Speed -->
        <div class="flex items-center gap-2">
            <span class="text-xs font-bold text-gray-700 dark:text-gray-300">{{ t('label_speed') }} <span
                    id="speedValue" class="text-primary">1.0</span></span>
            <input type="range" id="audioSpeed" min="0.5" max="2.0" step="0.1" value="1.0"
                class="w-20 h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 accent-primary"
                title="">
        </div>

        <div class="flex-1"></div>

        <!-- Multi-Voice Toggle -->
        <label class="inline-flex items-center cursor-pointer mr-2">
            <input type="checkbox" id="multiVoiceToggle" class="sr-only peer">
            <div
                class="relative w-8 h-4 bg-gray-200 peer-focus:outline-none rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-3 after:w-3 after:transition-all dark:border-gray-600 peer-checked:bg-purple-600">
            </div>
            <span class="ms-2 text-xs font-medium text-gray-900 dark:text-gray-300">{{ t('label_multivoice') }}</span>
        </label>

        <!-- Generate Button -->
        <button onclick="saveTTSSettings(this)"
            class="px-3 py-1.5 text-xs bg-green-600 hover:bg-green-700 text-white rounded shadow transition flex items-center gap-1">
            <span>üíæ {{ t('btn_save_settings_only') }}</span>
        </button>
        <button onclick="generateTTS()" id="generateBtn"
            class="btn-primary py-1.5 px-4 text-sm font-medium rounded-md shadow-sm hover:shadow active:scale-95 transition-all flex items-center gap-2 whitespace-nowrap">
            <span>üîä {{ t('btn_generate') }}</span>
        </button>

        <!-- Divider -->
        <div class="h-4 w-px bg-gray-300 dark:bg-gray-600 mx-1"></div>

        <!-- Upload Audio Button -->
        <div class="flex items-center">
            <input type="file" id="audioUploadInput" accept="audio/*" class="hidden"
                onchange="uploadExternalAudio(this)">
            <button onclick="document.getElementById('audioUploadInput').click()"
                class="btn-secondary py-1.5 px-3 flex items-center justify-center gap-2 text-xs font-bold shadow-sm whitespace-nowrap">
                <span>üìÅ {{ t('btn_upload_ext_audio') }}</span>
            </button>
        </div>
    </div>

    <!-- 2. Main Workspace (Grid) -->
    <div class="grid grid-cols-12 gap-3 flex-1 min-h-0">
        <!-- Left Panel: Character Mapping / Info (Col-4) -->
        <div class="col-span-12 md:col-span-4 flex flex-col gap-3 min-h-0">
            <!-- Information / Status -->
            <div id="apiStatus"
                class="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-3 shrink-0 shadow-sm">
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-2">
                        <span class="text-sm">üîë</span>
                        <span id="apiStatusText" class="text-xs text-gray-500">{{ t('status_checking_api') }}</span>
                    </div>
                </div>
            </div>

            <!-- Voice Preview Section -->
            <div id="voicePreviewSection"
                class="hidden bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-3 shadow-sm border-l-4 border-l-blue-400">
                <div class="flex items-center justify-between mb-2">
                    <h4 class="text-xs font-bold text-gray-700 dark:text-gray-300">{{ t('voice_preview_title') }}</h4>
                    <span id="previewVoiceLabel" class="text-[10px] text-blue-600 font-bold"></span>
                </div>
                <div class="flex items-center gap-2">
                    <audio id="voicePreviewPlayer" controls class="w-full h-8 flex-1"></audio>
                </div>
            </div>

            <!-- Multi-Voice Mapping List (Visible when Toggle ON) -->
            <div id="voiceMappingSection"
                class="hidden flex-1 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-3 flex flex-col overflow-hidden shadow-sm">
                <div class="flex items-center justify-between mb-2 shrink-0">
                    <h4 class="text-xs font-bold text-gray-700 dark:text-gray-300">{{ t('character_voice_title') }}</h4>
                    <button onclick="analyzeScriptForCharacters()"
                        class="text-[10px] text-blue-500 hover:text-blue-700">üîÑ {{ t('btn_refresh') }}</button>
                </div>

                <div class="text-[10px] text-gray-500 mb-2 bg-blue-50 dark:bg-blue-900/20 p-2 rounded">
                    {{ t('multivoice_helper') | safe }}
                </div>

                <div id="characterList" class="overflow-y-auto flex-1 space-y-2 pr-1 custom-scrollbar">
                    <p class="text-xs text-gray-400 text-center py-4">{{ t('multivoice_empty_desc') | safe }}</p>
                </div>
            </div>

            <!-- Audio Result (Visible after generation) -->
            <div id="resultSection"
                class="hidden shrink-0 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-3 shadow-sm border-l-4 border-l-purple-500">
                <h4 class="text-xs font-bold text-gray-800 dark:text-white mb-2">{{ t('gen_result_title') }}</h4>
                <audio id="audioPlayer" controls class="w-full h-8 mb-2"></audio>
                <div class="flex gap-2">
                    <a id="downloadLink" href="#" download class="flex-1 btn-secondary py-1 text-xs text-center">üíæ
                        {{ t('btn_download') }}</a>
                    <a href="/subtitle_gen"
                        class="flex-1 btn-primary py-1 text-xs text-center bg-blue-600 hover:bg-blue-700">{{
                        t('btn_go_subtitle') }}</a>
                </div>
            </div>
        </div>

        <!-- Right Panel: Script Editor (Col-8) -->
        <div
            class="col-span-12 md:col-span-8 flex flex-col min-h-0 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 shadow-sm overflow-hidden">
            <div
                class="flex items-center justify-between p-2 border-b border-gray-100 dark:border-gray-700 bg-gray-50 dark:bg-gray-800/50">
                <h3 class="text-xs font-bold text-gray-700 dark:text-gray-300 flex items-center gap-2">
                    {{ t('script_input_title') }}
                    <span class="font-normal text-gray-400">|</span>
                    <span class="font-normal text-gray-500"><span id="charCount">0</span>Ïûê</span>
                </h3>
                <button onclick="loadScript()"
                    class="text-xs text-gray-500 hover:text-primary flex items-center gap-1 transition-colors">
                    üîÑ {{ t('btn_load_script') }}
                </button>
            </div>

            <textarea id="ttsText"
                class="flex-1 p-3 text-sm font-mono border-0 focus:ring-0 resize-none bg-transparent dark:text-gray-200 custom-scrollbar leading-relaxed"
                placeholder="{{ t('script_input_placeholder') }}"></textarea>

            <div
                class="p-1 px-3 bg-gray-50 dark:bg-gray-800/50 border-t border-gray-100 dark:border-gray-700 text-[10px] text-gray-400 flex justify-between">
                <span>{{ t('est_time_label') }}: <span id="estTime">0:00</span></span>
                <span>{{ t('newline_hint') }}</span>
            </div>
        </div>
    </div>
</div>

<style>
    .custom-scrollbar::-webkit-scrollbar {
        width: 4px;
    }

    .custom-scrollbar::-webkit-scrollbar-track {
        background: transparent;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb {
        background-color: #cbd5e1;
        border-radius: 20px;
    }

    .dark .custom-scrollbar::-webkit-scrollbar-thumb {
        background-color: #4b5563;
    }
</style>
{% endblock %}

{% block scripts %}
<script>
    let speechSynth = window.speechSynthesis;
    let utterance = null;

    document.addEventListener('DOMContentLoaded', async () => {
        checkScriptStatus(); // [NEW] Check Status
        await checkAPIStatus();
        await loadVoices();

        // [NEW] Restore saved settings
        const pid = getCurrentProject();
        if (pid) await restoreTTSSettings(pid);

        loadScript();

        document.getElementById('providerSelect').addEventListener('change', handleProviderChange);

        const speedSlider = document.getElementById('audioSpeed');
        const speedValue = document.getElementById('speedValue');
        if (speedSlider && speedValue) {
            speedSlider.addEventListener('input', (e) => speedValue.textContent = e.target.value);
        }
    });

    async function restoreTTSSettings(projectId) {
        try {
            const settings = await API.project.getSettings(projectId);
            if (!settings) return;

            if (settings.voice_provider) {
                const prov = document.getElementById('providerSelect');
                if (prov) {
                    prov.value = settings.voice_provider;
                    // reload voices for this provider
                    await loadVoices();
                }
            }

            if (settings.voice_name) { // voice_name maps to voiceId in DB
                const vs = document.getElementById('voiceSelect');
                if (vs) vs.value = settings.voice_name;
            }
            // voice_id might also be used in some contexts, check both
            if (settings.voice_id && !settings.voice_name) {
                const vs = document.getElementById('voiceSelect');
                if (vs) vs.value = settings.voice_id;
            }

            if (settings.voice_speed) {
                const speed = document.getElementById('audioSpeed');
                const val = document.getElementById('speedValue');
                if (speed) speed.value = settings.voice_speed;
                if (val) val.textContent = settings.voice_speed;
            }
        } catch (e) {
            console.error("Failed to restore TTS settings:", e);
        }
    }

    // Script Status Check (Same logic as image_gen)
    async function checkScriptStatus() {
        const badge = document.getElementById('scriptStatusBadge');
        if (!badge) return;

        let hasScript = false;

        // 1. Check Local Storage
        const localData = Utils.storage.get('fullScript');
        if (localData && localData.script) {
            hasScript = true;
        } else {
            // 2. Check DB
            const projectId = getCurrentProject();
            if (projectId) {
                try {
                    const result = await API.project.getScript(projectId);
                    if (result && result.full_script) {
                        hasScript = true;
                        // Sync to local
                        Utils.storage.set('fullScript', { script: result.full_script });
                    }
                } catch (e) {
                    console.error("Script check failed:", e);
                }
            }
        }

        if (hasScript) {
            badge.className = "text-[10px] flex items-center gap-1 px-2 py-1 rounded-full bg-green-100 dark:bg-green-900/30 text-green-600 dark:text-green-400 font-normal";
            badge.innerHTML = "<span>‚úÖ</span> {{ t('script_ready') }}";
        } else {
            badge.className = "text-[10px] flex items-center gap-1 px-2 py-1 rounded-full bg-red-100 dark:bg-red-900/30 text-red-600 dark:text-red-400 font-normal";
            badge.innerHTML = "<span>üö´</span> {{ t('no_script') }}";
        }
    }

    // ... (Í∏∞Ï°¥ JS Î°úÏßÅ Ïú†ÏßÄ, ID Îß§Ïπ≠ ÌôïÏù∏) ...
    // window.addEventListener('projectStateRestored', ...) Î°úÏßÅÏùÄ Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö© Í∞ÄÎä•
    // Îã®, HTML Íµ¨Ï°∞Í∞Ä Î∞îÎÄåÏóàÏúºÎØÄÎ°ú classList Ï†úÏñ¥ Î∂ÄÎ∂Ñ ÌôïÏù∏ ÌïÑÏöî

    // ÏÉÅÌÉú Î≥µÍµ¨ Ïù¥Î≤§Ìä∏ ÏàòÏã†
    window.addEventListener('projectStateRestored', async (e) => {
        const data = e.detail;

        // 1. Script Restoration
        if (data.full_script && data.full_script.full_script) {
            Utils.storage.set('fullScript', { script: data.full_script.full_script });
            loadScript();
        } else if (data.settings && data.settings.script) {
            Utils.storage.set('fullScript', { script: data.settings.script });
            loadScript();
        }

        // 2. Audio Result Restoration
        if (data.tts) {
            if (!data.tts.url && data.tts.audio_path) {
                const path = data.tts.audio_path.replace(/\\/g, '/');
                const outputIndex = path.indexOf('/output/');
                if (outputIndex !== -1) data.tts.url = path.substring(outputIndex);
            }
            if (data.tts.url) {
                Utils.storage.set('ttsAudio', data.tts);
                const player = document.getElementById('audioPlayer');
                if (player) player.src = data.tts.url;
                const dnLink = document.getElementById('downloadLink');
                if (dnLink) dnLink.href = data.tts.url;

                const resultSec = document.getElementById('resultSection');
                if (resultSec) resultSec.classList.remove('hidden');
            }
        }

        // 3. TTS Settings Restoration (Voice, Provider, Speed)
        if (data.settings) {
            const settings = data.settings;
            if (settings.voice_provider) {
                const prov = document.getElementById('providerSelect');
                if (prov) prov.value = settings.voice_provider;
            }

            // Load voices for the provider
            await loadVoices();

            if (settings.voice_name) {
                const vs = document.getElementById('voiceSelect');
                if (vs) vs.value = settings.voice_name;
            }
            if (settings.voice_speed) {
                const speed = document.getElementById('audioSpeed');
                const val = document.getElementById('speedValue');
                if (speed) speed.value = settings.voice_speed;
                if (val) val.textContent = settings.voice_speed;
            }
            if (settings.voice_multi_enabled !== undefined) {
                const toggle = document.getElementById('multiVoiceToggle');
                if (toggle) {
                    toggle.checked = !!settings.voice_multi_enabled;
                    // Restore mapping
                    if (settings.voice_mapping_json) {
                        try {
                            characterVoiceMap = JSON.parse(settings.voice_mapping_json);
                        } catch (e) { }
                    }
                    toggle.dispatchEvent(new Event('change'));
                }
            }
        }
    });

    async function checkAPIStatus() {
        const health = await API.health();
        const statusText = document.getElementById('apiStatusText');

        let msg = '';
        if (health.apis?.elevenlabs) msg += '<span class="text-green-600">‚úÖ EL </span>';
        if (health.apis?.openai) msg += '<span class="text-green-600">‚úÖ OA </span>';
        if (!msg) msg = '<span class="text-blue-600">‚ú® Gemini</span>';

        statusText.innerHTML = msg;
        // handleProviderChange(); // [MOD] Removed to avoid redundant calls, will be handled by restoreTTSSettings or default
    }

    // [NEW] Save TTS Settings Bulk
    async function saveTTSSettings(btn) {
        const projectId = getCurrentProject();
        if (!projectId) return;

        const originalText = btn ? btn.innerHTML : `{{ t('btn_save_settings_only') }}`;
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = `<span>üîÑ</span> {{ t('status_saving') }}`;
        }

        try {
            const provider = document.getElementById('providerSelect').value;
            const voiceId = document.getElementById('voiceSelect').value;
            const speed = parseFloat(document.getElementById('audioSpeed').value) || 1.0;
            const isMultiVoice = document.getElementById('multiVoiceToggle').checked ? 1 : 0;

            const settings = {
                voice_provider: provider,
                voice_name: voiceId,
                voice_speed: speed,
                voice_multi_enabled: isMultiVoice,
                voice_mapping_json: JSON.stringify(characterVoiceMap)
            };

            const result = await API.project.saveSettings(projectId, settings);
            if (result.status === 'ok') {
                Utils.showToast(`{{ t('toast_tts_settings_saved') }}`, "success");
            } else {
                throw new Error(result.error || "Save failed");
            }
        } catch (e) {
            console.error(e);
            Utils.showToast("ÏÑ§Ï†ï Ï†ÄÏû• Ïã§Ìå®: " + e.message, "error");
        } finally {
            if (btn) {
                btn.disabled = false;
                btn.innerHTML = originalText;
            }
        }
    }

    // [NEW] Restore TTS Settings

    // Ï†ÑÏó≠ Î≥ÄÏàò
    let detectedCharacters = new Set();
    let characterVoiceMap = {};
    let availableVoices = [];
    let currentLanguage = 'ko';

    document.getElementById('multiVoiceToggle').addEventListener('change', (e) => {
        const section = document.getElementById('voiceMappingSection');
        const singleControls = document.getElementById('singleVoiceControls');

        if (e.target.checked) {
            section.classList.remove('hidden');
            singleControls.classList.add('opacity-50', 'pointer-events-none'); // Disable single controls visually
            analyzeScriptForCharacters();

            const provider = document.getElementById('providerSelect');
            if (provider.value !== 'gemini') {
                provider.value = 'gemini';
                handleProviderChange();
                Utils.showToast("{{ t('toast_multivoice_gemini_recommended') }}", 'info');
            }
        } else {
            section.classList.add('hidden');
            singleControls.classList.remove('opacity-50', 'pointer-events-none');
        }
    });

    document.getElementById('ttsText').addEventListener('input', () => {
        updateStats();
        if (document.getElementById('multiVoiceToggle').checked) {
            analyzeScriptForCharacters();
        }
    });

    function analyzeScriptForCharacters() {
        const text = document.getElementById('ttsText').value;
        const lines = text.split('\n');
        const newCharacters = new Set();
        const regex = /^([^\s:\[\]\(\)]+)(?:\(.*\))?[:]/;

        lines.forEach(line => {
            const match = line.trim().match(regex);
            if (match && match[1]) {
                let cleanName = match[1].trim()
                    .replace(/[\*\_\#]/g, '')
                    .replace(/[\[\]\(\)\{\}]/g, '')
                    .trim();
                if (cleanName && cleanName.length > 0) newCharacters.add(cleanName);
            }
        });

        if (!isSetsEqual(detectedCharacters, newCharacters)) {
            detectedCharacters = newCharacters;
            renderCharacterMapping();
        }
    }

    function isSetsEqual(a, b) {
        if (a.size !== b.size) return false;
        for (let item of a) if (!b.has(item)) return false;
        return true;
    }

    function renderCharacterMapping() {
        const container = document.getElementById('characterList');
        container.innerHTML = '';

        if (detectedCharacters.size === 0) {
            container.innerHTML = `<p class="text-xs text-gray-400 text-center py-2">{{ t('no_characters_detected') | safe }}</p>`;
            return;
        }

        const sortedChars = Array.from(detectedCharacters).sort();
        sortedChars.forEach(char => {
            const savedVoice = characterVoiceMap[char] || '';
            const row = document.createElement('div');
            row.className = 'flex items-center justify-between bg-gray-50 dark:bg-gray-700/50 p-1.5 rounded border border-gray-100 dark:border-gray-600 gap-2';

            let options = availableVoices.length > 0 ? availableVoices.map(v =>
                `<option value="${v.id}" ${v.id === savedVoice ? 'selected' : ''}>${v.name}</option>`
            ).join('') : `<option value="">{{ t('status_loading') }}</option>`;

            const safeChar = char.replace(/'/g, "\\'");

            row.innerHTML = `
                <span class="text-xs font-bold text-gray-700 dark:text-gray-300 w-16 truncate" title="${char}">${char}</span>
                <select class="text-[10px] border-gray-200 dark:border-gray-600 rounded py-1 pl-1 pr-6 flex-1 bg-white dark:bg-gray-800 dark:text-white" onchange="updateCharVoice('${safeChar}', this.value)">
                    <option value="">-- {{ t('label_default_voice') }} --</option>
                    ${options}
                </select>
            `;
            container.appendChild(row);
        });
    }

    window.updateCharVoice = function (char, voiceId) {
        if (voiceId) characterVoiceMap[char] = voiceId;
        else delete characterVoiceMap[char];
    };

    async function loadVoices() {
        const select = document.getElementById('voiceSelect');
        const provider = document.getElementById('providerSelect').value;
        select.innerHTML = `<option>{{ t('status_loading') }}</option>`;
        availableVoices = [];

        // ... Data Loading Logic same as before ... 
        // (Briefing logic for brevity, assuming standard API calls)

        let voices = [];
        try {
            if (provider === 'browser') {
                const browserVoices = speechSynthesis.getVoices().filter(v => v.lang.startsWith('ko'));
                voices = browserVoices.map(v => ({ id: v.name, name: v.name }));
            } else if (provider === 'google_cloud') {
                voices = [
                    { id: 'ko-KR-Neural2-A', name: 'G-Neural2 A(Ïó¨)' },
                    { id: 'ko-KR-Neural2-C', name: 'G-Neural2 C(ÎÇ®)' },
                    { id: 'ko-KR-Standard-A', name: 'G-Std A(Ïó¨)' }
                ]; // Simplified for now, or full list
            } else if (provider === 'gemini') {
                voices = [
                    { id: 'Puck', name: 'Puck (ÎÇ®/Ï§ë)' },
                    { id: 'Charon', name: 'Charon (ÎÇ®/Ï†Ä)' },
                    { id: 'Kore', name: 'Kore (Ïó¨/Î∂ÄÎìú)' },
                    { id: 'Fenrir', name: 'Fenrir (ÎÇ®/Í±∞Ïπ®)' },
                    { id: 'Aoede', name: 'Aoede (Ïó¨/ÎÜí)' }
                ];
            } else if (provider === 'openai') {
                voices = [
                    { id: 'alloy', name: 'Alloy' }, { id: 'echo', name: 'Echo' }, { id: 'shimmer', name: 'Shimmer' }
                ];
            } else {
                // ElevenLabs
                const result = await API.tts.getVoices();
                if (result.voices) voices = result.voices.map(v => ({
                    id: v.voice_id,
                    name: v.name,
                    preview_url: v.preview_url
                }));
            }
        } catch (e) {
            console.error(e);
        }

        availableVoices = voices;
        if (voices.length > 0) {
            select.innerHTML = voices.map(v => `<option value="${v.id}">${v.name}</option>`).join('');
        } else {
            select.innerHTML = `<option value="">{{ t('no_voice') }}</option>`;
        }

        // Add event listener for preview
        select.onchange = handleVoiceChange;
        handleVoiceChange();

        if (document.getElementById('multiVoiceToggle').checked) renderCharacterMapping();
    }

    function handleVoiceChange() {
        const select = document.getElementById('voiceSelect');
        const voiceId = select.value;
        const voice = availableVoices.find(v => v.id === voiceId);
        const previewSection = document.getElementById('voicePreviewSection');
        const player = document.getElementById('voicePreviewPlayer');
        const label = document.getElementById('previewVoiceLabel');

        if (voice && voice.preview_url) {
            previewSection.classList.remove('hidden');
            player.src = voice.preview_url;
            label.textContent = voice.name;
        } else {
            previewSection.classList.add('hidden');
            player.src = '';
            label.textContent = '';
        }
    }

    async function loadScript() {
        console.log("loadScript() called");
        const projectId = getCurrentProject();
        let scriptText = "";

        if (projectId) {
            try {
                // 1. Try to fetch fresh data from server
                const projectFull = await API.project.getFull(projectId);
                console.log("Project Data:", projectFull);

                if (projectFull.project && projectFull.project.target_language) {
                    currentLanguage = projectFull.project.target_language;
                }

                // Strategy A: Longform Script (Check various possible keys)
                if (projectFull.script) {
                    if (typeof projectFull.script === 'string') {
                        scriptText = projectFull.script;
                    } else if (projectFull.script.full_script) {
                        scriptText = projectFull.script.full_script;
                    }
                }

                // Strategy B: Shorts Script (Fallback)
                if (!scriptText && projectFull.shorts) {
                    // Shorts data structure might vary. Typically { shorts: [...] } or just [...]
                    let shortsList = [];
                    if (Array.isArray(projectFull.shorts)) shortsList = projectFull.shorts;
                    else if (projectFull.shorts.shorts && Array.isArray(projectFull.shorts.shorts)) shortsList = projectFull.shorts.shorts;
                    else if (projectFull.shorts.shorts_data && Array.isArray(projectFull.shorts.shorts_data)) shortsList = projectFull.shorts.shorts_data;

                    if (shortsList.length > 0) {
                        console.log("Found Shorts script, using fallback.");
                        // Combine shorts scripts
                        scriptText = shortsList.map((s, i) => {
                            const content = s.script || s.narration || s.text || "";
                            return `[Shorts #${i + 1}] ${s.title || ''}\n${content}`;
                        }).join('\n\n');
                        Utils.showToast("{{ t('toast_shorts_script_loaded') }}", 'info');
                    }
                }

                if (scriptText) {
                    // Update Local Storage for consistency
                    Utils.storage.set('fullScript', { script: scriptText });
                    applyScriptToTextarea(scriptText);
                    Utils.showToast(`{{ t('toast_script_loaded') }}`, 'success');
                    return;
                }

            } catch (e) {
                console.error("Server script load failed:", e);
                Utils.showToast(`{{ t('toast_script_load_failed') }}`, 'error');
            }
        }

        // 2. Fallback to Local Storage (if server fetch failed or yielded nothing)
        const localData = Utils.storage.get('fullScript');
        if (localData && localData.script) {
            console.log("Loaded script from local storage");
            applyScriptToTextarea(localData.script);
        } else {
            if (projectId && !scriptText) Utils.showToast(`{{ t('err_no_script') }}`, 'warning');
        }
    }

    function applyScriptToTextarea(text) {
        if (!text) return;
        text = text.replace(/#{1,6}\s/g, '');
        document.getElementById('ttsText').value = text.trim();
        updateStats();
        setTimeout(() => {
            if (document.getElementById('multiVoiceToggle').checked) analyzeScriptForCharacters();
        }, 100);
    }

    function updateStats() {
        const text = document.getElementById('ttsText').value;
        const charCount = text.length;
        const seconds = Math.ceil(charCount / 5);
        document.getElementById('charCount').textContent = charCount.toLocaleString();
        document.getElementById('estTime').textContent = Utils.formatDuration(seconds);
    }

    function handleProviderChange() { loadVoices(); }

    async function generateTTS() {
        const text = document.getElementById('ttsText').value.trim();
        if (!text) return Utils.showToast(`{{ t('toast_input_text_required') }}`, 'warning');

        const provider = document.getElementById('providerSelect').value;
        const speed = parseFloat(document.getElementById('audioSpeed').value) || 1.0;
        const voiceId = document.getElementById('voiceSelect').value;
        const btn = document.getElementById('generateBtn');
        const isMultiVoice = document.getElementById('multiVoiceToggle').checked;

        if (provider === 'browser') { playBrowserTTS(); return; }

        Utils.setLoading(btn, true, `{{ t('status_generating') }}`);
        try {
            const projectId = getCurrentProject();
            const result = await API.tts.generate(text, {
                voiceId, provider, language: currentLanguage, speed,
                projectId: projectId ? parseInt(projectId) : null,
                multiVoice: isMultiVoice,
                voiceMap: isMultiVoice ? characterVoiceMap : {}
            });

            if (result.status === 'ok') {
                const player = document.getElementById('audioPlayer');
                player.src = result.url;
                player.play().catch(e => { });
                document.getElementById('downloadLink').href = result.url;
                document.getElementById('resultSection').classList.remove('hidden');
                Utils.showToast("{{ t('status_done') }}", 'success');
                Utils.storage.set('ttsAudio', { url: result.url, timestamp: Date.now() });

                // [NEW] Update Stepper
                if (window.updateStepStatus) window.updateStepStatus('tts', true);
            } else {
                Utils.showToast(result.error || `{{ t('status_fail') }}`, 'error');
            }
        } catch (error) {
            Utils.showToast(`{{ t('status_error') }}`, 'error');
        } finally {
            Utils.setLoading(btn, false);
        }
    }

    // External Audio Upload
    async function uploadExternalAudio(input) {
        if (!input.files || input.files.length === 0) return;

        const file = input.files[0];
        const projectId = getCurrentProject();

        if (!projectId) {
            Utils.showToast(`{{ t('toast_select_project_first') }}`, "warning");
            input.value = ''; // Reset
            return;
        }

        Utils.showToast(`{{ t('status_uploading') }}`, "info");

        const formData = new FormData();
        formData.append('file', file);

        try {
            const response = await fetch(`/api/projects/${projectId}/tts/upload`, {
                method: 'POST',
                body: formData
            });
            const result = await response.json();

            if (result.status === 'ok') {
                Utils.showToast(`{{ t('toast_ext_audio_registered') }}`, 'success');

                // Set audio player
                const player = document.getElementById('audioPlayer');
                player.src = result.url;
                player.play().catch(e => { }); // Autoplay if possible

                document.getElementById('downloadLink').href = result.url;
                document.getElementById('resultSection').classList.remove('hidden');

                // Save to storage
                // Save to storage
                Utils.storage.set('ttsAudio', { url: result.url, timestamp: Date.now() });

                // [NEW] Update Stepper
                if (window.updateStepStatus) window.updateStepStatus('tts', true);

            } else {
                Utils.showToast('ÏóÖÎ°úÎìú Ïã§Ìå®: ' + (result.error || 'Unknown'), 'error');
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('ÏóÖÎ°úÎìú Ï§ë Ïò§Î•ò Î∞úÏÉù', 'error');
        } finally {
            input.value = ''; // Reset
        }
    }

    // Browser TTS functions remain similar...
    function playBrowserTTS() { /* ... */ }
</script>
{% endblock %}