{% extends "base.html" %}

{% block content %}


<!-- 분석 데이터 표시 -->
<div id="analysisInfo" class="card container-content section-spacing hidden">
    <h3 class="card-title">📋 대본 구조 기반</h3>
    <input type="text" id="structureTopic" class="input-field mt-1" placeholder="영상 주제 (수정 가능)">
    <p class="text-xs text-gray-500 mt-1">💡 주제가 다르다면 직접 수정해주세요. AI는 이 주제와 아래 구조를 바탕으로 대본을 씁니다.</p>
</div>

<!-- 디버그/프리뷰: 실제로 로드된 구조 확인용 -->
<div id="structurePreview" class="card mb-6 border-l-4 border-indigo-500 bg-indigo-50 dark:bg-indigo-900/10">
    <div class="flex items-center justify-between mb-2">
        <h3 class="font-bold text-indigo-800 dark:text-indigo-300">🔍 AI에게 전달될 구조 데이터 (확인용)</h3>
        <button onclick="copyStructurePreview()"
            class="text-xs bg-indigo-100 hover:bg-indigo-200 text-indigo-700 px-2 py-1 rounded transition-colors">
            📋 전체 복사
        </button>
    </div>
    <div id="previewContent"
        class="text-sm text-gray-700 dark:text-gray-300 whitespace-pre-wrap font-mono max-h-40 overflow-y-auto p-2 bg-white dark:bg-gray-800 rounded border border-gray-200 dark:border-gray-700">
        (데이터 로딩 중...)
    </div>
</div>

<!-- 탭 네비게이션 -->
<div class="flex mb-6 border-b border-gray-200 dark:border-gray-700">
    <button onclick="setScriptMode('ai')" id="tabAI"
        class="px-6 py-3 font-bold border-b-2 border-blue-500 text-blue-600 dark:text-blue-400 transition-all">
        🤖 AI 자동 생성
    </button>
    <button onclick="setScriptMode('manual')" id="tabManual"
        class="px-6 py-3 font-bold border-b-2 border-transparent text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 transition-all">
        📝 직접 입력 (붙여넣기)
    </button>
</div>

<!-- ================= AI 생성 모드 ================= -->
<div id="aiGenSection">
    <!-- 대본 옵션 -->
    <div class="card mb-6">
        <h3 class="font-bold text-gray-800 dark:text-white mb-4">⚙️ 대본 옵션</h3>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">대본 스타일</label>
                <select id="scriptStyle" class="input-field">
                    <option value="story" selected>옛날 이야기 (Old Story)</option>
                    <option value="news">뉴스 보도 (News Delivery)</option>
                    <option value="narration">나레이션형 (설명 위주)</option>
                    <option value="conversational">대화형 (친근한 말투)</option>
                    <option value="storytelling">스토리텔링형 (이야기 전개)</option>
                </select>
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">포함 요소</label>
                <div class="flex gap-4">
                    <label class="flex items-center gap-2">
                        <input type="checkbox" id="includeHooks" checked class="rounded">
                        <span class="text-sm text-gray-700 dark:text-gray-300">후킹 멘트</span>
                    </label>
                    <label class="flex items-center gap-2">
                        <input type="checkbox" id="includeCTA" checked class="rounded">
                        <span class="text-sm text-gray-700 dark:text-gray-300">CTA</span>
                    </label>
                </div>
            </div>
        </div>
    </div>

    <!-- 생성 버튼 그룹 -->
    <div class="flex gap-2 mb-6">
        <button onclick="generateScript()" id="generateBtn"
            class="flex-1 btn-primary py-4 flex items-center justify-center gap-3 text-lg">
            <span>✍️</span>
            <span>대본 생성 시작하기</span>
        </button>
        <button onclick="stopAndSave()" id="stopBtn"
            class="hidden btn-secondary bg-red-100 text-red-600 hover:bg-red-200 py-4 px-6 flex items-center justify-center gap-2">
            <span>⏹️</span>
            <span>멈춤 & 저장 (즉시 완료)</span>
        </button>
    </div>
</div>
<!-- End of aiGenSection -->

<!-- ================= 직접 입력 모드 ================= -->
<div id="manualInputSection" class="hidden">
    <div
        class="card container-content section-spacing bg-yellow-50 dark:bg-yellow-900/10 border border-yellow-100 dark:border-yellow-900/30">
        <h3 class="card-title">📝 이미 작성된 대본이 있나요?</h3>
        <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">
            외부에서 작성한 대본을 여기에 붙여넣으세요. AI 생성 과정을 건너뛰고 바로 다음 단계(TTS, 이미지)로 진행할 수 있습니다.
        </p>

        <textarea id="manualScriptInput" class="input-field font-mono" rows="15"
            placeholder="여기에 대본을 붙여넣으세요..."></textarea>

        <div class="btn-group btn-group-end mt-4">
            <button onclick="registerManualScript()" class="btn-primary btn-primary-lg">
                <span>💾</span>
                <span>대본 등록하기</span>
            </button>
        </div>
    </div>
</div>

<!-- 결과 영역 -->
<div id="resultSection" class="hidden">
    <div class="card container-lg section-spacing">
        <div class="flex items-center justify-between mb-4">
            <h3 class="card-title mb-0">📝 생성된 대본</h3>
            <div class="btn-group">
                <button onclick="translateScript()" id="translateBtn" class="btn-secondary hidden">🌐 번역하기</button>
                <button onclick="copyScript()" class="btn-secondary">📋 복사</button>
                <button onclick="downloadScript()" class="btn-secondary">💾 다운로드</button>
            </div>
        </div>

        <div class="mb-4 flex gap-4 text-sm text-gray-500">
            <span id="charCount" class="badge badge-primary">0자</span>
            <span id="readTime" class="badge badge-primary">예상 읽기 시간: 0분</span>
        </div>

        <textarea id="scriptContent" class="input-field font-mono" rows="20"></textarea>

        <div class="btn-group btn-group-center mt-6 pt-6 border-t border-gray-200 dark:border-gray-700">
            <button onclick="goToImageGen()" class="btn-primary" style="min-width: 200px;">
                <span>🖼️</span>
                <span>이미지 프롬프트 생성</span>
                <span>→</span>
            </button>
            <button onclick="goToTTS()" class="btn-secondary" style="min-width: 200px;">
                <span>🔊</span>
                <span>TTS 생성</span>
                <span>→</span>
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    let currentScript = '';

    // 페이지 로드 시 데이터 로딩
    document.addEventListener('DOMContentLoaded', async () => {
        const projectId = getCurrentProject();
        console.log("Current Project ID:", projectId);

        // 1. 프리뷰 초기화
        const previewEl = document.getElementById('previewContent');
        if (previewEl) previewEl.textContent = "데이터 로딩 중...";

        // 2. 데이터 가져오기 (로컬 -> 서버)
        let structureData = Utils.storage.get('scriptStructure');

        // [중요] 프로젝트 ID 불일치 시 데이터를 폐기하고 서버에서 다시 가져옴
        if (structureData && structureData.project_id && structureData.project_id != projectId) {
            console.log("Mismatching validation: Storage ID", structureData.project_id, "Current ID", projectId);
            structureData = null; // Force reload
            Utils.storage.remove('scriptStructure');
        }

        if (!structureData && projectId) {
            try {
                // 서버에서 조회
                const projectFull = await API.project.getFull(projectId);
                console.log("Projects Full Data:", projectFull);

                if (projectFull && projectFull.script_structure) {
                    structureData = projectFull.script_structure;
                    // topic이 필요하면 projectFull.project.topic 또는 script_structure 내부 확인
                    if (!structureData.topic && projectFull.project) {
                        structureData.topic = projectFull.project.topic || projectFull.project.name;
                    }

                    // project_id가 없으면 주입 (클라이언트 사이드 검증용)
                    if (!structureData.project_id) {
                        structureData.project_id = projectId;
                    }

                    Utils.storage.set('scriptStructure', structureData);
                    Utils.showToast('기획 데이터를 server에서 불러왔습니다', 'success');
                }
            } catch (e) {
                console.error("Failed to fetch project data:", e);
                if (previewEl) previewEl.textContent = "❌ 서버 데이터 조회 실패";
            }
        }

        // 3. UI 업데이트
        if (structureData) {
            const infoEl = document.getElementById('analysisInfo'); // Corrected ID from 'structureInfo' to 'analysisInfo'
            if (infoEl) infoEl.classList.remove('hidden');

            const topicEl = document.getElementById('structureTopic');
            const topic = structureData.topic || structureData.hook || '주제 미상';
            if (topicEl) topicEl.value = topic;

            // 프리뷰 업데이트
            if (previewEl) {
                previewEl.textContent = JSON.stringify(structureData, null, 2);
                previewEl.classList.remove('text-red-600');
            }
        } else {
            if (previewEl) {
                previewEl.textContent = "❌ 구조 데이터가 없습니다! 대본 기획 단계 완료 여부를 확인해주세요.";
                previewEl.classList.add('text-red-600', 'font-bold');
            }
        }
    });

    async function generateScript() {
        const projectId = getCurrentProject();
        // 1. 데이터 가져오기 (로컬 -> 서버)
        let structureData = Utils.storage.get('scriptStructure');

        // 데이터가 없거나, 프로젝트 ID가 다르면 새로고침 시도
        if (!structureData || (structureData.project_id && structureData.project_id != projectId)) {
            console.log("Refreshing data in generateScript due to mismatch or missing");
            try {
                const projectFull = await API.project.getFull(projectId);
                if (projectFull && projectFull.script_structure) {
                    structureData = projectFull.script_structure;
                    if (!structureData.topic && projectFull.project) {
                        structureData.topic = projectFull.project.topic || projectFull.project.name;
                    }
                    if (!structureData.project_id) structureData.project_id = projectId;
                    Utils.storage.set('scriptStructure', structureData);
                }
            } catch (e) { console.error(e); }
        }

        if (!structureData) {
            Utils.showToast('대본 구조 데이터가 없습니다. 기획 단계부터 진행해주세요.', 'error');
            return;
        }

        // UI 프리뷰 강제 업데이트 (싱크 맞추기)
        const previewEl = document.getElementById('previewContent');
        if (previewEl) previewEl.textContent = JSON.stringify(structureData, null, 2);

        // 2. 구조 데이터를 문자열로 변환 (버그 수정)
        let structureText = '';
        if (typeof structureData === 'string') {
            structureText = structureData;
        } else if (typeof structureData === 'object') {
            // "structure" 키가 있으면 사용, 없으면 전체 객체 변환
            structureText = structureData.structure || JSON.stringify(structureData, null, 2);
        }

        // 주제정보 보강
        const topic = document.getElementById('structureTopic').value || structureData.topic || structureData.hook || '유튜브 영상';

        // 길이 정보 보강 (기본값 60초)
        const duration = structureData.duration || 60;
        // 한국어 말하기 속도: 초당 약 2.5~3음절 (여유있게 계산)
        // 30초 -> 90~120자, 60초 -> 200~250자
        // 너무 짧으면 AI가 내용을 못 채우므로 초당 4.5자 정도로 넉넉히 잡고 제한
        const maxChars = duration * 5;
        const targetLenMsg = `${duration}초 영상 (약 ${Math.round(duration * 2.5)} ~ ${maxChars}자 내외)`;

        const style = document.getElementById('scriptStyle').value;
        const includeHooks = document.getElementById('includeHooks').checked;
        const includeCTA = document.getElementById('includeCTA').checked;

        const btn = document.getElementById('generateBtn');
        Utils.setLoading(btn, true, '대본 생성 중...');

        // 언어 설정 조회
        let targetLanguage = 'ko'; // 기본값
        try {
            const projectFull = await API.project.getFull(projectId);
            if (projectFull && projectFull.settings && projectFull.settings.target_language) {
                targetLanguage = projectFull.settings.target_language;
            }
        } catch (e) {
            console.error("Failed to fetch project settings for language:", e);
        }

        // 언어 이름 매핑
        const langMap = {
            'ko': '한국어',
            'en': 'English',
            'ja': 'Japanese',
            'es': 'Spanish'
        };
        const langName = langMap[targetLanguage] || targetLanguage;

        // 섹션별 순차 생성 (긴 영상 대응)
        let finalScript = "";
        const sections = structureData.sections || [];

        // 전체 구조 텍스트 (문맥 유지용)
        const fullStructureSummary = sections.map((s, i) => `${i + 1}. ${s.title}: ${s.key_points.join(', ')}`).join('\n');

        // 스타일별 상세 지침 매핑
        const styleInstructionMap = {
            'narration': `
                - **전문적이고 신뢰감 있는 톤**을 유지하되, 지루하지 않게 작성하세요.
                - 복잡한 개념은 쉽고 명확한 비유를 들어 설명하세요.
                - "자, 여기를 보시죠", "이것이 왜 중요할까요?" 같은 문구로 시청자의 주의를 환기하세요.
                - 논리적인 흐름(A이므로 B이다)을 명확히 하세요.`,
            'conversational': `
                - **옆집 친구에게 말하듯 편안하고 친근한 반말**(~해, ~했어)을 사용하세요.
                - 무거운 주제도 가볍고 위트 있게 풀어내세요.
                - "있잖아, 그거 알아?", "진짜 대박이지 않아?" 같은 구어체 추임새를 적절히 섞으세요.
                - 시청자의 공감을 이끌어내는 문장을 자주 사용하세요.`,
            'storytelling': `
                - **훌륭한 이야기꾼(Storyteller)**이 되어, 듣는 이가 다음 내용이 궁금해 미치도록 만드세요.
                - **"도대체 왜 그랬을까요?", "하지만 여기서 반전이 일어납니다."**와 같은 **호기심 유발 질문(Curiosity Gap)**을 지속적으로 던지세요.
                - 단순한 사실 나열을 멈추고, 눈앞에 그려지는 듯한 **생생하고 감각적인 묘사**를 사용하세요.
                - 문장과 문장 사이를 매끄럽게 잇는 **연결 고리(Bridge)**를 사용하여 몰입감을 깨뜨리지 마세요.
                - 긴장감을 조성했다가 해소하는 방식을 사용하여 드라마틱한 전개를 만드세요.`
        };

        // [NEW] 글로벌 설정에서 커스텀 프롬프트 가져오기
        let selectedStyleInstruction = styleInstructionMap[style] || styleInstructionMap['narration'];

        if (style === 'news' || style === 'story') {
            try {
                const settingsRes = await fetch('/api/settings');
                const settingsData = await settingsRes.json();
                if (settingsData.script_styles && settingsData.script_styles[style]) {
                    selectedStyleInstruction = `- **${style === 'news' ? '뉴스 보도' : '옛날 이야기'} 스타일 지침:**\n${settingsData.script_styles[style]}`;
                }
            } catch (e) {
                console.error("Failed to fetch custom style prompts:", e);
            }
        }

        // 섹션이 없으면 기존 방식(통생성)으로 처리
        if (sections.length === 0) {
            // Fallback: 섹션이 없을 경우 처리 로직이 필요하지만, 현재는 구조화된 데이터를 기본으로 가정합니다.
            console.warn("No sections found in structure data.");
        }

        Utils.setLoading(btn, true, `대본 생성 중... (0 / ${sections.length})`);
        document.getElementById('resultSection').classList.remove('hidden'); // 미리 보여줌

        // [NEW] Stop Button Logic
        document.getElementById('stopBtn').classList.remove('hidden');

        try {
            console.log(`Starting generation for ${sections.length} sections.`);
            for (let i = 0; i < sections.length; i++) {
                if (window.stopGeneration) {
                    console.log("Generation stopped by user.");
                    Utils.showToast('생성이 중단되었습니다. 현재까지의 내용을 저장합니다.', 'warning');
                    break;
                }

                const section = sections[i];
                console.log(`Processing section ${i + 1}/${sections.length}: ${section.title}`);
                Utils.setLoading(btn, true, `대본 생성 중... (${i + 1}/${sections.length} - ${section.title})`);

                // 섹션별 예상 길이 계산 (초 단위)
                const sectionDuration = Math.floor(duration / sections.length);
                // 한국어 말하기 속도: 초당 약 2.5~3음절. 넉넉하게 2.5~5자 범위로 가이드.
                const minChars = Math.floor(sectionDuration * 2.5);
                const maxChars = Math.floor(sectionDuration * 5);
                const sectionTargetMsg = `${sectionDuration}초 분량 (최소 ${minChars}자 ~ 최대 ${maxChars}자 내외)`;

                const sectionPrompt = `당신은 ${duration}초 분량의 유튜브 장편 영상 대본 작가입니다.
전체 기획된 대본 구조 중 ** "${section.title}" ** 파트를 작성해주세요.

[전체 대본 구조]
${fullStructureSummary}

        [현재 작성할 파트]
            - 섹션: ${section.title}
        - 주요 내용: ${section.key_points.join(', ')}
        - 목표 길이: ${sectionTargetMsg} (이 섹션만 충실하게 작성)

        [작성 지침]
        1. 앞뒤 문맥('이전 섹션 요약' 참고)을 고려하여 자연스럽게 이어지도록 쓰세요.
        2. ** 스타일 지침(매우 중요):**
            ${selectedStyleInstruction}

         3. ** 분량을 충분히 뽑아주세요.** 
            - 현재 섹션의 목표 분량은 **${minChars}자 이상**입니다. 
            - 내용이 부족하다면 구체적인 사례, 통계, 전문가의 견해, 관련 비하인드 스토리 등을 추가하여 내용을 대폭 보강하세요.
            - 핵심 키포인트를 하나하나 심도 있게 다루십시오.
        4. 섹션 제목(예: [서론])은 출력하지 말고, 오직 대본 본문만 작성하세요.
        5. ** 반드시 한국어로 작성하세요.** (1차 생성은 무조건 한국어)
        6. **현재 섹션의 내용만 작성하고, 절대 다음 섹션(결론 등)이나 마무리 멘트를 미리 작성하지 마세요.**

        [이전까지 내용 요약(문맥 참고용)]
${finalScript.length > 500 ? finalScript.substring(finalScript.length - 500) : finalScript} ... (직전 내용)

오직 대본 본문만 작성하세요.`;

                try {
                    // 60초 타임아웃 레이스
                    const fetchPromise = API.gemini.generate(sectionPrompt, { temperature: 0.7, maxTokens: 4096 });
                    const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 90000));

                    const result = await Promise.race([fetchPromise, timeoutPromise]);

                    if (result.status === 'ok') {
                        const sectionText = result.text.trim();
                        // 중복 방지: 이미 내용이 포함된 경우 건너뛰기
                        if (!finalScript.includes(sectionText.substring(0, 20))) {
                            finalScript += `\n\n ** [${section.title}] **\n${sectionText} `;
                        }

                        // [NEW] 중간 결과 저장 (매 섹션마다)
                        Utils.storage.set('fullScript', {
                            topic: structureData?.topic || '영상',
                            script: finalScript,
                            timestamp: Date.now()
                        });
                        if (projectId) {
                            API.project.saveScript(projectId, finalScript, finalScript.length, Math.ceil(finalScript.length / 415)).catch(e => console.error("Auto-save failed:", e));
                        }

                        // 중간 결과 표시
                        const textArea = document.getElementById('scriptContent');
                        if (textArea) textArea.value = finalScript;
                        updateStats();
                        console.log(`Section ${i + 1} complete.`);
                    } else {
                        console.error(`Section ${i + 1} failed`, result);
                        finalScript += `\n\n[${section.title} 파트 생성 실패]\n`;
                    }
                } catch (innerErr) {
                    console.error(`Error generating section ${i + 1}:`, innerErr);
                    finalScript += `\n\n[${section.title} 파트 생성 중 오류 발생]\n`;
                }

                // API Rate Limit 방지용 대기 (마지막 섹션 제외)
                if (i < sections.length - 1) {
                    console.log(`Waiting before next section...`);
                    await new Promise(r => setTimeout(r, 1000));
                }
            }

            console.log("All sections completed.");

            // 최종 완료
            currentScript = finalScript;
            Utils.storage.set('fullScript', {
                topic: structureData?.topic || '영상',
                script: currentScript,
                timestamp: Date.now()
            });

            // [FIX] DB에 대본 저장 (중요: 그래야 진행상태가 업데이트됨)
            if (projectId) {
                try {
                    const charCount = currentScript.length;
                    const readTime = Math.ceil(charCount / 415);
                    await API.project.saveScript(projectId, currentScript, charCount, readTime);
                    console.log("Script saved to DB successfully.");
                } catch (dbErr) {
                    console.error("Failed to save script to DB:", dbErr);
                }
            }

            Utils.showToast('전체 대본 생성이 완료되었습니다', 'success');

            // 번역 버튼 표시 여부 체크
            checkTranslationAvailability(targetLanguage);

            // [NEW] 대본 기반 제목 자동 생성 및 저장
            if (!window.stopGeneration) {
                await autoGenerateTitle(projectId, currentScript);
            }

        } catch (error) {
            console.error('생성 오류:', error);
            Utils.showToast('생성 중 오류가 발생했습니다: ' + error.message, 'error');
        } finally {
            console.log("Process finished, resetting button.");
            Utils.setLoading(btn, false);
            document.getElementById('stopBtn').classList.add('hidden');
            window.stopGeneration = false;
        }
    }

    // 제목 자동 생성 및 저장 함수
    async function autoGenerateTitle(projectId, script) {
        try {
            Utils.showToast('AI가 최적의 제목을 선정하고 있습니다...', 'info');

            const prompt = `당신은 유튜브 썸네일/제목 어그로 장인입니다.
다음 대본 내용을 바탕으로 클릭률(CTR)을 극대화할 수 있는 **가장 강력한 후킹성 제목 1개**를 작성해주세요.

[대본 요약]
${script.substring(0, 2000)}...

[조건]
1. 따옴표 없이 제목 텍스트만 출력하세요.
2. 30자 이내로 짧고 강렬하게 작성하세요.
3. 호기심을 자극하거나 이득을 강조하는 스타일이어야 합니다.
4. 예시: "이것만 알면 인생이 바뀝니다", "99%가 모르는 충격적인 사실"
5. **오직 제목 1줄만 반환하세요.**`;

            const result = await API.gemini.generate(prompt, { temperature: 0.8 });

            if (result.status === 'ok') {
                let newTitle = result.text.trim().replace(/^["']|["']$/g, ''); // 따옴표 제거
                console.log("Auto-generated Title:", newTitle);

                // 프로젝트 정보 업데이트
                await API.project.update(projectId, { video_title: newTitle });

                Utils.showToast(`제목이 자동 설정되었습니다: ${newTitle}`, 'success');

                // (선택) 상단 헤더 업데이트가 가능하다면 수행 (헤더에 제목 표시 기능이 있다면)
                // const titleEl = document.getElementById('projectTitleDisplay');
                // if(titleEl) titleEl.textContent = newTitle;
            }
        } catch (e) {
            console.error("Auto title generation failed:", e);
            // 제목 생성 실패는 크리티컬하지 않으므로 조용히 넘어감 (로그만 남김)
        }
    }

    function stopAndSave() {
        if (window.confirm('대본 생성을 강제로 중단하고 현재까지의 내용을 저장하시겠습니까?\n(마지막 섹션 생성 작업은 완료될 때까지 기다릴 수 있습니다.)')) {
            window.stopGeneration = true;
            const btn = document.getElementById('stopBtn');
            btn.innerHTML = '🛑 중단 중...';
            btn.disabled = true;
        }
    }

    function updateStats() {
        const text = document.getElementById('scriptContent').value;
        const charCount = text.length;
        const readTime = Math.ceil(charCount / 415); // 분당 415자 기준 (Edge TTS 1.0 속도 최적화)

        document.getElementById('charCount').textContent = `${charCount.toLocaleString()} 자`;
        document.getElementById('readTime').textContent = `예상 읽기 시간: ${readTime} 분`;
    }

    document.getElementById('scriptContent')?.addEventListener('input', updateStats);

    function copyScript() {
        const text = document.getElementById('scriptContent').value;
        Utils.copyToClipboard(text);
        Utils.showToast('복사되었습니다', 'success');
    }

    function downloadScript() {
        const text = document.getElementById('scriptContent').value;
        const topic = Utils.storage.get('scriptStructure')?.topic || '대본';
        Utils.downloadFile(text, `${topic} _대본.txt`);
    }

    function goToImageGen() {
        window.location.href = '/image-gen';
    }

    function goToTTS() {
        window.location.href = '/tts';
    }

    // 프로젝트 상태 복구 이벤트 수신
    window.addEventListener('projectStateRestored', (e) => {
        const data = e.detail;

        // 1. 대본 데이터 복구
        if (data.script && data.script.full_script) {
            currentScript = data.script.full_script;
            const textarea = document.getElementById('scriptContent');
            if (textarea) textarea.value = currentScript;

            document.getElementById('resultSection').classList.remove('hidden');
            if (window.updateStats) updateStats();

            // 로컬 스토리지 동기화
            Utils.storage.set('fullScript', {
                topic: data.project?.topic || '영상',
                script: currentScript,
                timestamp: Date.now()
            });
        }

        // 2. 구조 데이터 복구 (필요시)
        if (data.script_structure) {
            Utils.storage.set('scriptStructure', data.script_structure);
        }
    });

    // 초기 로드 시 로컬 스토리지 확인
    document.addEventListener('DOMContentLoaded', () => {
        const savedScript = Utils.storage.get('fullScript');
        if (savedScript && savedScript.script) {
            currentScript = savedScript.script;
            const textarea = document.getElementById('scriptContent');
            if (textarea) textarea.value = currentScript;
            document.getElementById('resultSection').classList.remove('hidden');
            if (window.updateStats) updateStats();
        }
    });
    function checkTranslationAvailability(targetLang) {
        if (targetLang && targetLang !== 'ko') {
            const btn = document.getElementById('translateBtn');
            btn.classList.remove('hidden');
            btn.textContent = `🌐 ${targetLang === 'en' ? '영어' : targetLang === 'ja' ? '일본어' : '외국어'}로 번역하기`;
            btn.dataset.lang = targetLang;
        }
    }

    async function translateScript() {
        const btn = document.getElementById('translateBtn');
        const targetLang = btn.dataset.lang;
        const script = document.getElementById('scriptContent').value;

        if (!script) return;

        if (!confirm('현재 대본을 번역하시겠습니까? (기존 내용은 덮어씌워집니다)')) return;

        const originalText = btn.innerHTML;
        Utils.setLoading(btn, true, '번역 중...');

        try {
            const response = await fetch('/api/gemini/translate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    text: script,
                    target_language: targetLang
                })
            });

            const result = await response.json();

            if (result.status === 'ok') {
                const translated = result.translated_text;
                document.getElementById('scriptContent').value = translated;
                currentScript = translated;
                updateStats(); // 글자수 업데이트

                // 저장
                const topic = document.getElementById('structureTopic').value || '영상';
                Utils.storage.set('fullScript', {
                    topic: topic,
                    script: translated,
                    timestamp: Date.now()
                });

                // DB 저장 (선택 사항, 유저가 원할 때 저장하게 놔둘 수도 있지만 일단 자동 저장이 없으므로)

                Utils.showToast('번역이 완료되었습니다', 'success');
            } else {
                throw new Error(result.error);
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('번역 실패: ' + e.message, 'error');
        } finally {
            Utils.setLoading(btn, false);
            btn.innerHTML = originalText;
        }
    }

    // 프로젝트 로드 시에도 언어 체크
    window.addEventListener('projectChanged', async (e) => {
        const projectId = e.detail.projectId;
        try {
            const projectFull = await API.project.getFull(projectId);
            if (projectFull && projectFull.settings && projectFull.settings.target_language) {
                checkTranslationAvailability(projectFull.settings.target_language);
            }
        } catch (e) { }
    });

    // [NEW] 탭 전환 및 수동 등록 로직
    function setScriptMode(mode) {
        const tabAI = document.getElementById('tabAI');
        const tabManual = document.getElementById('tabManual');
        const sectionAI = document.getElementById('aiGenSection');
        const sectionManual = document.getElementById('manualInputSection');

        if (mode === 'ai') {
            // Activate AI Tab
            tabAI.classList.add('border-blue-500', 'text-blue-600', 'dark:text-blue-400');
            tabAI.classList.remove('border-transparent', 'text-gray-500', 'dark:text-gray-400');

            // Deactivate Manual Tab
            tabManual.classList.remove('border-blue-500', 'text-blue-600', 'dark:text-blue-400');
            tabManual.classList.add('border-transparent', 'text-gray-500', 'dark:text-gray-400');

            sectionAI.classList.remove('hidden');
            sectionManual.classList.add('hidden');
        } else {
            // Activate Manual Tab
            tabManual.classList.add('border-blue-500', 'text-blue-600', 'dark:text-blue-400');
            tabManual.classList.remove('border-transparent', 'text-gray-500', 'dark:text-gray-400');

            // Deactivate AI Tab
            tabAI.classList.remove('border-blue-500', 'text-blue-600', 'dark:text-blue-400');
            tabAI.classList.add('border-transparent', 'text-gray-500', 'dark:text-gray-400');

            sectionAI.classList.add('hidden');
            sectionManual.classList.remove('hidden');
        }
    }

    async function registerManualScript() {
        const scriptInput = document.getElementById('manualScriptInput');
        const scriptText = scriptInput.value.trim();

        if (!scriptText) {
            Utils.showToast('대본 내용을 입력해주세요', 'warning');
            return;
        }

        const projectId = getCurrentProject();
        // 기획 데이터에서 주제 가져오기
        const structureData = Utils.storage.get('scriptStructure') || {};
        const topic = structureData.topic || '외부 대본';

        // 1. UI 및 변수 업데이트
        currentScript = scriptText;
        const textArea = document.getElementById('scriptContent');
        if (textArea) textArea.value = currentScript;

        document.getElementById('resultSection').classList.remove('hidden');
        updateStats();

        // 2. 저장 (로컬 + DB)
        Utils.storage.set('fullScript', {
            topic: topic,
            script: currentScript,
            timestamp: Date.now()
        });

        if (projectId) {
            try {
                const charCount = currentScript.length;
                const readTime = Math.ceil(charCount / 415);
                await API.project.saveScript(projectId, currentScript, charCount, readTime);
                Utils.showToast('대본이 성공적으로 등록되었습니다', 'success');

                // 제목 자동 생성 (선택 사항)
                // await autoGenerateTitle(projectId, currentScript); 

                // 스크롤 이동
                document.getElementById('resultSection').scrollIntoView({ behavior: 'smooth' });

                // 탭을 AI 모드로 복귀? 아니면 그대로? -> 그대로 둠.

            } catch (e) {
                console.error("Manual save failed:", e);
                Utils.showToast('저장 중 오류가 발생했습니다', 'error');
            }
        } else {
            Utils.showToast('로컬에 저장되었습니다 (프로젝트 미선택)', 'info');
            document.getElementById('resultSection').scrollIntoView({ behavior: 'smooth' });
        }
    }

    function copyStructurePreview() {
        const text = document.getElementById('previewContent').textContent;
        Utils.copyToClipboard(text);
        Utils.showToast('구조 데이터가 복사되었습니다', 'success');
    }
</script>
{% endblock %}