{% extends "base.html" %}

{% block content %}
<style>
    .style-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
        gap: 10px;
    }

    .style-card-thumb {
        cursor: pointer;
        border: 2px solid transparent;
        border-radius: 8px;
        overflow: hidden;
        transition: all 0.2s;
        background: #f3f4f6;
        position: relative;
    }

    .dark .style-card-thumb {
        background: #374151;
    }

    .style-card-thumb:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }

    .style-card-thumb.active {
        border-color: #3b82f6;
        box-shadow: 0 0 0 2px #3b82f6;
    }

    .style-card-thumb img {
        width: 100%;
        aspect-ratio: 16/9;
        object-fit: cover;
    }

    .style-label {
        padding: 6px;
        text-align: center;
        font-size: 0.75rem;
        font-weight: 600;
        color: #4b5563;
    }

    .dark .style-label {
        color: #ffffff;
    }

    .style-card-thumb.active .style-label {
        background: #3b82f6;
        color: white;
    }
</style>


<!-- 1ë‹¨ê³„: ì•„ì´ë””ì–´ ìƒì„± -->
<div class="card mb-6">
    <h3 class="font-bold text-gray-800 dark:text-white mb-4">{{ t('thumb_stage_1') }}</h3>
    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
        <div>
            <label class="block text-sm font-medium text-gray-700 dark:text-white mb-2">{{ t('label_video_topic')
                }}</label>
            <input type="text" id="videoTitle" class="input-field" placeholder="{{ t('placeholder_video_topic') }}">
        </div>
        <div class="md:col-span-2">
            <div class="flex items-center justify-between mb-3">
                <label class="block text-sm font-medium text-gray-700 dark:text-white">{{ t('label_select_style')
                    }}</label>
                <button onclick="saveThumbnailStyle()" id="saveStyleBtn"
                    class="px-3 py-1 text-xs bg-green-600 hover:bg-green-700 text-white rounded shadow transition flex items-center gap-1">
                    <span>ğŸ’¾</span>
                    <span>{{ t('btn_save_settings_only') }}</span>
                </button>
            </div>
            <input type="hidden" id="thumbnailStyle" value="face">
            <div id="thumbnailStyleGrid" class="style-grid">
                <!-- Loaded via JS -->
            </div>
        </div>
    </div>
    <!-- ìƒ‰ìƒ í†¤, ë¹„ìœ¨ ì„¤ì • ì œê±°ë¨ -->


    <!-- ë²„íŠ¼ ê·¸ë¦¬ë“œ (Compact) -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-3 md:col-span-3">
        <button onclick="generateIdeas()" id="ideaBtn"
            class="btn-primary py-3 text-sm font-bold shadow-md hover:shadow-lg transition-all flex items-center justify-center gap-2">
            <span class="text-lg">ğŸ’¡</span>
            <span>{{ t('btn_gen_ideas') }}</span>
        </button>

        <button onclick="generateHookTexts()" id="hookTextBtn"
            class="btn-secondary py-3 text-sm font-bold shadow-md hover:shadow-lg transition-all flex items-center justify-center gap-2">
            <span class="text-lg">ğŸ¤–</span>
            <div class="flex flex-col items-center">
                <span>{{ t('btn_gen_hook_texts') }}</span>
                <span class="text-[9px] opacity-75">{{ t('btn_gen_hook_helper') }}</span>
            </div>
        </button>
    </div>
</div>

<!-- AI ìƒì„± ë¬¸êµ¬ í‘œì‹œ ì˜ì—­ -->
<div id="hookTextsSection" class="hidden card mb-4">
    <h4 class="text-sm font-bold text-blue-800 dark:text-blue-300 mb-3 flex items-center gap-2">
        <span>ğŸ¯</span>
        <span>{{ t('ai_recommend_hook') }}</span>
    </h4>
    <div id="hookTextsList" class="flex flex-wrap gap-2 mb-3"></div>
    <p id="hookReasoning" class="text-xs text-blue-600 dark:text-blue-400 italic"></p>
</div>

<!-- 2ë‹¨ê³„: ì•„ì´ë””ì–´ ì„ íƒ ë° ì´ë¯¸ì§€ ìƒì„± -->
<div id="ideasSection" class="card mb-6 hidden">
    <h3 class="font-bold text-gray-800 dark:text-white mb-4">{{ t('thumb_stage_2') }}</h3>
    <div id="ideasList" class="space-y-4 mb-4"></div>
</div>

<!-- 3ë‹¨ê³„: í…ìŠ¤íŠ¸ ì¶”ê°€ -->
<div id="textSection" class="card mb-6 hidden">
    <h3 class="font-bold text-gray-800 dark:text-white mb-4">{{ t('thumb_stage_3') }}</h3>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 dark:text-white mb-2">{{
                    t('label_text_candidates') }}</label>
                <div id="textCandidates" class="flex flex-wrap gap-2 mb-3"></div>
            </div>



            <div id="layersContainer" class="space-y-4 mb-6">
                <!-- ë ˆì´ì–´ë“¤ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
            </div>

            <button onclick="addLayer()" class="btn-secondary w-full mb-4 text-sm">
                {{ t('btn_add_text_layer') }}
            </button>

            <div class="border-t border-gray-200 dark:border-gray-700 my-4 pt-4">
                <p class="text-xs text-gray-500 mb-2">{{ t('helper_step_1') }}</p>
                <div class="flex gap-2 mb-3">
                    <button onclick="document.getElementById('bgUploadInput').click()"
                        class="flex-1 btn-secondary py-2">
                        {{ t('btn_upload_bg') }}
                    </button>
                    <input type="file" id="bgUploadInput" class="hidden" accept="image/*"
                        onchange="uploadBackgroundImage(this)">

                    <button onclick="generateBackground()" id="bgBtn" class="flex-1 btn-secondary py-2">
                        {{ t('btn_ai_gen_bg') }}
                    </button>
                </div>

                <p class="text-xs text-gray-500 mb-2">{{ t('helper_step_2') }}</p>
                <div class="flex gap-2">
                    <button onclick="generateFinalThumbnail()" id="generateBtn" class="flex-[3] btn-primary py-3">
                        {{ t('btn_finalize_thumb') }}
                    </button>
                    <button onclick="savePermanentSettings()" id="saveSettingsBtn"
                        class="flex-1 btn-secondary py-3 flex items-center justify-center gap-2"
                        title="í˜„ì¬ ëª¨ë“  ì„¤ì •ì„ ì„œë²„ì— ì˜êµ¬ ì €ì¥í•©ë‹ˆë‹¤.">
                        <span>ğŸ’¾</span>
                        <span class="hidden md:inline">ì„¤ì • ì €ì¥</span>
                    </button>
                </div>
            </div>
        </div>

        <div class="space-y-4">
            <div>
                <label class="block text-sm font-medium text-gray-700 dark:text-white mb-2">{{
                    t('label_preview_layout') }}</label>
                <div id="previewContainer"
                    class="bg-gray-100 dark:bg-gray-700 rounded-lg p-2 relative overflow-hidden flex items-center justify-center transition-all duration-300 max-h-[600px] mx-auto">
                    <canvas id="thumbnailCanvas" width="1280" height="720"
                        class="w-full h-auto rounded shadow-inner bg-gray-200 dark:bg-gray-800"></canvas>
                    <div id="previewPlaceholder"
                        class="absolute inset-0 flex items-center justify-center pointer-events-none">
                        <span class="text-gray-500 text-sm">{{ t('placeholder_select_idea') }}</span>
                    </div>
                </div>
            </div>

            <div class="bg-yellow-50 dark:bg-yellow-900/20 rounded-lg p-4">
                <h4 class="text-xs font-bold text-yellow-800 dark:text-yellow-300 mb-1 uppercase">Styling Tip</h4>
                <p class="text-xs text-yellow-700 dark:text-yellow-400">
                    ë°”ì´ëŸ´ ìŠ¤íƒ€ì¼ì„ ìœ„í•´ <b>ì™¸ê³½ì„ (Stroke)</b>ì„ êµµê²Œ í•˜ê³  <b>Gmarket Sans</b> í°íŠ¸ë¥¼ ì‚¬ìš©í•´ ë³´ì„¸ìš”.
                </p>
            </div>

            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 dark:text-white mb-2">{{
                    t('label_shape_layer') }}</label>
                <div id="shapeLayersContainer" class="space-y-4 mb-4"></div>
                <button onclick="addShapeLayer()" class="btn-secondary w-full text-sm">
                    {{ t('btn_add_shape_layer') }}
                </button>
            </div>
        </div>
    </div>
</div>

<!-- 4ë‹¨ê³„: ê²°ê³¼ -->
<div id="resultSection" class="card hidden">
    <h3 class="font-bold text-gray-800 dark:text-white mb-4">{{ t('thumb_stage_4') }}</h3>
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div class="flex justify-center items-center bg-gray-100 dark:bg-gray-800 rounded-lg p-2">
            <img id="resultImage" src="" alt="Generated Thumbnail"
                class="max-h-80 w-auto rounded shadow-lg object-contain">
        </div>
        <div class="space-y-4">
            <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
                <h4 class="font-medium text-gray-800 dark:text-white mb-2">ğŸ“ {{ t('image_info_title') }}</h4>
                <p id="thumbnailSizeInfo" class="text-sm text-gray-600 dark:text-gray-400">{{ t('label_size') }}:
                    1280 x 720 (16:9)</p>
                <p class="text-sm text-gray-600 dark:text-gray-400">í˜•ì‹: PNG</p>
            </div>
            <div class="flex gap-2">
                <a id="downloadLink" href="" download="thumbnail.png" class="flex-1 btn-primary text-center">
                    {{ t('btn_download') }}
                </a>
                <button onclick="regenerate()" class="btn-secondary">
                    {{ t('btn_regen') }}
                </button>
            </div>
            <div class="bg-blue-50 dark:bg-blue-900/20 rounded-lg p-4">
                <h4 class="font-medium text-blue-800 dark:text-blue-300 mb-2">ğŸ’¡ íŒ</h4>
                <ul class="text-sm text-blue-700 dark:text-blue-400 space-y-1">
                    <li>â€¢ í…ìŠ¤íŠ¸ëŠ” 3-5ë‹¨ì–´ê°€ ìµœì </li>
                    <li>â€¢ ëŒ€ë¹„ê°€ ê°•í•œ ìƒ‰ìƒ ì‚¬ìš©</li>
                    <li>â€¢ ì–¼êµ´ì´ ìˆìœ¼ë©´ í´ë¦­ë¥  UP</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- ìƒì„± ì´ë ¥ -->
    <div class="mt-6">
        <h4 class="font-medium text-gray-800 dark:text-white mb-3">ğŸ“œ {{ t('history_title') }}</h4>
        <div id="historyList" class="grid grid-cols-4 md:grid-cols-6 gap-2"></div>
    </div>
</div>

{% endblock %}

{% block scripts %}
<script src="/static/js/thumbnail_hook_text.js?v=2"></script>
<script>
    window.targetLang = 'ko';
    let thumbnailData = null;
    let selectedPrompt = null;
    let selectedIdeaIndex = -1;
    let generatedHistory = [];
    let currentBackgroundPath = null; // ìƒì„±ëœ ë°°ê²½ ì´ë¯¸ì§€ ê²½ë¡œ (ë°±ì—”ë“œìš©)
    let currentBackgroundUrl = null; // ìƒì„±ëœ ë°°ê²½ ì´ë¯¸ì§€ URL (í”„ë¡ íŠ¸ì—”ë“œìš©)
    let currentAspectRatio = '16:9'; // [NEW] Default AR

    // í…ìŠ¤íŠ¸ ë ˆì´ì–´ ìƒíƒœ (ë™ì  ê´€ë¦¬)
    let textLayers = [
        { text: 'í…ìŠ¤íŠ¸ ì…ë ¥...', position: 'center', x_offset: 0, y_offset: 0, font_family: 'malgun', font_size: 72, color: '#FFFFFF', stroke_color: '#000000', stroke_width: 2, bg_color: null }
    ];

    // ë„í˜• ë ˆì´ì–´ ìƒíƒœ
    let shapeLayers = [];

    // ë“œë˜ê·¸ ìƒíƒœ ë³€ìˆ˜
    let isDragging = false;
    let draggedLayerIndex = -1;
    let dragStartX = 0;
    let dragStartY = 0;
    let initialLayerX = 0;
    let initialLayerY = 0;
    let layerBBoxes = []; // íˆíŠ¸ í…ŒìŠ¤íŠ¸ìš© ì¢Œí‘œ ì €ì¥ [{x, y, w, h, index}]

    // ë„í˜• í¬ê¸° ì¡°ì ˆ ê´€ë ¨ ë³€ìˆ˜
    let selectedShapeIndex = -1;
    let resizeHandle = null; // 'nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'
    let shapeBBoxes = [];
    let shapeHandleBBoxes = [];
    let initialShapeParams = {};

    // í”„ë¡œì íŠ¸ ë°ì´í„° ë¡œë“œ
    document.addEventListener('DOMContentLoaded', async () => {
        const projectId = getCurrentProject();
        initCanvasEvents(); // ìº”ë²„ìŠ¤ ì´ë²¤íŠ¸ ì´ˆê¸°í™”
        await loadThumbnailStyles(); // [NEW]

        if (projectId) {
            try {
                // 1. ë¡œì»¬ ìƒíƒœ ë¨¼ì € ë³µêµ¬ (Session)
                await loadStateFromLocal();

                // í”„ë¡œì íŠ¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ì–¸ì–´ ì„¤ì •)
                const project = await API.project.get(projectId);
                if (project) {
                    if (project.target_language) {
                        window.targetLang = project.target_language;
                    }
                    const titleEl = document.getElementById('videoTitle');
                    // Only set title if empty (preserve local change)
                    if (titleEl && !titleEl.value) {
                        titleEl.value = project.title || project.topic || '';
                    }
                }

                // ë¶„ì„ ë°ì´í„°ì—ì„œ ì œëª© ê°€ì ¸ì˜¤ê¸° (Legacy, now part of project.title/topic)
                const analysis = await API.project.getAnalysis(projectId);
                if (analysis?.video_title && !document.getElementById('videoTitle').value) {
                    document.getElementById('videoTitle').value = analysis.video_title;
                }

                // ê¸°ì¡´ ì €ì¥ëœ ì¸ë„¤ì¼ URL ë¡œë“œ
                // ê¸°ì¡´ ì €ì¥ëœ ì¸ë„¤ì¼ URL ë¡œë“œ
                const settings = await API.project.getSettings(projectId);
                let thumbUrl = settings?.thumbnail_url;

                // [Fallback] URL ì—†ìœ¼ë©´ ê²½ë¡œ ê¸°ë°˜ ì¶”ì 
                if (!thumbUrl && settings?.thumbnail_path) {
                    const path = settings.thumbnail_path;
                    if (path.includes('static')) {
                        // Convert local path to static URL
                        const parts = path.split('static');
                        thumbUrl = '/static' + parts[1].replace(/\\/g, '/');
                    } else {
                        // Force standard path
                        thumbUrl = `/static/projects/${projectId}/thumbnail.png`;
                    }
                }

                if (thumbUrl) {
                    // ê²°ê³¼ ì„¹ì…˜ í‘œì‹œ
                    const img = document.getElementById('resultImage');
                    img.src = `${thumbUrl}?t=${new Date().getTime()}`; // Cache bust

                    document.getElementById('downloadLink').href = thumbUrl;
                    document.getElementById('resultSection').classList.remove('hidden');

                    // ì´ë ¥ì— ì—†ìœ¼ë©´ ì¶”ê°€
                    if (!generatedHistory.includes(thumbUrl)) {
                        generatedHistory.unshift(thumbUrl);
                    }
                    updateHistory();
                }
                // [NEW] Sync Thumbnail Style with Image Style
                // [NEW] Prioritize Saved Thumbnail Style, else fallback to Sync with Image Style
                if (settings?.thumbnail_style) {
                    // Load saved style (no need to save again)
                    selectThumbnailStyle(settings.thumbnail_style, false);
                    console.log(`Loaded saved thumbnail style: '${settings.thumbnail_style}'`);
                } else if (settings?.image_style_prompt) {
                    // Fallback: Sync with Image Style (and save as initial default)
                    const styleMap = {
                        'ghibli': 'ghibli', 'wimpy': 'wimpy', 'minimal': 'minimal',
                        'cinematic': 'dramatic', 'realistic': 'face', 'webtoon': 'japanese_viral',
                        'anime': 'japanese_viral', '3d': 'dramatic'
                    };
                    const targetStyle = styleMap[settings.image_style_prompt];
                    if (targetStyle) {
                        selectThumbnailStyle(targetStyle, true);
                        console.log(`Synced thumbnail style to '${targetStyle}' from image style '${settings.image_style_prompt}'`);
                    }
                }

                // [NEW] Auto Aspect Ratio based on Project Settings
                if (settings?.aspect_ratio) {
                    setAspectRatio(settings.aspect_ratio);
                    console.log(`Auto-set Aspect Ratio to ${settings.aspect_ratio} from project settings`);
                } else if (settings?.app_mode === 'shorts') {
                    setAspectRatio('9:16');
                }
            } catch (e) {
                console.log('í”„ë¡œì íŠ¸ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨', e);
            }
        }
    });

    // setAspectRatio implementation moved to line ~1506


    // [NEW] Dynamically load styles
    async function loadThumbnailStyles() {
        const grid = document.getElementById('thumbnailStyleGrid');
        if (!grid) return;

        try {
            const res = await fetch('/api/settings/thumbnail-style-presets');
            const presets = await res.json();

            const displayNames = {
                'face': 'ì–¼êµ´ ê°•ì¡°í˜•',
                'text': 'í…ìŠ¤íŠ¸ ì¤‘ì‹¬í˜•',
                'contrast': 'ë¹„í¬/ì• í”„í„°í˜•',
                'mystery': 'ë¯¸ìŠ¤í„°ë¦¬í˜•',
                'minimal': 'ë¯¸ë‹ˆë©€í˜•',
                'dramatic': 'ë“œë¼ë§ˆí‹±í˜•',
                'ghibli': 'ì§€ë¸Œë¦¬ ê°ì„±',
                'wimpy': 'ìœ”í”¼í‚¤ë“œ ìŠ¤íƒ€ì¼',
                'ì‹œë‹ˆì–´ì‚¬ì—°2': 'ì‹œë‹ˆì–´ì‚¬ì—°2'
            };

            const currentStyle = document.getElementById('thumbnailStyle').value;

            grid.innerHTML = Object.entries(presets).map(([key, data]) => {
                const imageUrl = (typeof data === 'object' && data.image_url) ? data.image_url : `/static/img/thumbs/${key}.png`;
                const displayName = displayNames[key] || key;
                const isActive = key === currentStyle ? 'active' : '';

                return `
                    <div class="style-card-thumb ${isActive}" onclick="selectThumbnailStyle('${key}')" data-style="${key}">
                        <img src="${imageUrl}" alt="${displayName}" loading="lazy" 
                             onerror="this.onerror=null; this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22160%22 height=%2290%22%3E%3Crect fill=%22%23374151%22 width=%22160%22 height=%2290%22/%3E%3Ctext fill=%22%239CA3AF%22 x=%22%2550%22 y=%22%2550%22 text-anchor=%22middle%22 dy=%22.3em%22%3ENo Image%3C/text%3E%3C/svg%3E';">
                        <div class="style-label">${displayName}</div>
                    </div>
                    `;
            }).join('');
        } catch (e) {
            console.error("Failed to load thumbnail styles:", e);
        }
    }

    // [NEW] Save Thumbnail Style Button Handler
    async function saveThumbnailStyle() {
        const styleId = document.getElementById('thumbnailStyle').value;
        const projectId = getCurrentProject();
        const btn = document.getElementById('saveStyleBtn');

        if (!projectId) {
            Utils.showToast("í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.", "warning");
            return;
        }

        const originalText = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span>ğŸ”„</span><span>ì €ì¥ì¤‘...</span>';

        try {
            // Save to project settings
            await API.project.saveSettings(projectId, { thumbnail_style: styleId });
            Utils.showToast(`ì¸ë„¤ì¼ ìŠ¤íƒ€ì¼ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤: ${styleId}`, "success");
            console.log('Thumbnail style saved:', styleId);
        } catch (e) {
            console.error('Failed to save thumbnail style:', e);
            Utils.showToast("ì €ì¥ ì‹¤íŒ¨: " + e.message, "error");
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalText;
        }
    }

    // ìŠ¤íƒ€ì¼ ì„ íƒ í•¨ìˆ˜ (UI selection only, no auto-save)
    function selectThumbnailStyle(styleId) {
        document.getElementById('thumbnailStyle').value = styleId;

        // UI ì—…ë°ì´íŠ¸
        document.querySelectorAll('.style-card-thumb').forEach(card => {
            if (card.dataset.style === styleId) {
                card.classList.add('active');
            } else {
                card.classList.remove('active');
            }
        });

        console.log('Thumbnail style selected:', styleId);

        // ìŠ¤íƒ€ì¼ì— ë”°ë¥¸ ê¸°ë³¸ í…ìŠ¤íŠ¸ ì„¤ì • ìë™ ìµœì í™”
        if (styleId === 'japanese_viral') {
            // ë ˆì´ì–´ 4ê°œ í™•ë³´
            while (textLayers.length < 4) {
                textLayers.push({ text: 'ì¶”ê°€ í…ìŠ¤íŠ¸', position: 'center', font_family: 'gmarket', font_size: 90, color: '#FFFFFF', stroke_color: '#000000', stroke_width: 5, bg_color: null });
            }

            const x_shift = -320; // ì¢Œì¸¡ ì •ë ¬ íš¨ê³¼

            // Layer 1: Green
            if (textLayers[0]) {
                textLayers[0].position = 'row1';
                textLayers[0].x_offset = x_shift;
                textLayers[0].y_offset = 20;
                textLayers[0].font_family = 'gmarket';
                textLayers[0].font_size = 85;
                textLayers[0].color = '#00FF00';
                textLayers[0].stroke_color = '#000000';
                textLayers[0].stroke_width = 8;
            }
            // Layer 2: Cyan
            if (textLayers[1]) {
                textLayers[1].position = 'row2';
                textLayers[1].x_offset = x_shift;
                textLayers[1].y_offset = 20;
                textLayers[1].font_family = 'gmarket';
                textLayers[1].font_size = 85;
                textLayers[1].color = '#00FFFF';
                textLayers[1].stroke_color = '#000000';
                textLayers[1].stroke_width = 8;
            }
            // Layer 3: Purple
            if (textLayers[2]) {
                textLayers[2].position = 'row3';
                textLayers[2].x_offset = x_shift;
                textLayers[2].y_offset = 20;
                textLayers[2].font_family = 'gmarket';
                textLayers[2].font_size = 85;
                textLayers[2].color = '#E000FF';
                textLayers[2].stroke_color = '#FFFFFF';
                textLayers[2].stroke_width = 8;
            }
            // Layer 4: Red + Yellow
            if (textLayers[3]) {
                textLayers[3].position = 'row4';
                textLayers[3].x_offset = x_shift;
                textLayers[3].y_offset = 40;
                textLayers[3].font_family = 'gmarket';
                textLayers[3].font_size = 100;
                textLayers[3].color = '#FF0000';
                textLayers[3].stroke_color = '#FFFF00';
                textLayers[3].stroke_width = 10;
            }

            Utils.showToast('ì‹œë‹ˆì–´ ë¡±í¼ ìŠ¤íƒ€ì¼ (4ì¤„ ì»¬ëŸ¬)ì´ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
        } else if (styleId === 'text') {
            textLayers.forEach(l => { l.bg_color = '#000000'; l.color = '#FFFFFF'; });
        }

        // Only render if textLayers has been initialized and container exists
        try {
            if (textLayers && textLayers.length > 0 && document.getElementById('layersContainer')) {
                renderLayers();
            }
        } catch (e) {
            console.warn("renderLayers skipped:", e);
        }

        console.log("Selected thumbnail style:", styleId);
    }

    // 1. ì•„ì´ë””ì–´ ìƒì„±
    async function generateIdeas() {
        const title = document.getElementById('videoTitle').value.trim() || 'ì˜ìƒ';
        const style = document.getElementById('thumbnailStyle').value;


        // targetLangì€ ì „ì—­ ë³€ìˆ˜ ì‚¬ìš© (DOMContentLoadedì—ì„œ ì„¤ì •ë¨)

        const btn = document.getElementById('ideaBtn');
        Utils.setLoading(btn, true, 'ìƒì„± ì¤‘...');

        const langInstruction = window.targetLang === 'ja' ? 'ì¸ë„¤ì¼ í…ìŠ¤íŠ¸ í›„ë³´(texts)ëŠ” ë°˜ë“œì‹œ "ì¼ë³¸ì–´(Japanese)"ë¡œ ì‘ì„±í•˜ì„¸ìš”.' :
            window.targetLang === 'en' ? 'ì¸ë„¤ì¼ í…ìŠ¤íŠ¸ í›„ë³´(texts)ëŠ” ë°˜ë“œì‹œ "ì˜ì–´(English)"ë¡œ ì‘ì„±í•˜ì„¸ìš”.' :
                'ì¸ë„¤ì¼ í…ìŠ¤íŠ¸ í›„ë³´(texts)ëŠ” "í•œêµ­ì–´"ë¡œ ì‘ì„±í•˜ì„¸ìš”.';

        const prompt = `ìœ íŠœë¸Œ ì¸ë„¤ì¼ ë””ìì¸ ì „ë¬¸ê°€ë¡œì„œ ë‹¤ìŒ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ í´ë¦­ë¥  ë†’ì€ ì¸ë„¤ì¼ ì•„ì´ë””ì–´ë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”.

[ì˜ìƒ ì£¼ì œ]
${title}

[ìŠ¤íƒ€ì¼]
${style}
${style === 'japanese_viral' ? `
**SPECIAL STYLE INSTRUCTION (Japanese Viral):**
- Layout: Split screen or Text Overlay. Left 60% Text, Right 40% Image.
- Typography: Extremely bold, heavy sans-serif fonts. Colors: White, Red, Yellow. High contrast strokes/outlines.
- Imagery: Close-up, emotional face (elderly/shocked/crying/angry). Dark background.
- Vibe: Viral, provocative, "Shocking Truth", "Reality", "Documentary".
- Text Effects: Red/Yellow background highlights behind text.
` : ''}

[ì–¸ì–´ ì„¤ì •]
${langInstruction}

JSON í˜•ì‹ìœ¼ë¡œ ë°˜í™˜:
{
    "ideas": [
        {
            "concept": "ì»¨ì…‰ ì„¤ëª… (1-2ë¬¸ì¥)",
            "layout": "ë ˆì´ì•„ì›ƒ ì„¤ëª…",
            "prompt_en": "Detailed English prompt for Imagen 4. DO NOT include names of real people; use generic descriptions like 'middle-aged man', 'female doctor', etc. Example: A dramatic cinematic scene of a middle-aged male doctor in a dark room, expressive lighting, professional photography, 8k quality"
        }
    ],
    "texts": ["ì¸ë„¤ì¼ í…ìŠ¤íŠ¸ í›„ë³´ 1 (3-5ë‹¨ì–´)", "í›„ë³´ 2", "í›„ë³´ 3", "í›„ë³´ 4", "í›„ë³´ 5"]
}

ideasëŠ” 3ê°œ ìƒì„±í•˜ì„¸ìš”. prompt_enì€ Imagen 4ì—ì„œ ìµœìƒì˜ ê²°ê³¼ê°€ ë‚˜ì˜¤ë„ë¡ ì•„ì£¼ ìƒì„¸í•˜ê²Œ ì˜ì–´ë¡œ ì‘ì„±í•˜ì„¸ìš”. ì‹¤ì¡´ ì¸ë¬¼ì˜ ì´ë¦„(ì˜ˆ: ì—°ì˜ˆì¸, ì •ì¹˜ì¸, ì˜ì‚¬ëª… ë“±)ì€ ì ˆëŒ€ë¡œ ë„£ì§€ ë§ˆì„¸ìš”. ëŒ€ì‹  ê·¸ ì‚¬ëŒì˜ íŠ¹ì§•ì´ë‚˜ ì§ì—… ë“±ìœ¼ë¡œ ë¬˜ì‚¬í•˜ì„¸ìš”. JSONë§Œ ë°˜í™˜í•˜ì„¸ìš”.`;

        try {
            const result = await API.gemini.generate(prompt, { temperature: 0.8 });
            console.log('API Response:', JSON.stringify(result, null, 2));

            if (result.status === 'ok') {
                console.log('Response text:', result.text);
                const jsonMatch = result.text.match(/\{[\s\S]*\}/);
                console.log('JSON match found:', jsonMatch ? 'Yes' : 'No');

                if (jsonMatch) {
                    try {
                        thumbnailData = JSON.parse(jsonMatch[0]);
                        console.log('Parsed thumbnail data:', JSON.stringify(thumbnailData, null, 2));
                        renderIdeas();
                        document.getElementById('ideasSection').classList.remove('hidden');
                        saveStateToLocal(); // ì €ì¥
                    } catch (parseError) {
                        console.error('JSON parse error:', parseError);
                        Utils.showToast('JSON íŒŒì‹± ì‹¤íŒ¨: ' + parseError.message, 'error');
                    }
                } else {
                    console.error('No JSON found in response. Full text:', result.text);
                    Utils.showToast('ì‘ë‹µì—ì„œ JSONì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
                }
            } else {
                console.error('API returned error status:', JSON.stringify(result, null, 2));

                // í• ë‹¹ëŸ‰ ì´ˆê³¼ ì—ëŸ¬ íŠ¹ë³„ ì²˜ë¦¬
                if (result.error && result.error.code === 429) {
                    Utils.showToast('âš ï¸ Gemini API í• ë‹¹ëŸ‰ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤. API í‚¤ë¥¼ í™•ì¸í•˜ê±°ë‚˜ ë‚´ì¼ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', 'error');
                } else {
                    Utils.showToast('ì•„ì´ë””ì–´ ìƒì„± ì‹¤íŒ¨: ' + (result.error?.message || result.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'), 'error');
                }
            }
        } catch (error) {
            console.error('Error in generateIdeas:', error);
            Utils.showToast('ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message, 'error');
        } finally {
            Utils.setLoading(btn, false);
        }
    }

    // ì•„ì´ë””ì–´ ë Œë”ë§
    function renderIdeas() {
        if (!thumbnailData || !thumbnailData.ideas) return;
        const container = document.getElementById('ideasList');
        container.innerHTML = thumbnailData.ideas.map((idea, i) => `
            <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4 cursor-pointer hover:ring-2 hover:ring-primary transition ${i === selectedIdeaIndex ? 'ring-2 ring-primary bg-blue-50 dark:bg-gray-600' : ''}" onclick="selectIdea(${i})">
                <div class="flex items-center justify-between mb-2">
                    <span class="font-medium text-gray-800 dark:text-white">ì•„ì´ë””ì–´ ${i + 1}</span>
                    <button onclick="event.stopPropagation(); selectIdea(${i})" class="btn-primary text-xs">${i === selectedIdeaIndex ? 'ì„ íƒë¨' : 'ì„ íƒ'}</button>
                </div>
                <p class="text-gray-600 dark:text-gray-400 mb-2">${idea.concept}</p>
                <p class="text-sm text-gray-500">ë ˆì´ì•„ì›ƒ: ${idea.layout}</p>
                <details class="mt-2" open>
                    <summary class="text-xs text-blue-500 cursor-pointer">í”„ë¡¬í”„íŠ¸ ìˆ˜ì •</summary>
                    <textarea 
                        class="w-full h-32 bg-gray-900 text-green-400 p-2 rounded text-xs mt-2 focus:ring-1 focus:ring-blue-500 outline-none resize-y"
                        onclick="event.stopPropagation()"
                        oninput="updateIdeaPrompt(${i}, this.value)"
                    >${idea.prompt_en}</textarea>
                </details>
            </div>
        `).join('');
    }

    function updateIdeaPrompt(index, newPrompt) {
        // ë°ì´í„° ì—…ë°ì´íŠ¸
        if (thumbnailData && thumbnailData.ideas && thumbnailData.ideas[index]) {
            thumbnailData.ideas[index].prompt_en = newPrompt;

            // ë§Œì•½ í˜„ì¬ ì„ íƒëœ ì•„ì´ë””ì–´ë¼ë©´, ì„ íƒëœ í”„ë¡¬í”„íŠ¸ ë³€ìˆ˜ë„ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            if (index === selectedIdeaIndex) {
                selectedPrompt = newPrompt;
            }
            saveStateToLocal(); // ì €ì¥
        }
    }

    // ì•„ì´ë””ì–´ ì„ íƒ
    function selectIdea(index) {
        selectedIdeaIndex = index;
        selectedPrompt = thumbnailData.ideas[index].prompt_en;

        // UI ì—…ë°ì´íŠ¸ (ì„ íƒë¨ í‘œì‹œ)
        renderIdeas();

        // í…ìŠ¤íŠ¸ í›„ë³´ ìë™ ë°°ì • (ë ˆì´ì–´ ë™ì  ìƒì„±)
        if (thumbnailData.texts && thumbnailData.texts.length > 0) {
            // ê¸°ì¡´ ë ˆì´ì–´ ì´ˆê¸°í™” (ë˜ëŠ” ì‚¬ìš©ìì—ê²Œ ë¬¼ì–´ë´ì•¼ í•˜ì§€ë§Œ, í¸ì˜ìƒ ì´ˆê¸°í™”)
            textLayers = [];

            const currentStyle = document.getElementById('thumbnailStyle').value;
            const style = currentStyle; // 'viral' ë˜ëŠ” ë‹¤ë¥¸ ìŠ¤íƒ€ì¼
            // const isJapaneseViral = currentStyle === 'japanese_viral'; // ì´ ë³€ìˆ˜ëŠ” ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠìŒ

            // [SMART LAYOUT] í…ìŠ¤íŠ¸ ë ˆì´ì•„ì›ƒ ìë™ ê³„ì‚°
            // ëª¨ë“  í…ìŠ¤íŠ¸ í›„ë³´ë¥¼ í•˜ë‚˜ì˜ ë¬¸ìì—´ë¡œ í•©ì³ì„œ ì¤„ë°”ê¿ˆìœ¼ë¡œ ë¶„ë¦¬
            const allText = thumbnailData.texts.join('\n');
            const lines = allText.split('\n').filter(line => line.trim() !== ''); // ë¹ˆ ì¤„ ì œê±°
            const lineCount = lines.length;
            let baseFontSize = 72;

            // ì¤„ ìˆ˜ì— ë”°ë¥¸ ê¸°ë³¸ í°íŠ¸ í¬ê¸° ë° ë°°ì¹˜ ì „ëµ ì„¤ì •
            if (lineCount <= 1) baseFontSize = 90;
            else if (lineCount === 2) baseFontSize = 85;
            else if (lineCount === 3) baseFontSize = 75;
            else baseFontSize = 65; // 4ì¤„ ì´ìƒì€ ì‘ê²Œ

            lines.forEach((line, i) => {
                const newLayer = {
                    text: line,
                    position: 'center', // ê¸°ë³¸ê°’, ì•„ë˜ì—ì„œ ë®ì–´ì”€
                    x_offset: 0,
                    y_offset: 0,
                    font_family: 'malgun',
                    font_size: baseFontSize,
                    color: '#FFFFFF',
                    stroke_color: '#000000',
                    stroke_width: 5, // ì™¸ê³½ì„  ì¡°ê¸ˆ ë” ì˜ ë³´ì´ê²Œ
                    bg_color: null
                };

                // [Smart Positioning]
                if (style === 'viral') {
                    // ë°”ì´ëŸ´ ìŠ¤íƒ€ì¼: ìƒ‰ìƒ ì•Œë¡ë‹¬ë¡ + ë°°ì¹˜ ë¶„ì‚°
                    if (lineCount === 1) {
                        newLayer.position = 'center';
                        newLayer.color = '#FFFF00';
                        newLayer.stroke_color = '#FF0000';
                    } else if (lineCount === 2) {
                        if (i === 0) { newLayer.position = 'row2'; newLayer.color = '#FFFFFF'; } // ìƒë‹¨
                        if (i === 1) { newLayer.position = 'row4'; newLayer.color = '#FFFF00'; newLayer.stroke_color = '#FF0000'; } // í•˜ë‹¨ ê°•ì¡°
                    } else if (lineCount === 3) {
                        if (i === 0) { newLayer.position = 'row1'; newLayer.color = '#FFFFFF'; }
                        if (i === 1) { newLayer.position = 'center'; newLayer.color = '#00FFFF'; }
                        if (i === 2) { newLayer.position = 'bottom'; newLayer.color = '#FFFF00'; newLayer.stroke_color = '#FF0000'; }
                    } else {
                        // 4ì¤„ ì´ìƒ
                        if (i === 0) { newLayer.position = 'row1'; newLayer.color = '#FFFFFF'; }
                        else if (i === 1) { newLayer.position = 'row2'; newLayer.color = '#00FFFF'; }
                        else if (i === 2) { newLayer.position = 'row3'; newLayer.color = '#E000FF'; }
                        else if (i === 3) {
                            newLayer.position = 'row4';
                            newLayer.color = '#FFFF00';
                            newLayer.stroke_color = '#FF0000';
                        } else {
                            newLayer.position = 'row5'; // 5ë²ˆì§¸ ì¤„
                        }
                    }
                } else {
                    // ì¼ë°˜ ìŠ¤íƒ€ì¼: ê¹”ë”í•˜ê²Œ ìœ„ì—ì„œ ì•„ë˜ë¡œ
                    if (lineCount === 1) newLayer.position = 'center';
                    else if (lineCount === 2) {
                        if (i === 0) newLayer.position = 'row2';
                        if (i === 1) newLayer.position = 'row4';
                    }
                    else if (lineCount === 3) {
                        if (i === 0) newLayer.position = 'row1';
                        if (i === 1) newLayer.position = 'center';
                        if (i === 2) newLayer.position = 'bottom';
                    }
                    else {
                        if (i === 0) newLayer.position = 'row1';
                        else if (i === 1) newLayer.position = 'row2';
                        else if (i === 2) newLayer.position = 'row3';
                        else if (i === 3) newLayer.position = 'row4';
                        else newLayer.position = 'row5';
                    }
                }

                textLayers.push(newLayer);
            });
        }

        // í…ìŠ¤íŠ¸ ì„¹ì…˜ í‘œì‹œ
        document.getElementById('textSection').classList.remove('hidden');

        // í…ìŠ¤íŠ¸ í›„ë³´ í‘œì‹œ
        const textContainer = document.getElementById('textCandidates');
        textContainer.innerHTML = thumbnailData.texts.map(text => `
            <button onclick="addTextToActiveLayer('${text.replace(/'/g, "\\'")}')" class="px-3 py-1 bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-300 rounded-lg hover:bg-yellow-200 transition text-sm">
                ${text}
            </button>
        `).join('');

        // ë¯¸ë¦¬ë³´ê¸° í”Œë ˆì´ìŠ¤í™€ë” ìˆ¨ê¸°ê¸°
        const placeholder = document.getElementById('previewPlaceholder');
        if (placeholder) placeholder.classList.add('hidden');

        renderLayers();
        Utils.showToast(`ì•„ì´ë””ì–´ ${index + 1} ì„ íƒë¨`, 'success');

        // ìŠ¤í¬ë¡¤
        // ìŠ¤í¬ë¡¤
        document.getElementById('textSection').scrollIntoView({ behavior: 'smooth' });
        saveStateToLocal(); // ì €ì¥
    }

    // ë ˆì´ì–´ ì¶”ê°€
    function addLayer() {
        textLayers.push({
            text: '', position: 'center', x_offset: 0, y_offset: 0, font_family: 'malgun', font_size: 72, color: '#FFFFFF', stroke_color: '#000000', stroke_width: 2, bg_color: null
        });
        renderLayers();
        saveStateToLocal();
    }

    // ë ˆì´ì–´ ì œê±°
    function removeLayer(index) {
        textLayers.splice(index, 1);
        renderLayers();
        saveStateToLocal();
    }

    // ë ˆì´ì–´ UI ë Œë”ë§ (Compact & Position Removed)
    function renderLayers() {
        const container = document.getElementById('layersContainer');
        container.innerHTML = textLayers.map((layer, i) => `
            <div class="bg-gray-50 dark:bg-gray-800 p-3 rounded-lg border border-gray-200 dark:border-gray-700 relative group shadow-sm">
                <!-- Header -->
                <div class="flex items-center justify-between mb-2">
                    <span class="text-[10px] font-bold text-indigo-500 dark:text-indigo-400">LAYER ${i + 1}</span>
                    <button onclick="removeLayer(${i})" class="text-gray-400 hover:text-red-500 transition px-2">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                
                <!-- Text Input -->
                <input type="text" value="${layer.text}" oninput="updateLayer(${i}, 'text', this.value)" 
                    class="input-field mb-3 font-bold text-sm w-full" placeholder="í…ìŠ¤íŠ¸ ì…ë ¥...">

                <!-- Controls Row -->
                <div class="flex flex-wrap gap-2 items-end">
                    <!-- Font -->
                    <div class="flex-1 min-w-[100px]">
                        <label class="block text-[9px] text-gray-500 mb-1">í°íŠ¸</label>
                        <select onchange="updateLayer(${i}, 'font_family', this.value)" class="input-field py-1 text-xs w-full h-8">
                            <option value="malgun" ${layer.font_family === 'malgun' ? 'selected' : ''}>ë§‘ì€ê³ ë”•</option>
                            <option value="gmarket" ${layer.font_family === 'gmarket' ? 'selected' : ''}>Gmarket</option>
                            <option value="cookie" ${layer.font_family === 'cookie' ? 'selected' : ''}>ì¿ í‚¤ëŸ°</option>
                        </select>
                    </div>

                    <!-- Size -->
                    <div class="w-14">
                        <label class="block text-[9px] text-gray-500 mb-1">í¬ê¸°</label>
                        <input type="number" value="${layer.font_size}" oninput="updateLayer(${i}, 'font_size', parseInt(this.value))" 
                            class="input-field py-1 text-xs w-full h-8 px-1 text-center">
                    </div>

                    <div class="w-[1px] h-6 bg-gray-200 dark:bg-gray-600 mx-1 mb-1"></div>

                    <!-- Text Color -->
                    <div>
                        <label class="block text-[9px] text-gray-500 mb-1">ìƒ‰ìƒ</label>
                        <div class="h-8 w-8 relative overflow-hidden rounded border border-gray-300 dark:border-gray-600">
                             <input type="color" value="${layer.color}" onchange="updateLayer(${i}, 'color', this.value)" 
                                class="absolute -top-2 -left-2 w-12 h-12 p-0 border-none cursor-pointer">
                        </div>
                    </div>

                    <!-- Stroke -->
                    <div class="flex gap-1 items-end">
                        <div class="group/stroke">
                             <label class="block text-[9px] text-gray-500 mb-1">ì™¸ê³½ì„ </label>
                             <div class="h-8 w-8 relative overflow-hidden rounded border border-gray-300 dark:border-gray-600">
                                <input type="color" value="${layer.stroke_color || '#000000'}" onchange="updateLayer(${i}, 'stroke_color', this.value)" 
                                   class="absolute -top-2 -left-2 w-12 h-12 p-0 border-none cursor-pointer">
                             </div>
                        </div>
                        <input type="number" value="${layer.stroke_width}" oninput="updateLayer(${i}, 'stroke_width', parseInt(this.value))" 
                            class="input-field py-1 text-xs w-10 h-8 px-1 text-center" title="ì™¸ê³½ì„  ë‘ê»˜">
                    </div>

                    <!-- BG -->
                    <div class="flex gap-1 items-end">
                        <div>
                             <label class="block text-[9px] text-gray-500 mb-1">ë°°ê²½</label>
                             <div class="h-8 w-8 relative overflow-hidden rounded border border-gray-300 dark:border-gray-600 ${!layer.bg_color ? 'opacity-30' : ''}">
                                <input type="color" value="${layer.bg_color || '#000000'}" onchange="updateLayer(${i}, 'bg_color', this.value)" 
                                   class="absolute -top-2 -left-2 w-12 h-12 p-0 border-none cursor-pointer">
                             </div>
                        </div>
                        <button onclick="toggleLayerBg(${i})" class="h-8 btn-secondary text-[10px] px-2 whitespace-nowrap ${layer.bg_color ? 'bg-indigo-50 text-indigo-600 border-indigo-200' : ''}">
                            ${layer.bg_color ? 'ON' : 'OFF'}
                        </button>
                    </div>
                </div>
            </div>
        `).join('');
    }

    // --- ë„í˜• ë ˆì´ì–´ ê´€ë¦¬ ---
    function addShapeLayer() {
        shapeLayers.push({
            x: 100, y: 100, width: 300, height: 100,
            color_start: '#000000', color_end: null, // nullì´ë©´ ë‹¨ìƒ‰
            opacity: 0.5, opacity_end: 0.5,
            gradient_direction: 'horizontal'
        });
        selectedShapeIndex = shapeLayers.length - 1; // ì¶”ê°€ ì‹œ ìë™ ì„ íƒ
        renderShapeLayers();
        drawPreview();
        saveStateToLocal();
    }

    function removeShapeLayer(index) {
        shapeLayers.splice(index, 1);
        selectedShapeIndex = -1; // ì„ íƒ í•´ì œ
        renderShapeLayers();
        drawPreview();
        saveStateToLocal();
    }

    function updateShapeLayer(index, key, value) {
        shapeLayers[index][key] = value;
        drawPreview();
        saveStateToLocal();
    }

    // ë„í˜• ì„ íƒ (UIì—ì„œ í´ë¦­ ì‹œ)
    function selectShapeLayer(index) {
        selectedShapeIndex = index;
        renderShapeLayers(); // í•˜ì´ë¼ì´íŠ¸ ê°±ì‹  ë“±ì„ ìœ„í•´
        drawPreview(); // í•¸ë“¤ í‘œì‹œ
    }

    function renderShapeLayers() {
        const container = document.getElementById('shapeLayersContainer');
        container.innerHTML = shapeLayers.map((shape, i) => `
            <div class="p-3 rounded-lg border relative transition ${i === selectedShapeIndex ? 'bg-blue-100 border-blue-400 dark:bg-blue-900/40 dark:border-blue-500 ring-1 ring-blue-400' : 'bg-blue-50 border-blue-200 dark:bg-blue-900/20 dark:border-blue-800'}"
                 onclick="selectShapeLayer(${i})">
                <div class="flex items-center justify-between mb-2">
                    <span class="text-[10px] font-bold text-blue-500">ë„í˜• ${i + 1}</span>
                    <button onclick="removeShapeLayer(${i}); event.stopPropagation();" class="text-gray-400 hover:text-red-500">Ã—</button>
                </div>
                
                <div class="grid grid-cols-4 gap-2 mb-2">
                    <input type="number" value="${shape.x}" oninput="updateShapeLayer(${i}, 'x', parseInt(this.value))" class="input-field py-1 text-xs" placeholder="X">
                    <input type="number" value="${shape.y}" oninput="updateShapeLayer(${i}, 'y', parseInt(this.value))" class="input-field py-1 text-xs" placeholder="Y">
                    <input type="number" value="${shape.width}" oninput="updateShapeLayer(${i}, 'width', parseInt(this.value))" class="input-field py-1 text-xs" placeholder="W">
                    <input type="number" value="${shape.height}" oninput="updateShapeLayer(${i}, 'height', parseInt(this.value))" class="input-field py-1 text-xs" placeholder="H">
                </div>

                <div class="grid grid-cols-2 gap-2 mb-2">
                    <div>
                        <label class="block text-[10px] text-gray-500">ì‹œì‘ ìƒ‰ìƒ</label>
                        <input type="color" value="${shape.color_start}" onchange="updateShapeLayer(${i}, 'color_start', this.value)" class="w-full h-6 p-0 border-none rounded cursor-pointer">
                    </div>
                    <div>
                        <label class="block text-[10px] text-gray-500">ë ìƒ‰ìƒ (ì„ íƒ)</label>
                        <div class="flex gap-1">
                            <input type="color" value="${shape.color_end || '#000000'}" onchange="updateShapeLayer(${i}, 'color_end', this.value)" class="w-full h-6 p-0 border-none rounded cursor-pointer ${!shape.color_end ? 'opacity-30' : ''}">
                            <button onclick="updateShapeLayer(${i}, 'color_end', '${shape.color_end ? '' : '#000000'}')" class="text-[9px] w-12 btn-secondary py-0">${shape.color_end ? 'OFF' : 'ON'}</button>
                        </div>
                    </div>
                </div>

                <div class="space-y-1">
                     <div class="flex items-center gap-2">
                         <span class="text-[10px] text-gray-500 w-14">ì‹œì‘ íˆ¬ëª…ë„</span>
                         <input type="range" min="0" max="1" step="0.1" value="${shape.opacity}" oninput="updateShapeLayer(${i}, 'opacity', parseFloat(this.value))" class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                     </div>
                     <div class="flex items-center gap-2" style="${!shape.color_end ? 'opacity: 0.5; pointer-events: none;' : ''}">
                         <span class="text-[10px] text-gray-500 w-14">ë íˆ¬ëª…ë„</span>
                         <input type="range" min="0" max="1" step="0.1" value="${shape.opacity_end ?? shape.opacity}" oninput="updateShapeLayer(${i}, 'opacity_end', parseFloat(this.value))" class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                     </div>
                </div>
                
                <div class="mt-2 text-right">
                     <select onchange="updateShapeLayer(${i}, 'gradient_direction', this.value)" class="text-xs p-1 rounded border dark:bg-gray-700 dark:border-gray-600">
                        <option value="horizontal" ${shape.gradient_direction === 'horizontal' ? 'selected' : ''}>ë°©í–¥: ê°€ë¡œ</option>
                        <option value="vertical" ${shape.gradient_direction === 'vertical' ? 'selected' : ''}>ë°©í–¥: ì„¸ë¡œ</option>
                     </select>
                </div>
            </div>
        `).join('');
    }

    function updateLayer(index, key, value) {
        textLayers[index][key] = value;
        if (key === 'position') {
            // í–‰ ë³€ê²½ ì‹œ ì˜¤í”„ì…‹ ì´ˆê¸°í™” (ì‚¬ìš©ì í¸ì˜)
            textLayers[index].x_offset = 0;
            textLayers[index].y_offset = 0;
            renderLayers(); // ì˜¤í”„ì…‹ ì…ë ¥ì°½ ê°’ë„ ë°”ë€Œì–´ì•¼ í•˜ë¯€ë¡œ ì „ì²´ ë Œë”ë§
        } else {
            drawPreview(); // ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
        }
        saveStateToLocal();
    }

    function toggleLayerBg(index) {
        textLayers[index].bg_color = textLayers[index].bg_color ? null : '#000000';
        renderLayers();
        saveStateToLocal();
    }

    function addTextToActiveLayer(text) {
        const emptyLayer = textLayers.find(l => !l.text) || textLayers[0];
        emptyLayer.text = text;
        renderLayers();
        saveStateToLocal();
    }

    // ìº”ë²„ìŠ¤ ì´ë²¤íŠ¸ ì´ˆê¸°í™” (ë“œë˜ê·¸ ì•¤ ë“œë¡­)
    function initCanvasEvents() {
        const canvas = document.getElementById('thumbnailCanvas');
        if (!canvas) return;

        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseout', handleMouseUp);

        // í„°ì¹˜ ì´ë²¤íŠ¸ ì§€ì› (ëª¨ë°”ì¼)
        canvas.addEventListener('touchstart', (e) => handleMouseDown(e.touches[0]));
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMouseMove(e.touches[0]); });
        canvas.addEventListener('touchend', handleMouseUp);
    }

    function getCanvasCoordinates(e, canvas) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    }

    function handleMouseDown(e) {
        e.preventDefault(); // ê¸°ë³¸ ë“œë˜ê·¸ ë°©ì§€
        const canvas = document.getElementById('thumbnailCanvas');
        const coords = getCanvasCoordinates(e, canvas);

        // 0. í•¸ë“¤ í´ë¦­ í™•ì¸ (ì´ë¯¸ ì„ íƒëœ ë„í˜•ì´ ìˆì„ ë•Œ)
        if (selectedShapeIndex !== -1) {
            for (let i = 0; i < shapeHandleBBoxes.length; i++) {
                const h = shapeHandleBBoxes[i];
                // í˜„ì¬ ì„ íƒëœ ë„í˜•ì˜ í•¸ë“¤ì¸ì§€ í™•ì¸
                if (h.index !== selectedShapeIndex) continue;

                if (coords.x >= h.x && coords.x <= h.x + h.w &&
                    coords.y >= h.y && coords.y <= h.y + h.h) {

                    isDragging = true;
                    resizeHandle = h.type;
                    dragStartX = coords.x;
                    dragStartY = coords.y;

                    const shape = shapeLayers[selectedShapeIndex];
                    initialShapeParams = { x: shape.x, y: shape.y, w: shape.width, h: shape.height };
                    return; // ë¦¬ì‚¬ì´ì¦ˆ ì‹œì‘í•˜ë©´ ì¢…ë£Œ
                }
            }
        }

        // 1. ë„í˜• í´ë¦­ í™•ì¸ (í…ìŠ¤íŠ¸ë³´ë‹¤ ì•„ë˜ì— ìˆìœ¼ë¯€ë¡œ ë¨¼ì € ì²´í¬í•˜ì§€ë§Œ í…ìŠ¤íŠ¸ê°€ ìš°ì„ ê¶Œ ê°€ì§)
        // í•˜ì§€ë§Œ ì§ê´€ì„±ì„ ìœ„í•´ 'ê°€ì¥ ìœ„ì— ìˆëŠ” ìš”ì†Œ'ë¥¼ ì„ íƒí•˜ëŠ”ê²Œ ë§ìŒ.
        // ì—¬ê¸°ì„  ë‹¨ìˆœí™”ë¥¼ ìœ„í•´: í…ìŠ¤íŠ¸ íˆíŠ¸ -> í…ìŠ¤íŠ¸ ë“œë˜ê·¸ / ë„í˜• íˆíŠ¸(í…ìŠ¤íŠ¸ ì•„ë‹˜) -> ë„í˜• ì„ íƒ+ë“œë˜ê·¸

        // í…ìŠ¤íŠ¸ íˆíŠ¸ í…ŒìŠ¤íŠ¸
        let hitText = false;
        for (let i = layerBBoxes.length - 1; i >= 0; i--) {
            const bbox = layerBBoxes[i];
            if (coords.x >= bbox.x && coords.x <= bbox.x + bbox.w &&
                coords.y >= bbox.y && coords.y <= bbox.y + bbox.h) {

                isDragging = true;
                draggedLayerIndex = bbox.index;
                resizeHandle = null; // í…ìŠ¤íŠ¸ ë“œë˜ê·¸ì„

                dragStartX = coords.x;
                dragStartY = coords.y;
                initialLayerX = textLayers[draggedLayerIndex].x_offset || 0;
                initialLayerY = textLayers[draggedLayerIndex].y_offset || 0;

                canvas.style.cursor = 'grabbing';
                hitText = true;

                // í…ìŠ¤íŠ¸ ì„ íƒ ì‹œ ë„í˜• ì„ íƒ í•´ì œ (ì›í•œë‹¤ë©´)
                // selectedShapeIndex = -1; renderShapeLayers();
                break;
            }
        }
        if (hitText) return;

        // ë„í˜• íˆíŠ¸ í…ŒìŠ¤íŠ¸
        for (let i = shapeBBoxes.length - 1; i >= 0; i--) {
            const bbox = shapeBBoxes[i];
            if (coords.x >= bbox.x && coords.x <= bbox.x + bbox.w &&
                coords.y >= bbox.y && coords.y <= bbox.y + bbox.h) {

                selectedShapeIndex = bbox.index;
                isDragging = true;
                resizeHandle = 'move_shape'; // íŠ¹ë³„ íƒ€ì…

                dragStartX = coords.x;
                dragStartY = coords.y;
                const shape = shapeLayers[selectedShapeIndex];
                initialShapeParams = { x: shape.x, y: shape.y, w: shape.width, h: shape.height };

                renderShapeLayers(); // UI Highlight
                drawPreview(); // Show Handles
                return;
            }
        }

        // ì•„ë¬´ê²ƒë„ ì•ˆì°ìŒ -> ì„ íƒ í•´ì œ
        if (selectedShapeIndex !== -1) {
            selectedShapeIndex = -1;
            renderShapeLayers();
            drawPreview();
        }
    }

    function handleMouseMove(e) {
        const canvas = document.getElementById('thumbnailCanvas');
        const coords = getCanvasCoordinates(e, canvas);

        if (!isDragging) {
            // ì»¤ì„œ ì—…ë°ì´íŠ¸ ë¡œì§
            let cursor = 'default';

            // 1. í•¸ë“¤ ì˜¤ë²„
            if (selectedShapeIndex !== -1) {
                for (const h of shapeHandleBBoxes) {
                    if (h.index === selectedShapeIndex &&
                        coords.x >= h.x && coords.x <= h.x + h.w &&
                        coords.y >= h.y && coords.y <= h.y + h.h) {

                        if (h.type === 'nw' || h.type === 'se') cursor = 'nwse-resize';
                        else if (h.type === 'ne' || h.type === 'sw') cursor = 'nesw-resize';
                        else if (h.type === 'n' || h.type === 's') cursor = 'ns-resize';
                        else if (h.type === 'e' || h.type === 'w') cursor = 'ew-resize';
                        break;
                    }
                }
            }

            // 2. í…ìŠ¤íŠ¸ ì˜¤ë²„
            if (cursor === 'default') {
                for (const bbox of layerBBoxes) {
                    if (coords.x >= bbox.x && coords.x <= bbox.x + bbox.w &&
                        coords.y >= bbox.y && coords.y <= bbox.y + bbox.h) {
                        cursor = 'grab'; break;
                    }
                }
            }

            // 3. ë„í˜• ì˜¤ë²„
            if (cursor === 'default') {
                for (const bbox of shapeBBoxes) {
                    if (coords.x >= bbox.x && coords.x <= bbox.x + bbox.w &&
                        coords.y >= bbox.y && coords.y <= bbox.y + bbox.h) {
                        cursor = 'move'; break;
                    }
                }
            }

            canvas.style.cursor = cursor;
            return;
        }

        // ë“œë˜ê·¸/ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬
        const dx = coords.x - dragStartX;
        const dy = coords.y - dragStartY;

        if (resizeHandle && selectedShapeIndex !== -1) {
            const shape = shapeLayers[selectedShapeIndex];
            const init = initialShapeParams;

            if (resizeHandle === 'move_shape') {
                shape.x = init.x + dx;
                shape.y = init.y + dy;
            } else {
                // Resize Logic
                if (resizeHandle.includes('e')) shape.width = Math.max(10, init.w + dx);
                if (resizeHandle.includes('s')) shape.height = Math.max(10, init.h + dy);
                if (resizeHandle.includes('w')) {
                    const newW = Math.max(10, init.w - dx);
                    shape.x = init.x + (init.w - newW);
                    shape.width = newW;
                }
                if (resizeHandle.includes('n')) {
                    const newH = Math.max(10, init.h - dy);
                    shape.y = init.y + (init.h - newH);
                    shape.height = newH;
                }
            }
            renderShapeLayers(); // ìˆ˜ì¹˜ ì—…ë°ì´íŠ¸
            drawPreview();
        } else if (draggedLayerIndex !== -1) {
            // í…ìŠ¤íŠ¸ ì´ë™
            textLayers[draggedLayerIndex].x_offset = initialLayerX + dx;
            textLayers[draggedLayerIndex].y_offset = initialLayerY + dy;
            drawPreview();
        }
    }

    function handleMouseUp() {
        if (isDragging) {
            isDragging = false;
            resizeHandle = null;
            draggedLayerIndex = -1;
            document.getElementById('thumbnailCanvas').style.cursor = 'default';
            renderLayers(); // í…ìŠ¤íŠ¸ë§Œ ì—…ë°ì´íŠ¸
            renderShapeLayers(); // ë„í˜• ì—…ë°ì´íŠ¸
            saveStateToLocal(); // ë“œë˜ê·¸ ì¢…ë£Œ ì‹œ ì €ì¥
        }
    }

    let bgImage = null; // Global background image object

    // ë°°ê²½ ìƒì„± í•¨ìˆ˜
    async function generateBackground() {
        if (!selectedPrompt) {
            Utils.showToast('ë¨¼ì € ì•„ì´ë””ì–´ë¥¼ ì„ íƒí•˜ì„¸ìš”', 'warning');
            return;
        }

        const btn = document.getElementById('bgBtn');
        Utils.setLoading(btn, true, 'ë°°ê²½ ìƒì„± ì¤‘... (40ì´ˆ ì†Œìš”)');

        try {
            const result = await API.image.generateThumbnailBackground(selectedPrompt, currentAspectRatio); // Correct API Call


            if (result.status === 'ok') {
                currentBackgroundPath = result.path;
                currentBackgroundUrl = result.url;
                bgImage = null; // Reset any manually uploaded image so we load the new URL

                Utils.showToast('ë°°ê²½ ì´ë¯¸ì§€ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
                drawPreview(); // ë°°ê²½ ì ìš©
                saveStateToLocal(); // ì €ì¥
            } else {
                // 404 ë“±ì˜ ê²½ìš° detail í•„ë“œë¡œ ì—ëŸ¬ê°€ ì˜´
                const errorMsg = result.error || result.detail || 'ë°°ê²½ ìƒì„± ì‹¤íŒ¨';
                if (errorMsg === 'Not Found' || errorMsg.includes('Not Found')) {
                    Utils.showToast('âš ï¸ ì„œë²„ ì¬ì‹œì‘ì´ í•„ìš”í•©ë‹ˆë‹¤. (ìƒˆë¡œìš´ ê¸°ëŠ¥ ì ìš©ì„ ìœ„í•´ main.pyë¥¼ ì¬ì‹¤í–‰í•´ì£¼ì„¸ìš”)', 'error');
                } else {
                    Utils.showToast(errorMsg, 'error');
                }
            }
        } catch (error) {
            Utils.showToast('ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message, 'error');
            console.error(error);
        } finally {
            Utils.setLoading(btn, false);
        }
    }

    // ìº”ë²„ìŠ¤ ë¯¸ë¦¬ë³´ê¸° ë Œë”ë§
    function drawPreview() {
        const canvas = document.getElementById('thumbnailCanvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');

        // Clear canvas
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 2. ë°°ê²½ ê·¸ë¦¬ê¸°
        if (bgImage) {
            // If we have a prepared image object (from upload or cached URL), use it
            ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
            drawShapeLayers(ctx);
            drawTextOverlays(ctx);

            // Hide placeholder
            const placeholder = document.getElementById('previewPlaceholder');
            if (placeholder) placeholder.classList.add('hidden');
        } else if (currentBackgroundUrl) {
            // If we have a URL but no object yet, load it
            const tempImg = new Image();
            tempImg.crossOrigin = "anonymous";
            tempImg.onload = () => {
                bgImage = tempImg; // [Fix] Cache the image
                ctx.drawImage(tempImg, 0, 0, canvas.width, canvas.height);
                drawShapeLayers(ctx);
                drawTextOverlays(ctx);

                // Hide placeholder
                const placeholder = document.getElementById('previewPlaceholder');
                if (placeholder) placeholder.classList.add('hidden');
            };
            tempImg.src = currentBackgroundUrl;
        } else {
            // No background yet
            drawShapeLayers(ctx);
            drawTextOverlays(ctx);
        }
    }

    function drawShapeLayers(ctx) {
        if (!shapeLayers) return;
        shapeBBoxes = [];
        shapeHandleBBoxes = [];

        shapeLayers.forEach((shape, i) => {
            const x = shape.x;
            const y = shape.y;
            const w = shape.width;
            const h = shape.height;

            // Hitbox ì €ì¥
            shapeBBoxes.push({ x, y, w, h, index: i });

            // Hex to RGB Helper
            const hexToRgb = (hex) => {
                const bigint = parseInt(hex.slice(1), 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                return `${r}, ${g}, ${b}`;
            };

            const startRgb = hexToRgb(shape.color_start);
            const opacityStart = shape.opacity !== undefined ? shape.opacity : 1.0;
            const opacityEnd = shape.opacity_end !== undefined ? shape.opacity_end : opacityStart;

            let fillStyle;

            if (shape.color_end && shape.color_end !== shape.color_start) {
                const endRgb = hexToRgb(shape.color_end);

                // ê·¸ë¼ë””ì–¸íŠ¸
                let grad;
                if (shape.gradient_direction === 'vertical') {
                    grad = ctx.createLinearGradient(x, y, x, y + h);
                } else {
                    grad = ctx.createLinearGradient(x, y, x + w, y);
                }

                grad.addColorStop(0, `rgba(${startRgb}, ${opacityStart})`);
                grad.addColorStop(1, `rgba(${endRgb}, ${opacityEnd})`);
                fillStyle = grad;
            } else if (opacityStart !== opacityEnd) {
                // ë‹¨ìƒ‰ì´ì§€ë§Œ íˆ¬ëª…ë„ë§Œ ë‹¤ë¥¼ ë•Œ (íˆ¬ëª…ë„ ê·¸ë¼ë””ì–¸íŠ¸)
                let grad;
                if (shape.gradient_direction === 'vertical') {
                    grad = ctx.createLinearGradient(x, y, x, y + h);
                } else {
                    grad = ctx.createLinearGradient(x, y, x + w, y);
                }
                grad.addColorStop(0, `rgba(${startRgb}, ${opacityStart})`);
                grad.addColorStop(1, `rgba(${startRgb}, ${opacityEnd})`);
                fillStyle = grad;
            } else {
                // ì™„ì „ ë‹¨ìƒ‰
                fillStyle = `rgba(${startRgb}, ${opacityStart})`;
            }

            ctx.save();
            ctx.fillStyle = fillStyle;
            ctx.fillRect(x, y, w, h);

            // ì„ íƒëœ ë„í˜•ì€ ì™¸ê³½ì„  + í•¸ë“¤ í‘œì‹œ
            if (i === selectedShapeIndex) {
                ctx.strokeStyle = '#00cdff';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);

                // í•¸ë“¤ ê·¸ë¦¬ê¸°
                const handleSize = 8;
                const handles = [
                    { type: 'nw', x: x, y: y },
                    { type: 'n', x: x + w / 2, y: y },
                    { type: 'ne', x: x + w, y: y },
                    { type: 'e', x: x + w, y: y + h / 2 },
                    { type: 'se', x: x + w, y: y + h },
                    { type: 's', x: x + w / 2, y: y + h },
                    { type: 'sw', x: x, y: y + h },
                    { type: 'w', x: x, y: y + h / 2 }
                ];

                ctx.strokeStyle = '#00cdff';
                ctx.fillStyle = '#ffffff';

                handles.forEach(h => {
                    const hx = h.x - handleSize / 2;
                    const hy = h.y - handleSize / 2;
                    ctx.fillRect(hx, hy, handleSize, handleSize);
                    ctx.strokeRect(hx, hy, handleSize, handleSize);

                    shapeHandleBBoxes.push({
                        x: hx, y: hy, w: handleSize, h: handleSize,
                        type: h.type, index: i
                    });
                });
            }
            ctx.restore();
        });
    }

    // í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸° (ê¸°ë³¸ í•¨ìˆ˜ ë¶„ë¦¬)
    function drawTextOverlays(ctx) {
        // íˆíŠ¸ë°•ìŠ¤ ì´ˆê¸°í™”
        layerBBoxes = [];

        // ê¸°ë³¸ í°íŠ¸ ì„¤ì • (ë¸Œë¼ìš°ì € ìº”ë²„ìŠ¤ìš©)
        // main.pyì™€ ìµœëŒ€í•œ ë¹„ìŠ·í•˜ê²Œ ë§ì¶¤
        const getFont = (family, size) => {
            let fontName = 'Malgun Gothic';
            if (family === 'gmarket') fontName = 'Gmarket Sans';
            if (family === 'cookie') fontName = 'CookieRun';
            return `bold ${size}px "${fontName}", sans-serif`;
        };

        textLayers.forEach((layer, i) => {
            if (!layer.text.trim()) return;

            ctx.save();
            ctx.font = getFont(layer.font_family, layer.font_size);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // ìœ„ì¹˜ ê³„ì‚° (Dynamic)
            let x = ctx.canvas.width / 2; // center x
            let y = ctx.canvas.height / 2; // center y

            const canvasH = ctx.canvas.height;
            if (layer.position === 'center') y = canvasH * 0.5;
            else if (layer.position === 'top') y = canvasH * 0.15;
            else if (layer.position === 'bottom') y = canvasH * 0.85;
            else if (layer.position === 'row1') y = canvasH * 0.15;
            else if (layer.position === 'row2') y = canvasH * 0.35;
            else if (layer.position === 'row3') y = canvasH * 0.55;
            else if (layer.position === 'row4') y = canvasH * 0.75;
            else if (layer.position === 'row5') y = canvasH * 0.90;

            x += (layer.x_offset || 0);
            y += (layer.y_offset || 0);

            // ì™¸ê³½ì„ 
            if (layer.stroke_width > 0) {
                ctx.lineWidth = layer.stroke_width * 2; // ìº”ë²„ìŠ¤ëŠ” ì¤‘ì•™ ê¸°ì¤€ì´ë¼ 2ë°°
                ctx.strokeStyle = layer.stroke_color;
                ctx.strokeText(layer.text, x, y);
            }

            // ì±„ìš°ê¸°
            ctx.fillStyle = layer.color;
            ctx.fillText(layer.text, x, y);

            // íˆíŠ¸ë°•ìŠ¤ ì €ì¥ (ëŒ€ëµì )
            const metrics = ctx.measureText(layer.text);
            const w = metrics.width;
            const h = layer.font_size; // ê·¼ì‚¬ì¹˜
            layerBBoxes.push({
                x: x - w / 2,
                y: y - h / 2,
                w: w,
                h: h,
                index: i
            });

            ctx.restore();
        });
    }

    // renderLayersì—ì„œ drawPreview í˜¸ì¶œ í¬í•¨
    const originalRenderLayers = renderLayers;
    renderLayers = function () {
        originalRenderLayers();
        drawPreview();
    };

    // ë°°ê²½ ì´ë¯¸ì§€ ì—…ë¡œë“œ í•¸ë“¤ëŸ¬
    function uploadBackgroundImage(input) {
        if (input.files && input.files[0]) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const img = new Image();
                img.crossOrigin = "anonymous"; // CORS issue prevention
                img.onload = function () {
                    bgImage = img; // Update global background image

                    // Hide placeholder text
                    const placeholder = document.getElementById('previewPlaceholder');
                    if (placeholder) placeholder.classList.add('hidden');

                    drawPreview();
                    Utils.showToast('ë°°ê²½ ì´ë¯¸ì§€ê°€ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(input.files[0]);
        }
    }

    // ìµœì¢… ì¸ë„¤ì¼ ìƒì„±
    // ìµœì¢… ì¸ë„¤ì¼ ìƒì„± (Canvas ìº¡ì²˜ & ì €ì¥)
    async function generateFinalThumbnail() {
        // [Modified] Check if bgImage exists instead of selectedPrompt, to allow uploaded images
        if (!bgImage && !selectedPrompt) {
            Utils.showToast('ë¨¼ì € ì•„ì´ë””ì–´ë¥¼ ì„ íƒí•˜ê±°ë‚˜ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ì„¸ìš”', 'warning');
            return;
        }

        const validLayers = textLayers.filter(l => l.text.trim() !== '');
        if (validLayers.length === 0 && shapeLayers.length === 0) {
            Utils.showToast('ìµœì†Œ í•˜ë‚˜ ì´ìƒì˜ í…ìŠ¤íŠ¸ ë˜ëŠ” ë„í˜•ì„ ì…ë ¥í•˜ì„¸ìš”', 'warning');
            return;
        }

        const btn = document.getElementById('generateBtn');
        const originalText = btn.innerText;
        Utils.setLoading(btn, true, 'ì¸ë„¤ì¼ ì €ì¥ ì¤‘...');

        try {
            const canvas = document.getElementById('thumbnailCanvas');

            // ìº”ë²„ìŠ¤ ë°ì´í„°ë¥¼ Blobìœ¼ë¡œ ë³€í™˜
            canvas.toBlob(async (blob) => {
                if (!blob) {
                    Utils.setLoading(btn, false);
                    Utils.showToast('ì´ë¯¸ì§€ ë³€í™˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤', 'error');
                    return;
                }

                const projectId = getCurrentProject();
                if (!projectId) {
                    Utils.setLoading(btn, false);
                    Utils.showToast('í”„ë¡œì íŠ¸ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
                    return;
                }

                // ì„œë²„ë¡œ ì „ì†¡
                const formData = new FormData();
                formData.append('file', blob, 'thumbnail.png');

                try {
                    const response = await fetch(`/api/projects/${projectId}/thumbnail/save`, {
                        method: 'POST',
                        body: formData
                    });
                    const result = await response.json();

                    if (response.ok && result.status === 'ok') {
                        // ê²°ê³¼ í‘œì‹œ
                        document.getElementById('resultImage').src = result.url;
                        document.getElementById('downloadLink').href = result.url;
                        document.getElementById('resultSection').classList.remove('hidden');

                        // ì´ë ¥ ì¶”ê°€
                        generatedHistory.unshift(result.url);
                        updateHistory();

                        Utils.showToast('ì¸ë„¤ì¼ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');

                        // [NEW] Update Progress Stepper Immediately
                        if (window.updateStepStatus) {
                            window.updateStepStatus('thumbnail', true);
                        }

                        // ì¸ë„¤ì¼ ì•„ì´ë””ì–´/í…ìŠ¤íŠ¸ ì •ë³´ë„ í•¨ê»˜ ì €ì¥ (ì„ íƒ ì‚¬í•­)
                        try {
                            await API.project.saveThumbnails(projectId, thumbnailData.ideas, thumbnailData.texts);
                        } catch (ignore) { }

                        saveStateToLocal(); // ì €ì¥
                        document.getElementById('resultSection').scrollIntoView({ behavior: 'smooth' });
                    } else {
                        throw new Error(result.detail || result.error || 'ì €ì¥ ì‹¤íŒ¨');
                    }
                } catch (err) {
                    console.error('Upload Error:', err);
                    Utils.showToast(`ì €ì¥ ì‹¤íŒ¨: ${err.message}`, 'error');
                } finally {
                    Utils.setLoading(btn, false);
                }
            }, 'image/png', 1.0); // High quality

        } catch (error) {
            Utils.showToast('ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message, 'error');
            console.error(error);
            Utils.setLoading(btn, false);
        }
    }

    // ì´ë ¥ ì—…ë°ì´íŠ¸
    function updateHistory() {
        const container = document.getElementById('historyList');
        container.innerHTML = generatedHistory.slice(0, 12).map((url, i) => `
            <a href="${url}" download="thumbnail_${i}.png" class="block">
                <img src="${url}" alt="History ${i}" class="w-full h-16 object-cover rounded-lg hover:ring-2 hover:ring-primary transition">
            </a>
        `).join('');
    }

    // ë‹¤ì‹œ ìƒì„±
    function regenerate() {
        generateFinalThumbnail();
    }

    // --- Persistence Logic ---
    function saveStateToLocal() {
        const title = document.getElementById('videoTitle').value;
        const style = document.getElementById('thumbnailStyle').value;
        const aspectRatio = currentAspectRatio;


        const state = {
            title,
            style,
            aspectRatio,

            thumbnailData,
            selectedIdeaIndex,
            selectedPrompt,
            textLayers,
            shapeLayers,
            currentBackgroundPath,
            currentBackgroundUrl,
            generatedHistory,
            appMode: window.APP_MODE,
            projectId: getCurrentProject() // [NEW] Scope by Project ID
        };
        try {
            sessionStorage.setItem('thumbnail_gen_state', JSON.stringify(state));
        } catch (e) {
            console.warn('Storage saving failed', e);
        }
    }

    // [NEW] Aspect Ratio Handler
    function setAspectRatio(ratio, save = true) {
        currentAspectRatio = ratio;
        const canvas = document.getElementById('thumbnailCanvas');
        const previewContainer = document.getElementById('previewContainer');
        if (!canvas || !previewContainer) return;

        // Update Canvas Size
        let targetW, targetH;
        if (ratio === '9:16') {
            targetW = 720; targetH = 1280;

            // Container Styling for Shorts
            previewContainer.style.maxWidth = '340px';
            previewContainer.style.aspectRatio = '9/16';
            previewContainer.classList.remove('aspect-video');

            // Update Info Text
            const info = document.getElementById('thumbnailSizeInfo');
            if (info) info.innerText = 'í¬ê¸°: 720 x 1280 (9:16)';
        } else {
            targetW = 1280; targetH = 720;

            // Container Styling for Longform
            previewContainer.style.maxWidth = '100%';
            previewContainer.style.aspectRatio = '16/9';

            // Update Info Text
            const info = document.getElementById('thumbnailSizeInfo');
            if (info) info.innerText = 'í¬ê¸°: 1280 x 720 (16:9)';
        }

        // Canvas scale logic (display vs internal)
        canvas.width = targetW;
        canvas.height = targetH;

        drawPreview();
        if (save) saveStateToLocal();
    }

    async function savePermanentSettings() {
        const btn = document.getElementById('saveSettingsBtn');
        const projectId = getCurrentProject();
        if (!projectId) {
            Utils.showToast('í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.', 'error');
            return;
        }

        Utils.setLoading(btn, true);

        const title = document.getElementById('videoTitle').value;
        const style = document.getElementById('thumbnailStyle').value;
        const aspectRatio = currentAspectRatio;

        const fullSettings = {
            title,
            style,
            aspectRatio,
            selectedIdeaIndex,
            selectedPrompt,
            textLayers,
            shapeLayers,
            currentBackgroundPath,
            currentBackgroundUrl,
            generatedHistory,
            appMode: window.APP_MODE,
            projectId: projectId
        };

        try {
            // ideasì™€ textsëŠ” thumbnailDataì—ì„œ ì¶”ì¶œ
            const ideas = thumbnailData ? thumbnailData.ideas : [];
            const texts = thumbnailData ? thumbnailData.texts : [];

            const payload = {
                ideas: ideas,
                texts: texts,
                full_settings: fullSettings
            };

            const response = await fetch(`/api/projects/${projectId}/thumbnails`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json();
            if (result.status === 'ok') {
                Utils.showToast('ëª¨ë“  ì„¤ì •ì´ ì„œë²„ì— ì˜êµ¬ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                saveStateToLocal(); // ë¡œì»¬ ì„¸ì…˜ë„ ë™ê¸°í™”
            } else {
                throw new Error(result.error || 'ì €ì¥ ì‹¤íŒ¨');
            }
        } catch (error) {
            console.error('Save settings error:', error);
            Utils.showToast(`ì €ì¥ ì‹¤íŒ¨: ${error.message}`, 'error');
        } finally {
            Utils.setLoading(btn, false);
        }
    }

    async function loadStateFromLocal() {
        // [Fix] Ensure we know the App Mode first
        let currentMode = window.APP_MODE;
        if (!currentMode) {
            try {
                const res = await fetch('/api/settings');
                const settings = await res.json();
                currentMode = settings.app_mode || 'longform';
                window.APP_MODE = currentMode;
            } catch (e) {
                currentMode = 'longform';
            }
        }

        let saved = sessionStorage.getItem('thumbnail_gen_state');
        let state = null;

        if (!saved) {
            // [NEW] ì„œë²„ì—ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì‹œë„
            try {
                const projectId = getCurrentProject();
                if (projectId) {
                    const res = await fetch(`/api/projects/${projectId}/thumbnails`);
                    const result = await res.json();
                    if (result && result.full_settings && Object.keys(result.full_settings).length > 0) {
                        console.log("Found settings on server, using them.");
                        state = result.full_settings;
                        // thumbnailDataëŠ” ideasì™€ textsë¡œ ì¬êµ¬ì„± í•„ìš”í•  ìˆ˜ ìˆìŒ
                        if (!state.thumbnailData && result.ideas) {
                            state.thumbnailData = {
                                ideas: result.ideas,
                                texts: result.texts || []
                            };
                        }
                    }
                }
            } catch (e) {
                console.log("No server-side settings found or error fetching:", e);
            }
        } else {
            try {
                state = JSON.parse(saved);
            } catch (e) { }
        }

        if (!state) return;
        try {
            const currentProjectId = getCurrentProject();

            // [NEW] Project ID Scope Check
            // If saved state has no ID (legacy) or ID mismatch -> Reset
            if (!state.projectId || state.projectId !== currentProjectId) {
                console.log(`Project ID mismatch or Legacy Data (Saved: ${state.projectId}, Current: ${currentProjectId}). Resetting state.`);
                sessionStorage.removeItem('thumbnail_gen_state');
                return;
            }

            // [NEW] Mode validation
            // Only wipe if there is an explicit mismatch. Legacy state (undefined appMode) is allowed but migrated.
            if ((state.appMode || 'longform') !== currentMode) {
                console.log(`App mode mismatch (Saved: ${state.appMode || 'legacy'}, Current: ${currentMode}). Resetting state.`);
                sessionStorage.removeItem('thumbnail_gen_state');
                return;
            }

            if (state.title) document.getElementById('videoTitle').value = state.title;
            if (state.style) selectThumbnailStyle(state.style);
            // Aspect Ratio Restore
            // [FIX] Force Aspect Ratio based on Mode
            if (currentMode === 'shorts') {
                setAspectRatio('9:16', false);
            } else if (state.aspectRatio) {
                setAspectRatio(state.aspectRatio, false);
            } else {
                setAspectRatio('16:9', false);
            }



            if (state.thumbnailData) {
                thumbnailData = state.thumbnailData;
                selectedIdeaIndex = state.selectedIdeaIndex;
                selectedPrompt = state.selectedPrompt;
                renderIdeas();
                document.getElementById('ideasSection').classList.remove('hidden');
            }

            if (state.textLayers) {
                textLayers = state.textLayers;
                document.getElementById('textSection').classList.remove('hidden');
                // í…ìŠ¤íŠ¸ í›„ë³´ í‘œì‹œ ë³µêµ¬
                if (thumbnailData && thumbnailData.texts) {
                    const textContainer = document.getElementById('textCandidates');
                    textContainer.innerHTML = thumbnailData.texts.map(text => `
                        <button onclick="addTextToActiveLayer('${text.replace(/'/g, "\\'")}')" class="px-3 py-1 bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-300 rounded-lg hover:bg-yellow-200 transition text-sm">
                            ${text}
                        </button>
                    `).join('');
                }
            }
            if (state.shapeLayers) shapeLayers = state.shapeLayers;

            // ë°°ê²½ ì´ë¯¸ì§€ ë³µêµ¬
            if (state.currentBackgroundUrl) {
                currentBackgroundPath = state.currentBackgroundPath;
                currentBackgroundUrl = state.currentBackgroundUrl;

                // ì´ë¯¸ì§€ ë¡œë“œ í›„ ê·¸ë¦¬ê¸° ë° ìƒíƒœ ë³µì›
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => {
                    bgImage = img; // [IMPORTANT] Global variable restore
                    drawPreview();
                };
                img.onerror = () => {
                    console.warn("Failed to load saved background image (expired?)");
                    // Don't wipe state, just ignore bg
                };
                img.src = state.currentBackgroundUrl;

                // ë°°ê²½ ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ê²°ê³¼ ì„¹ì…˜ì´ ì•„ë‹ˆë¼ í”„ë¦¬ë·°ì— ë³´ì—¬ì•¼ í•¨.
                const placeholder = document.getElementById('previewPlaceholder');
                if (placeholder) placeholder.classList.add('hidden');
            }

            if (state.generatedHistory) {
                generatedHistory = state.generatedHistory;
                updateHistory();

                // [NEW] If history exists, restore the most recent one as main result
                if (generatedHistory.length > 0) {
                    const lastUrl = generatedHistory[0];
                    const img = document.getElementById('resultImage');
                    img.src = lastUrl;
                    document.getElementById('downloadLink').href = lastUrl;
                    document.getElementById('resultSection').classList.remove('hidden');
                }
            }

            renderLayers();
            renderShapeLayers();
            drawPreview();

            Utils.showToast('ì´ì „ ì‘ì—… ìƒíƒœë¥¼ ë³µêµ¬í–ˆìŠµë‹ˆë‹¤.', 'info');

        } catch (e) {
            console.error('State load error:', e);
        }
    }
</script>
{% endblock %}