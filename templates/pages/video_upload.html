{% extends "base.html" %}

{% block content %}
<div class="h-[calc(100vh-140px)] flex flex-col gap-3 p-2">
    <!-- Top Bar -->
    <div
        class="flex items-center justify-between p-2 bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 shrink-0">
        <h3 class="font-bold text-gray-800 dark:text-white flex items-center gap-2">
            <span>ğŸ“¤ {{ t('nav_upload_video') }}</span>
            <span class="text-xs font-normal text-gray-500">{{ t('upload_video_desc') }}</span>
        </h3>
    </div>

    <!-- Main Grid -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-3 flex-1 min-h-0">

        <!-- Left: Upload Zone -->
        <div
            class="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-4 flex flex-col justify-center">
            <div id="uploadArea"
                class="flex-1 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-xl flex flex-col items-center justify-center p-6 cursor-pointer hover:border-primary hover:bg-blue-50 dark:hover:bg-blue-900/10 transition-all group"
                ondrop="handleDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)"
                onclick="document.getElementById('fileInput').click()">

                <div
                    class="w-16 h-16 mb-4 rounded-full bg-gray-100 dark:bg-gray-700 mx-auto flex items-center justify-center text-gray-400 group-hover:text-primary group-hover:bg-white transition-colors">
                    <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12">
                        </path>
                    </svg>
                </div>

                <p class="text-sm font-bold text-gray-700 dark:text-gray-300">{{ t('drag_or_click') }}</p>
                <p class="text-xs text-gray-500 mt-2 text-center">{{ t('upload_size_hint') }}</p>
                <input type="file" id="fileInput" accept="video/*" class="hidden" onchange="handleFileSelect(event)">
            </div>

            <!-- Upload Progress -->
            <div id="uploadProgress" class="hidden mt-4">
                <div class="flex justify-between text-xs mb-1">
                    <span class="font-bold text-blue-600">{{ t('status_uploading') }}</span>
                    <span id="progressPercent">0%</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-1.5 dark:bg-gray-700 overflow-hidden">
                    <div id="progressBar" class="bg-blue-600 h-1.5 rounded-full transition-all duration-300"
                        style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- Right: Preview & Actions -->
        <div
            class="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-4 flex flex-col overflow-hidden relative">
            <div id="emptyState"
                class="absolute inset-0 flex flex-col items-center justify-center text-gray-400 bg-gray-50/50 dark:bg-gray-900/50 z-10 backdrop-blur-[1px]">
                <div class="text-4xl mb-2 grayscale opacity-30">ğŸ“º</div>
                <p class="text-xs">{{ t('preview_placeholder_upload') }}</p>
            </div>

            <div id="previewContent" class="flex flex-col h-full gap-4">
                <!-- Player -->
                <div class="relative bg-black rounded-lg overflow-hidden shadow-md shrink-0"
                    style="aspect-ratio: 16/9;">
                    <video id="videoPlayer" controls class="absolute inset-0 w-full h-full object-contain"></video>
                </div>

                <!-- Info -->
                <div
                    class="grid grid-cols-2 gap-2 text-xs text-gray-600 dark:text-gray-400 bg-gray-50 dark:bg-gray-700/50 p-3 rounded-lg border border-gray-100 dark:border-gray-700">
                    <div>{{ t('label_filename') }} <span id="videoFileName"
                            class="text-gray-900 dark:text-white font-mono truncate block"></span></div>
                    <div>{{ t('label_filesize') }} <span id="videoFileSize"
                            class="text-gray-900 dark:text-white font-mono"></span></div>
                    <div>{{ t('label_duration') }} <span id="videoDuration"
                            class="text-gray-900 dark:text-white font-mono"></span></div>
                </div>

                <div class="flex-1"></div>

                <!-- Actions -->
                <div class="grid grid-cols-1 gap-2">
                    {% if is_independent %}
                    <button onclick="uploadToYouTube()" id="youtubeUploadBtn"
                        class="btn-primary py-2.5 flex items-center justify-center gap-2 text-sm shadow-md">
                        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                            <path
                                d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z" />
                        </svg>
                        {{ t('btn_post_yt') }}
                    </button>
                    {% else %}
                    <button onclick="requestPublish()" id="requestPublishBtn"
                        class="btn-primary py-2.5 bg-purple-600 hover:bg-purple-700 flex items-center justify-center gap-2 text-sm shadow-md">
                        <span>ğŸ“¤</span> {{ t('btn_reserve') }} ì‹ ì²­ (ê²€ìˆ˜ í•„ìš”)
                    </button>
                    <p class="text-[10px] text-gray-500 text-center mt-1">
                        * ì¼ë°˜ íšŒì›ì€ ì—…ë¡œë“œ ì˜ˆì•½ í›„ ê´€ë¦¬ì í™•ì¸ì„ ê±°ì³ ìµœì¢… ê²Œì‹œë©ë‹ˆë‹¤.
                    </p>
                    {% endif %}
                    <button onclick="deleteVideo()"
                        class="btn-secondary py-2 text-xs hover:text-red-600 hover:bg-red-50 hover:border-red-200">
                        ğŸ—‘ï¸ {{ t('btn_delete_video') }}
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    let uploadedVideoPath = null;
    let currentVideoFile = null; // Store the original file for cloud upload

    function handleDragOver(e) { e.preventDefault(); e.currentTarget.classList.add('border-primary', 'bg-blue-50'); }
    function handleDragLeave(e) { e.preventDefault(); e.currentTarget.classList.remove('border-primary', 'bg-blue-50'); }
    function handleDrop(e) {
        e.preventDefault();
        const files = e.dataTransfer.files;
        if (files.length) processFile(files[0]);
    }
    function handleFileSelect(e) { if (e.target.files.length) processFile(e.target.files[0]); }

    function processFile(file) {
        if (file.size > 2 * 1024 * 1024 * 1024) return Utils.showToast("{{ t('err_upload_limit') }}", 'error');
        uploadVideo(file);
    }

    async function uploadVideo(file) {
        const projectId = getCurrentProject();
        if (!projectId) return Utils.showToast("{{ t('toast_select_project_first') }}", 'warning');

        const formData = new FormData(); formData.append('file', file);
        document.getElementById('uploadProgress').classList.remove('hidden');

        try {
            const xhr = new XMLHttpRequest();
            xhr.upload.addEventListener('progress', (e) => {
                if (e.lengthComputable) {
                    const pct = Math.round((e.loaded / e.total) * 100);
                    document.getElementById('progressBar').style.width = pct + '%';
                    document.getElementById('progressPercent').innerText = pct + '%';
                }
            });
            xhr.onload = () => {
                if (xhr.status === 200) {
                    const res = JSON.parse(xhr.responseText);
                    if (res.status === 'ok') {
                        uploadedVideoPath = res.path;
                        currentVideoFile = file; // Save file reference
                        showVideoPreview(file, res);
                        Utils.showToast("{{ t('toast_upload_finished') }}", 'success');

                        // [NEW] Update Progress Stepper
                        if (window.updateStepStatus) window.updateStepStatus('upload', true);

                    } else Utils.showToast(res.error, 'error');
                } else Utils.showToast("{{ t('toast_upload_fail') }}", 'error');
                document.getElementById('uploadProgress').classList.add('hidden');
            };
            xhr.open('POST', `/api/video/upload-external/${projectId}`);
            xhr.send(formData);
        } catch (e) { Utils.showToast("{{ t('status_error') }}", 'error'); }
    }

    function showVideoPreview(file, result) {
        document.getElementById('emptyState').classList.add('hidden');
        const player = document.getElementById('videoPlayer');
        player.src = result.url;
        player.load();

        document.getElementById('videoFileName').textContent = file.name;
        document.getElementById('videoFileSize').textContent = (file.size / (1024 * 1024)).toFixed(1) + ' MB';
        player.addEventListener('loadedmetadata', () => {
            document.getElementById('videoDuration').textContent = Math.floor(player.duration) + 's';
        });
    }

    async function requestPublish() {
        const projectId = getCurrentProject();
        if (!uploadedVideoPath) return Utils.showToast("{{ t('toast_no_video_uploaded') }}", 'warning');

        const btn = document.getElementById('requestPublishBtn');
        Utils.setLoading(btn, true, "ìœ íŠœë¸Œì— ì˜ˆì•½ ì—…ë¡œë“œ ì¤‘...");

        try {
            // 1. YouTube Upload (as Private by default in backend for Standard)
            const ytRes = await fetch(`/api/youtube/upload-external/${projectId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            const ytData = await ytRes.json();

            if (ytData.status !== 'ok') {
                throw new Error(ytData.error || "ìœ íŠœë¸Œ ì—…ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ");
            }

            const videoId = ytData.video_id;
            const videoUrl = ytData.url;

            // 1.5 Cloud Upload for Admin Preview (Optional but Recommended)
            let cloudPath = null;
            if (currentVideoFile) {
                try {
                    Utils.setLoading(btn, true, "í´ë¼ìš°ë“œ ê²€í† ìš© ì˜ìƒ ì—…ë¡œë“œ ì¤‘...");

                    // A. Get Signed URL
                    const signRes = await fetch('{{ AUTH_SERVER_URL }}/api/publishing/presigned-url', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            userId: "{{ get_license_key() }}",
                            fileName: currentVideoFile.name,
                            fileType: currentVideoFile.type
                        })
                    });
                    const signData = await signRes.json();

                    if (signData.success) {
                        // B. Upload to Storage
                        const uploadRes = await fetch(signData.uploadUrl, {
                            method: 'PUT',
                            body: currentVideoFile,
                            headers: { 'Content-Type': currentVideoFile.type }
                        });

                        if (uploadRes.ok) {
                            cloudPath = signData.path;
                        }
                    }
                } catch (err) {
                    console.warn("Cloud upload failed, but continuing with YouTube record:", err);
                }
            }

            // 2. Submit record to Central Server for Admin tracking
            Utils.setLoading(btn, true, "ê²€í†  ë ˆì½”ë“œ ë“±ë¡ ì¤‘...");
            const project = await API.project.get(projectId);
            const settings = await API.project.getSettings(projectId);

            const payload = {
                userId: "{{ get_license_key() }}",
                videoUrl: cloudPath || videoUrl, // Use cloud path if available for preview
                videoId: videoId,
                metadata: {
                    title: settings.title || project.name,
                    projectId: projectId,
                    duration: document.getElementById('videoDuration').textContent,
                    isYouTubePrivate: true,
                    isCloud: !!cloudPath,
                    youtubeUrl: videoUrl
                }
            };

            const res = await fetch('{{ AUTH_SERVER_URL }}/api/publishing', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const data = await res.json();
            if (data.success) {
                Utils.showToast("ì„±ê³µ! ìœ íŠœë¸Œ ì±„ë„ì— 'ë¹„ê³µê°œ'ë¡œ ì—…ë¡œë“œë˜ì—ˆìœ¼ë©° ê´€ë¦¬ìì—ê²Œ ê²€í† ê°€ ìš”ì²­ë˜ì—ˆìŠµë‹ˆë‹¤.", 'success');
                btn.disabled = true;
                btn.className = "btn-secondary py-2.5 w-full bg-green-500/10 text-green-500 border-green-500/20";
                btn.innerHTML = "<span>âœ…</span> ìœ íŠœë¸Œ ì˜ˆì•½ ì—…ë¡œë“œ ì™„ë£Œ";
            } else {
                throw new Error(data.error || "ì¤‘ì•™ ì„œë²„ ì „ì†¡ ì‹¤íŒ¨");
            }
        } catch (e) {
            console.error(e);
            Utils.showToast(e.message || "ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ", 'error');
        } finally {
            Utils.setLoading(btn, false);
        }
    }

    async function uploadToYouTube() {
        const projectId = getCurrentProject();
        if (!uploadedVideoPath) return Utils.showToast("{{ t('toast_no_video_uploaded') }}", 'warning');

        const btn = document.getElementById('youtubeUploadBtn');
        Utils.setLoading(btn, true, "{{ t('status_uploading') }}");
        try {
            // Independent users upload as PUBLIC by default (or we could add a toggle)
            const res = await fetch(`/api/youtube/upload-external/${projectId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ privacy: 'public' })
            });
            const data = await res.json();
            if (data.status === 'ok') {
                Utils.showToast("{{ t('toast_post_finished') }}", 'success');
                window.open(`https://www.youtube.com/watch?v=${data.video_id}`, '_blank');
            } else Utils.showToast(data.error, 'error');
        } catch (e) { Utils.showToast("{{ t('toast_post_fail') }}", 'error'); }
        finally { Utils.setLoading(btn, false); }
    }

    async function deleteVideo() {
        if (!confirm('ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
        const projectId = getCurrentProject();
        try {
            await fetch(`/api/video/delete-external/${projectId}`, { method: 'DELETE' });
            location.reload();
        } catch (e) { Utils.showToast("{{ t('status_error') }}", 'error'); }
    }

    document.addEventListener('DOMContentLoaded', async () => {
        const projectId = getCurrentProject();
        if (projectId) {
            const data = await API.project.getFull(projectId);
            const settings = data.settings || {};
            const metadata = data.metadata || {};
            const hasDesc = !!metadata.description;

            // 1. Determine Video Path (Prefer External, then Rendered)
            let videoPath = settings.external_video_path;
            let videoSource = 'external';

            if (!videoPath && settings.video_path) {
                videoPath = settings.video_path;
                videoSource = 'rendered';
            }

            if (videoPath) {
                // Construct URL
                // If it's absolute local path, we need to convert to relative /output/...
                let webUrl = "";
                if (videoPath.includes('output')) {
                    const parts = videoPath.split('output');
                    webUrl = '/output' + parts[parts.length - 1].replace(/\\/g, '/');
                }

                if (webUrl) {
                    uploadedVideoPath = videoPath;

                    // Fetch file info (especially size)
                    try {
                        const headRes = await fetch(webUrl, { method: 'HEAD' });
                        const size = headRes.headers.get('content-length');
                        showVideoPreview({
                            name: videoSource === 'rendered' ? 'Rendered Final Video' : 'Uploaded Video',
                            size: size ? parseInt(size) : 0
                        }, { url: webUrl });
                    } catch (e) {
                        showVideoPreview({
                            name: videoSource === 'rendered' ? 'Rendered Final Video' : 'Uploaded Video',
                            size: 0
                        }, { url: webUrl });
                    }
                }
            }

            // [NEW] Enable button if metadata is finished, even if not manually uploaded just now
            const isFinished = hasDesc && videoPath;
            // The buttons are enabled by default in HTML, but let's make sure the state is clear
            if (isFinished) {
                console.log("Project is ready for publish/upload");
            } else if (!videoPath) {
                // No video yet
            }
        }
    });
</script>
{% endblock %}