{% extends "base.html" %}

{% block content %}
<style>
    @import url('https://fonts.googleapis.com/css2?family=Nanum+Myeongjo:wght@700;800&family=Jua&family=Do+Hyeon&family=Black+Han+Sans&display=swap');

    @font-face {
        font-family: 'CookieRun-Regular';
        src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/CookieRun-Regular.woff') format('woff');
    }

    @font-face {
        font-family: 'GmarketSansBold';
        src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/GmarketSansBold.woff') format('woff');
    }

    @font-face {
        font-family: 'TmonMonsori';
        src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_two@1.0/TmonMonsori.woff') format('woff');
    }

    @font-face {
        font-family: 'Jalnan';
        src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_four@1.0/Jalnan.woff') format('woff');
    }

    @font-face {
        font-family: 'Pretendard-Bold';
        src: url('https://fastly.jsdelivr.net/gh/Project-Noonnu/noonfonts_2107@1.1/Pretendard-Bold.woff') format('woff');
    }

    @font-face {
        font-family: 'NanumSquareExtraBold';
        src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_seven@1.1/NanumSquareExtraBold.woff') format('woff');
    }

    @font-face {
        font-family: 'BinggraeMelona-Bold';
        src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_twelve@1.1/BinggraeMelona-Bold.woff') format('woff');
    }

    @font-face {
        font-family: 'NetmarbleB';
        src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_four@1.0/netmarbleB.woff') format('woff');
    }

    @font-face {
        font-family: 'ChosunIlboMyungjo';
        src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_one@1.0/ChosunIlboMyungjo.woff') format('woff');
    }

    @font-face {
        font-family: 'MapoFlowerIsland';
        src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_2001@1.1/MapoFlowerIsland.woff') format('woff');
    }

    @font-face {
        font-family: 'S-CoreDream-6Bold';
        src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_six@1.2/S-CoreDream-6Bold.woff') format('woff');
    }

    @font-face {
        font-family: 'Gungsuh';
        src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_one@1.0/Gungsuh.woff') format('woff');
    }

    .custom-scrollbar::-webkit-scrollbar {
        width: 4px;
    }

    .custom-scrollbar::-webkit-scrollbar-track {
        background: transparent;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb {
        background-color: #cbd5e1;
        border-radius: 20px;
    }

    .dark .custom-scrollbar::-webkit-scrollbar-thumb {
        background-color: #4b5563;
    }

    /* Compact inputs */
    .input-compact {
        @apply text-xs border-gray-300 dark:border-gray-600 rounded py-1 px-2 bg-gray-50 dark:bg-gray-700 dark:text-white focus:ring-1 focus:ring-primary focus:border-primary;
    }

    .subtitle-row.active {
        @apply bg-blue-50 dark:bg-blue-900/30 border-blue-200 dark:border-blue-700;
    }
</style>

<div class="h-[calc(100vh-140px)] flex flex-col gap-3 p-2">
    <!-- 1. Top Control Bar (Style & Actions) -->
    <div
        class="flex items-center gap-2 p-2 bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 shrink-0 flex-wrap">

        <!-- Font Settings -->
        <div class="flex items-center gap-2 border-r border-gray-200 dark:border-gray-600 pr-2">
            <span class="text-xs font-bold text-gray-700 dark:text-gray-300">서체</span>
            <select id="fontFamilySelect" class="input-compact w-24">
                <option value="GmarketSansBold" selected>G마켓산스</option>
                <option value="TmonMonsori">티몬몬소리</option>
                <option value="Jalnan">여가잘난체</option>
                <option value="Black Han Sans">검은고딕</option>
                <option value="Pretendard-Bold">프리텐다드</option>
                <option value="NanumSquareExtraBold">나눔스퀘어</option>
                <option value="Jua">배민 주아</option>
                <option value="Do Hyeon">배민 도현</option>
                <option value="CookieRun-Regular">쿠키런</option>
                <option value="BinggraeMelona-Bold">빙그레체</option>
                <option value="NetmarbleB">넷마블체</option>
                <option value="ChosunIlboMyungjo">조선일보명조</option>
                <option value="MapoFlowerIsland">마포꽃섬</option>
                <option value="S-CoreDream-6Bold">에스코어드림</option>
                <option value="Gungsuh">궁서체</option>
                <option value="NanumMyeongjo">나눔명조</option>
                <option value="Malgun Gothic">맑은고딕</option>
            </select>
            <!-- 폰트 크기 -->
            <div class="flex flex-col items-center gap-0">
                <span class="text-[10px] font-bold text-gray-400">크기</span>
                <div class="flex items-center gap-1">
                    <input type="number" id="fontSizeSlider" value="5.4" min="1" max="20" step="0.1"
                        class="input-compact w-14 text-center text-xs text-white bg-gray-700" title="폰트 크기 (%)">
                    <span class="text-[10px] text-gray-400">%</span>
                </div>
                <span id="fontSizeValue" class="hidden">5.4%</span>
            </div>

            <!-- 줄간격 -->
            <div class="flex flex-col items-center gap-0">
                <span class="text-[10px] font-bold text-gray-400">줄간격</span>
                <input type="number" id="lineSpacingInput" value="0.1" min="-0.5" max="1.5" step="0.05"
                    class="input-compact w-14 text-center text-xs text-white bg-gray-700" title="줄간격 비율">
            </div>
        </div>

        <!-- Color Settings -->
        <div class="flex items-center gap-2 border-r border-gray-200 dark:border-gray-600 pr-2">
            <span class="text-xs font-bold text-gray-700 dark:text-gray-300">색상</span>
            <div class="flex flex-col items-center">
                <input type="color" id="textColorInput" value="#ffffff"
                    class="w-6 h-4 p-0 border-0 rounded cursor-pointer" title="글자색">
                <span class="text-[10px] text-gray-400">글자</span>
            </div>
            <div class="flex flex-col items-center">
                <input type="color" id="strokeColorInput" value="#000000"
                    class="w-6 h-4 p-0 border-0 rounded cursor-pointer" title="테두리색">
                <span class="text-[10px] text-gray-400">테두리</span>
            </div>
        </div>

        <!-- Stroke Width (Reverted to numeric) -->
        <div class="flex flex-col items-center gap-1 border-r border-gray-200 dark:border-gray-600 px-2">
            <span class="text-xs font-bold text-gray-700 dark:text-gray-300">테두리두께</span>
            <div class="flex items-center gap-1">
                <input type="number" id="strokeWidthInput" value="0" min="0" max="15" step="0.5"
                    class="input-compact w-12 text-center text-xs text-white bg-gray-700" title="테두리 두께 (px)">
                <span class="text-[10px] text-gray-400">px</span>
            </div>
        </div>

        <!-- Background Strip Settings -->
        <div class="flex items-center gap-2 border-r border-gray-200 dark:border-gray-600 px-2">
            <div class="flex flex-col items-center gap-1">
                <span class="text-xs font-bold text-gray-700 dark:text-gray-300">배경띠</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="bgStripToggle" class="sr-only peer" onchange="updateBgStrip(this)">
                    <div
                        class="w-8 h-4 bg-gray-200 peer-focus:outline-none rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-3 after:w-3 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600">
                    </div>
                </label>
            </div>
            <div class="flex flex-col items-center">
                <input type="color" id="bgColorInput" value="#000000"
                    class="w-6 h-4 p-0 border-0 rounded cursor-pointer" title="배경색">
                <span class="text-[10px] text-gray-400">배경색</span>
            </div>
            <div class="flex flex-col items-center gap-0">
                <span class="text-[10px] font-bold text-gray-400">투명도</span>
                <input type="number" id="bgOpacityInput" value="0.5" min="0" max="1" step="0.1"
                    class="input-compact w-12 text-center text-xs text-white bg-gray-700" title="배경 투명도 (0~1)">
            </div>
        </div>

        <!-- Presets -->
        <div class="flex items-center gap-1 border-r border-gray-200 dark:border-gray-600 pr-2">
            <button onclick="applyPreset('basic_white')"
                class="w-5 h-5 bg-white border border-gray-300 rounded text-[10px] flex items-center justify-center shadow-sm"
                title="화이트">A</button>
            <button onclick="applyPreset('basic_black')"
                class="w-5 h-5 bg-black border border-gray-600 rounded text-[10px] text-white flex items-center justify-center shadow-sm"
                title="블랙">A</button>
            <button onclick="applyPreset('yellow_shadow')"
                class="w-5 h-5 bg-yellow-400 border border-yellow-600 rounded text-[10px] font-bold text-black flex items-center justify-center shadow-sm"
                title="옐로우">A</button>
        </div>

        <div class=" flex items-center gap-2 border-l border-gray-600 pl-4 ml-2">
            <span class="text-xs font-bold text-gray-400">화면비</span>
            <button id="ratioToggleBtn" onclick="toggleAspectRatio()"
                class="btn-secondary py-1 px-3 text-xs bg-gray-700 hover:bg-gray-600 text-white border-gray-600">
                화면비 16:9
            </button>
        </div>

        <div class="flex-1"></div>

        <!-- Actions -->
        <div class="flex items-center gap-2">
            <!-- [NEW] Reset Button -->
            <button onclick="resetAndReload(this)"
                class="px-3 py-1 text-xs bg-gray-500 hover:bg-gray-600 text-white rounded shadow transition flex items-center gap-1 border border-gray-600">
                <span>🔄 초기화 및 최신 데이터 로드</span>
            </button>

            <button onclick="distributeImages(this)"
                class="px-3 py-1 text-xs bg-indigo-600 hover:bg-indigo-700 text-white rounded shadow transition flex items-center gap-1">
                <span>AI 이미지 싱크 맞추기</span>
            </button>
            <button onclick="saveStyleSettings(this)"
                class="px-3 py-1 text-xs bg-green-600 hover:bg-green-700 text-white rounded shadow transition flex items-center gap-1">
                <span>💾 세팅저장</span>
            </button>
            <button id="saveBtn" onclick="saveSubtitles()"
                class="px-3 py-1 text-xs bg-red-600 hover:bg-red-700 text-white rounded shadow transition flex items-center gap-1">
                <span>저장</span>
            </button>
            <button id="renderBtn" onclick="renderVideoInPlace()"
                class="btn-primary py-1.5 px-4 text-xs font-bold bg-blue-600 hover:bg-blue-700 flex items-center gap-1">
                <span>영상 렌더링</span>
            </button>
        </div>
    </div>

    <!-- 2. Main Workspace (Grid) -->
    <div class="grid grid-cols-12 gap-3 flex-1 min-h-0">

        <!-- Left Panel: Subtitle List (Col-4) -->
        <div
            class="col-span-12 md:col-span-8 flex flex-col bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 shadow-sm overflow-hidden min-h-0">
            <!-- List Header -->
            <div
                class="p-2 bg-gray-50 dark:bg-gray-700/50 border-b border-gray-200 dark:border-gray-600 flex justify-between items-center shrink-0">
                <h3 class="text-xs font-bold text-gray-700 dark:text-gray-300 flex items-center gap-2">
                    자막 리스트 (DEBUG MODE)
                    <span id="debug-info" class="text-[10px] text-red-500 font-mono hidden"></span>
                </h3>
                <div class="flex gap-1">
                    <button onclick="regenerateSubtitles()"
                        class="text-[10px] bg-indigo-50 text-indigo-600 px-2 py-1 rounded hover:bg-indigo-100 border border-indigo-200">전체
                        AI 재생성</button>
                    <button onclick="addSubtitleRow()"
                        class="text-[10px] bg-gray-100 text-gray-600 px-2 py-1 rounded hover:bg-gray-200 border border-gray-300">+
                        추가</button>
                </div>
            </div>

            <!-- Lists & Strip Container -->
            <div class="flex flex-1 min-h-0 overflow-hidden">
                <!-- Vertical Image Strip -->
                <div id="imageThumbnailStrip"
                    class="w-20 flex flex-col gap-2 p-1 overflow-y-auto bg-gray-50 dark:bg-gray-900 border-r border-gray-200 dark:border-gray-700 custom-scrollbar shrink-0 items-center h-full min-h-0">
                    <!-- Thumbnails injected by JS -->
                </div>

                <!-- Subtitle List -->
                <div id="subtitleList" class="flex-1 overflow-y-auto custom-scrollbar p-1 space-y-1">
                    <!-- Rows injected by JS -->
                </div>
            </div>
        </div>

        <!-- Right Panel: Preview & Edit (Col-4) -->
        <div class="col-span-12 md:col-span-4 flex flex-col gap-3 min-h-0">

            <!-- Preview Area (Top) -->
            <div class="relative bg-black rounded-lg border border-gray-800 shadow-sm overflow-hidden group h-auto">
                <!-- Preview Container -->
                <div class="rounded-lg flex items-center justify-center">
                    <div id="mainPreviewBox"
                        class="relative w-full max-w-2xl bg-black shadow-2xl overflow-hidden transition-all duration-300">
                        <!-- Background Image/Video -->
                        <div id="previewContainer" class="absolute inset-0 flex items-start justify-center bg-gray-900">
                            <p class="text-gray-600 text-xs">자막을 선택하면 미리보기가 표시됩니다</p>
                        </div>
                    </div>
                </div>

                <!-- SVG Filter for Outline -->
                <!-- SVG Filter for Outline -->
                <svg width="0" height="0" class="absolute"
                    style="position: absolute; top:0; left:0; pointer-events: none;">
                    <defs>
                        <filter id="outlineFilter" x="-50%" y="-50%" width="200%" height="200%">
                            <feMorphology in="SourceAlpha" result="DILATED" operator="dilate" radius="0"
                                id="svgStokeWidth"></feMorphology>
                            <feFlood flood-color="#000000" flood-opacity="1" result="FLOOD" id="svgStrokeColor">
                            </feFlood>
                            <feComposite in="FLOOD" in2="DILATED" operator="in" result="OUTLINE"></feComposite>
                            <feMerge>
                                <feMergeNode in="OUTLINE"></feMergeNode>
                                <feMergeNode in="SourceGraphic"></feMergeNode>
                            </feMerge>
                        </filter>
                    </defs>
                </svg>

                <!-- Overlay Text -->
                <div id="subtitlePreviewBox" class="absolute inset-0 overflow-hidden pointer-events-none">
                    <div id="previewTextMain"
                        class="absolute transform -translate-x-1/2 -translate-y-1/2 pointer-events-auto cursor-move select-none whitespace-pre-wrap text-center leading-[0.95] hover:border hover:border-blue-400/50 hover:bg-white/10 rounded transition-colors px-4 py-2"
                        style="left: 50%; top: 75%; width: auto; max-width: 90%; font-weight: bold; color: white;">
                        자막 미리보기
                    </div>
                </div>

                <!-- Audio Controls Overlay -->
                <div
                    class="absolute bottom-0 left-0 right-0 bg-black/50 backdrop-blur-sm p-2 flex items-center opacity-0 group-hover:opacity-100 transition-opacity">
                    <audio id="audioPlayer" controls class="w-full h-8 opacity-90"></audio>
                </div>
            </div>

            <!-- Edit Area (Bottom) -->
            <div
                class="w-full max-w-2xl flex-1 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-3 shadow-sm flex flex-col min-h-0">
                <div class="flex flex-col mb-2">
                    <div class="flex justify-between items-center mb-1">
                        <h3 class="text-xs font-bold text-gray-700 dark:text-gray-300">현재 선택된 자막 편집</h3>
                        <div class="flex gap-1">
                            <button onclick="adjustTime(-0.1)"
                                class="px-2 py-0.5 bg-gray-100 dark:bg-gray-700 rounded border border-gray-300 dark:border-gray-600 text-[10px] font-bold hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors">-0.1s</button>
                            <button onclick="adjustTime(0.1)"
                                class="px-2 py-0.5 bg-gray-100 dark:bg-gray-700 rounded border border-gray-300 dark:border-gray-600 text-[10px] font-bold hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors">+0.1s</button>
                            <!-- [NEW] Contextual Save Button -->
                            <button onclick="saveAndSync()"
                                class="px-2 py-0.5 bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 rounded border border-blue-300 dark:border-blue-700 text-[10px] font-bold hover:bg-blue-200 dark:hover:bg-blue-800 transition-colors"
                                title="조정된 시간을 저장하고 이미지 싱크를 맞춥니다">저장</button>
                        </div>
                    </div>
                    <div class="flex justify-between items-center text-xs text-gray-500 mb-1">
                        <span class="font-semibold text-blue-500" id="currentImageIndicator">현재 이미지: -</span>
                        <div class="text-right">
                            <div class="text-right">
                                <span id="currentStartTime">0.00</span>s ~ <span id="currentEndTime">0.00</span>s
                            </div>
                        </div>
                        <!-- [NEW] Image Timing Control -->
                        <div
                            class="flex justify-between items-center bg-blue-50 dark:bg-gray-700/50 p-1 rounded mb-1 border border-blue-100 dark:border-gray-600">
                            <span class="text-[10px] font-bold text-blue-600 dark:text-blue-400">현재 이미지 시작</span>
                            <div class="flex items-center gap-2">
                                <span id="currentImageTime"
                                    class="text-xs font-mono text-gray-700 dark:text-gray-200">0.0s</span>
                                <div class="flex gap-1">
                                    <button onclick="adjustImageTime(-0.1)"
                                        class="px-1.5 py-0.5 bg-white dark:bg-gray-600 border border-gray-300 dark:border-gray-500 rounded text-[10px] hover:bg-gray-50">-0.1s</button>
                                    <button onclick="adjustImageTime(0.1)"
                                        class="px-1.5 py-0.5 bg-white dark:bg-gray-600 border border-gray-300 dark:border-gray-500 rounded text-[10px] hover:bg-gray-50">+0.1s</button>
                                </div>
                            </div>
                        </div>
                        <!-- [NEW] Image End Time Control -->
                        <div
                            class="flex justify-between items-center bg-orange-50 dark:bg-orange-900/20 p-1 rounded mb-1 border border-orange-100 dark:border-orange-800">
                            <span class="text-[10px] font-bold text-orange-600 dark:text-orange-400">현재 이미지
                                종료</span>
                            <div class="flex items-center gap-2">
                                <span id="currentImageEndTime"
                                    class="text-xs font-mono text-gray-700 dark:text-gray-200">-</span>
                                <div class="flex gap-1">
                                    <button id="btnImgEndMinus" onclick="adjustImageEndTime(-0.1)"
                                        class="px-1.5 py-0.5 bg-white dark:bg-gray-600 border border-gray-300 dark:border-gray-500 rounded text-[10px] hover:bg-gray-50">-0.1s</button>
                                    <button id="btnImgEndPlus" onclick="adjustImageEndTime(0.1)"
                                        class="px-1.5 py-0.5 bg-white dark:bg-gray-600 border border-gray-300 dark:border-gray-500 rounded text-[10px] hover:bg-gray-50">+0.1s</button>
                                </div>
                            </div>
                        </div>
                    </div>


                    <textarea id="currentSubtitleText"
                        class="flex-1 w-full p-2 text-sm border border-gray-200 dark:border-gray-600 rounded resize-none bg-gray-50 dark:bg-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 text-center leading-relaxed overflow-y-auto min-h-[5rem]"
                        placeholder="리스트에서 자막을 선택하세요."></textarea>

                    <!-- DEBUG OVERLAY -->
                    <div id="debug-overlay" class="hidden">
                        DEBUG: Initializing...
                    </div>
                </div>
            </div>

            <!-- Rendered Video Section (New) -->
            <div id="renderedVideoSection"
                class="hidden bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-3 shadow-sm">
                <div class="flex items-center justify-between mb-2">
                    <h3 class="text-sm font-bold text-gray-700 dark:text-gray-300">🎬 렌더링된 영상</h3>
                    <button onclick="closeRenderedVideo()"
                        class="text-xs text-gray-500 hover:text-gray-700 dark:hover:text-gray-300">
                        ✕ 닫기
                    </button>
                </div>
                <div id="renderedVideoPlayer" class="bg-black rounded-lg overflow-hidden" style="aspect-ratio: 16/9;">
                    <!-- Video player will be inserted here -->
                </div>
            </div>
        </div>
    </div>
</div>

</div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Global State
    let projectId = {{ project.id if project else 'null' }};
    let subtitles = [];
    let images = []; // Timeline Images (Used in video)
    let sourceImages = []; // Palette Images (Source)
    let loadedScript = "";
    let styleSettings = {};
    let audioDuration = 0;
    let selectedIndex = -1;
    let imageTimings = []; // [NEW] Image Start Times based on backend Pacing
    let imageEffects = []; // [NEW] Zoom/Pan Effects (1:1 with images)


    // --- Initialization ---
    // [NEW] Helper for Path Conversion (Local -> Web)
    Utils.convertToWebPath = function (path) {
        if (!path) return "";
        if (path.startsWith('http://') || path.startsWith('https://')) return path;

        // Normalize slashes
        let normalized = path.replace(/\\/g, '/');

        // Case-insensitive checks
        // We split by the case-insensitive regex of the folder name surrounded by slashes

        // Output
        if (/\/output\//i.test(normalized)) {
            const parts = normalized.split(/\/output\//i);
            // Rejoin the rest in case there are multiple (though unlikely for base mount)
            // Always assume the *mount* point corresponds to the *folder* name.
            return '/output/' + parts.slice(1).join('/output/');
        }

        // Static
        if (/\/static\//i.test(normalized)) {
            const parts = normalized.split(/\/static\//i);
            return '/static/' + parts.slice(1).join('/static/');
        }

        // Uploads
        if (/\/uploads\//i.test(normalized)) {
            const parts = normalized.split(/\/uploads\//i);
            return '/uploads/' + parts.slice(1).join('/uploads/');
        }

        return path;
    };

    document.addEventListener('DOMContentLoaded', async () => {
        // [FIX] Wait for Utils to be ready
        const waitForUtils = () => new Promise(resolve => {
            if (typeof Utils !== 'undefined') return resolve();
            const interval = setInterval(() => {
                if (typeof Utils !== 'undefined') {
                    clearInterval(interval);
                    resolve();
                }
            }, 100);
        });

        await waitForUtils();

        // Initialize Utils-dependent variables
        if (!projectId) {
            // Priority 1: URL Param (Most Reliable for direct links)
            const urlParams = new URLSearchParams(window.location.search);
            const pid = urlParams.get('project_id');
            if (pid) projectId = parseInt(pid);

            // Priority 2: storage (Fallback)
            if (!projectId) {
                const storedId = Utils.storage.get('currentProjectId');
                if (storedId) projectId = parseInt(storedId);
            }
        }

        if (!projectId) {
            Utils.showToast('프로젝트 ID를 찾을 수 없습니다. 메인화면에서 프로젝트를 선택해주세요.', 'error');
            // Optional: Redirect to home?
            // window.location.href = '/';
            return;
        }

        setupStyleListeners();

        // Load Data
        await loadProjectAndSubtitles();

        // [New] Auto Generate if empty
        if (!subtitles || subtitles.length === 0) {
            console.log("[Auto] No subtitles found. Triggering Auto-Generation...");
            Utils.showToast("자막 데이터 자동 생성 및 로딩 중...", "info");
            await generateSubtitles();
        }

        // Draggable Preview
        const previewEl = document.getElementById('previewTextMain');
        if (previewEl) makeDraggable(previewEl);
    });

    // (Deleted legacy duplicate function)

    function renderSubtitles() {
        const list = document.getElementById('subtitleList');
        if (!list) return;

        if (subtitles.length === 0) {
            list.innerHTML = `
                <div class='flex flex-col items-center justify-center h-40 text-gray-400 gap-3'>
                    <p class="text-xs">자막이 없습니다.</p>
                    <button onclick="generateSubtitles()" class="btn-primary py-1.5 px-4 text-xs">
                        ✨ AI 자막 생성 (자동)
                    </button>
                </div>`;
            return;
        }

        // 1. Calculate Image Assignments
        const assignments = new Array(subtitles.length).fill(-1);
        if (imageTimings && imageTimings.length > 0) {
            for (let i = 0; i < imageTimings.length; i++) {
                // Assign image i to subtitles starting from imageTimings[i]
                // ... logic ...
            }
        }
        // Actually, logic is usually rendering list items. 
        // Let's keep original renderSubtitles structure but since I'm replacing a chunk, I must be careful not to delete logic.
        // Wait, I am replacing lines 410-1410? No, that's too big.
        // The user tool usage says EndLine: 1410. That's huge.
        // I should break this down.
        // First, I will ADD the Utils function at the top.
        // Then I will update renderImageStrip and previewImage separately.
    }


    // (Deleted legacy duplicate function)

    function renderSubtitles() {
        const list = document.getElementById('subtitleList');
        if (!list) return;

        if (subtitles.length === 0) {
            list.innerHTML = `
                <div class='flex flex-col items-center justify-center h-40 text-gray-400 gap-3'>
                    <p class="text-xs">자막이 없습니다.</p>
                    <button onclick="generateSubtitles()" class="btn-primary py-1.5 px-4 text-xs">
                        ✨ AI 자막 생성 (자동)
                    </button>
                </div>`;
            return;
        }

        // 1. Calculate Image Assignments
        const assignments = new Array(subtitles.length).fill(-1);
        if (imageTimings && imageTimings.length > 0) {
            for (let i = 0; i < subtitles.length; i++) {
                const start = subtitles[i].start;
                let bestImgIdx = -1;
                for (let k = 0; k < imageTimings.length; k++) {
                    if (start >= imageTimings[k] - 0.05) bestImgIdx = k;
                    else break;
                }
                // [Fix] Fallback to first image if subtitle starts before any timing (e.g. 0.0s vs 0.1s)
                if (bestImgIdx === -1 && imageTimings.length > 0) bestImgIdx = 0;
                assignments[i] = bestImgIdx;
            }
        }

        // [NEW] Dynamic sizing for Left Column (Thumbnail)
        // User Request: Allow height to grow, keep natural ratio, no fixed squash.
        const isShorts = (window.currentAppMode === 'shorts');
        const colWidthClass = isShorts ? 'w-10' : 'w-28'; // Container width
        // [MODIFIED] Use h-auto to maintain aspect ratio, remove fixed height constraints
        const imgClass = isShorts ? 'w-8 h-auto' : 'w-24 h-auto shadow-sm';

        const html = subtitles.map((sub, index) => {
            const isActive = index === selectedIndex ? 'ring-2 ring-blue-500 bg-blue-50 dark:bg-gray-800' : 'hover:bg-gray-50 dark:hover:bg-gray-800';
            const imgIdx = assignments[index];
            const prevImgIdx = index > 0 ? assignments[index - 1] : -1;
            const isTransition = (imgIdx !== -1 && imgIdx !== prevImgIdx); // Image actually changes here

            // Render Image Column
            let leftCol = "";
            if (isTransition) {
                // New Image Starts Here
                const actualIndex = Math.min(imgIdx, images.length - 1);
                const rawUrl = images[actualIndex];
                const imgUrl = Utils.convertToWebPath(rawUrl); // [FIX] Convert path
                const isVideo = imgUrl.toLowerCase().endsWith('.mp4') || (imgUrl.includes('upload') && !imgUrl.endsWith('.png') && !imgUrl.endsWith('.jpg'));

                // Asset Element (Video or Image)
                let assetHtml = '';
                if (isVideo) {
                    // Video: Maintain mostly ratio but limit max height if needed? 
                    // User wants natural ratio.
                    assetHtml = `
                        <video src="${imgUrl}" class="${imgClass} rounded-sm object-contain border-2 border-purple-500 z-0 bg-black min-h-[2rem]" muted loop onmouseover="this.play()" onmouseout="this.pause();this.currentTime=0;" playsinline></video>
                        <div class="absolute top-1 right-1 bg-purple-600 text-white text-[8px] px-1 rounded shadow-md z-10 flex items-center gap-0.5">
                            <span>🎬</span>
                        </div>
                    `;
                } else {
                    assetHtml = `
                        <img src="${imgUrl}" class="${imgClass} rounded-sm object-contain border-2 border-blue-400 z-0 bg-gray-100 min-h-[2rem]" alt="Scene">
                    `;
                }

                leftCol = `
                <div class="flex flex-col items-center mr-2 ${colWidthClass} shrink-0 relative group/thumb self-start pt-1">
                    <!-- Move Up (Merge with prev) -->
                    ${index > 0 ? `<button onclick="event.stopPropagation(); moveImageStart(${imgIdx}, -1)" class="absolute -top-2 z-10 w-full h-3 bg-gray-200 hover:bg-blue-100 text-[8px] flex items-center justify-center rounded-t border border-b-0 border-gray-300 opacity-0 group-hover/thumb:opacity-100 transition-opacity" title="이전 자막부터 시작">▲</button>` : ''}
                    
                    ${assetHtml}

                    <!-- [NEW] Delete Button -->
                    <button onclick="event.stopPropagation(); deleteImageStart(${imgIdx})" class="absolute top-1 right-1 z-10 w-5 h-5 bg-red-500/80 hover:bg-red-600 text-white text-[10px] flex items-center justify-center rounded shadow-sm opacity-0 group-hover/thumb:opacity-100 transition-opacity" title="이 자막구간에서 이미지 삭제">✕</button>
                    
                    <!-- [NEW] Upload/Replace Media Button -->
                    <button onclick="event.stopPropagation(); document.getElementById('upload-media-${actualIndex}').click()" 
                            class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-20 w-8 h-8 bg-black/60 hover:bg-blue-600 text-white rounded-full flex items-center justify-center opacity-0 group-hover/thumb:opacity-100 transition-all shadow-md backdrop-blur-sm" 
                            title="소스 미디어 변경/업로드 (이미지 or 영상)">
                        📂
                    </button>
                    <input type="file" id="upload-media-${actualIndex}" class="hidden" accept="image/*,video/*,video/mp4,video/x-m4v" onchange="uploadSourceMedia(${actualIndex}, this)">
                    
                    <div class="absolute bottom-0 right-0 bg-blue-500 text-white text-[9px] px-1 rounded-tl font-bold shadow-sm opacity-80">${actualIndex + 1}</div>

                    <!-- [NEW] Effect Selector (For Motion, maybe disable? But user might want it.) -->
                    <!-- Currently user requested distinguishing icon. Keeping selector for now. -->
                    <select onchange="event.stopPropagation(); updateImageEffect(${actualIndex}, this.value)" 
                            class="mt-1 w-full text-[9px] p-0 border-gray-300 rounded bg-white dark:bg-gray-700 dark:text-white dark:border-gray-600 focus:ring-0 focus:border-blue-500 h-4 leading-none text-center"
                            title="이미지 효과 선택">
                        <option value="random" ${imageEffects[actualIndex] === 'random' ? 'selected' : ''}>Random</option>
                        <option value="zoom_in" ${imageEffects[actualIndex] === 'zoom_in' ? 'selected' : ''}>Zoom In</option>
                        <option value="zoom_out" ${imageEffects[actualIndex] === 'zoom_out' ? 'selected' : ''}>Zoom Out</option>
                        <option value="pan_left" ${imageEffects[actualIndex] === 'pan_left' ? 'selected' : ''}>Pan Left</option>
                        <option value="pan_right" ${imageEffects[actualIndex] === 'pan_right' ? 'selected' : ''}>Pan Right</option>
                        <option value="none" ${imageEffects[actualIndex] === 'none' ? 'selected' : ''}>None</option>
                    </select>

                    <!-- Move Down (Start later) -->
                    ${index < subtitles.length - 1 ? `<button onclick="event.stopPropagation(); moveImageStart(${imgIdx}, 1)" class="absolute -bottom-2 z-10 w-full h-3 bg-gray-200 hover:bg-blue-100 text-[8px] flex items-center justify-center rounded-b border border-t-0 border-gray-300 opacity-0 group-hover/thumb:opacity-100 transition-opacity" title="다음 자막부터 시작">▼</button>` : ''}
                </div>`;
            } else {
                // Continuation
                leftCol = `
                <div class="flex flex-col items-center mr-2 ${colWidthClass} shrink-0 self-stretch">
                    <div class="w-0.5 h-full bg-gray-200 dark:bg-gray-700 min-h-[2rem]"></div>
                </div>`;
            }

            return `
            <div id="sub-row-${index}" 
                 onclick="selectSubtitle(${index})"
                 draggable="true"
                 ondragstart="handleSubtitleDragStart(event, ${index})"
                 ondragover="allowDrop(event)"
                 ondrop="handleCombinedDrop(event, ${index})"
                 class="flex items-stretch p-2 mb-1 bg-white dark:bg-gray-900 rounded-lg border border-gray-100 dark:border-gray-700 cursor-pointer transition-all ${isActive} group relative overflow-visible">
                
                ${leftCol}
                
                <div class="flex items-center flex-1 min-w-0">
                    <div class="flex flex-col gap-1 mr-2 shrink-0">
                        <!-- Subtitle Time -->
                        <div class="w-12 text-[10px] text-gray-500 font-mono text-center leading-tight" id="sub-time-${index}">
                            <div class="font-bold text-gray-600 dark:text-gray-400">${sub.start.toFixed(1)}s</div>
                            <div class="text-[9px]">~${sub.end.toFixed(1)}s</div>
                        </div>
                    </div>
                    
                    <div class="flex-1 text-sm text-gray-700 dark:text-gray-300 sub-text break-words leading-snug">
                        ${sub.text}
                    </div>
                </div>
            </div>`;
        }).join('');
        list.innerHTML = html;
        renderImageStrip(); // [NEW] Sync strip with render
    }

    // [NEW] Update Image Effect
    function updateImageEffect(imgIndex, effect) {
        if (!imageEffects) imageEffects = [];

        // Ensure array size
        if (imgIndex >= imageEffects.length) {
            // Fill gaps with 'random' or 'none'
            for (let k = imageEffects.length; k <= imgIndex; k++) {
                imageEffects[k] = 'random';
            }
        }

        imageEffects[imgIndex] = effect;
        console.log(`Image #${imgIndex + 1} effect set to: ${effect}`);
        updateDebug(`[UI] Updated Img #${imgIndex + 1} -> ${effect}. Effects: ${JSON.stringify(imageEffects)}`);

        // Optional: Auto-save or visual feedback?
        // Just log for now. The Save button sends this array.
        Utils.showToast(`이미지 #${imgIndex + 1} 효과: ${effect}`, 'info');
    }

    function selectSubtitle(index) {
        if (selectedIndex >= 0) {
            const prev = document.getElementById(`sub-row-${selectedIndex}`);
            if (prev) prev.classList.remove('active');
        }

        selectedIndex = index;
        const row = document.getElementById(`sub-row-${index}`);
        if (row) {
            row.classList.add('active');
            row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        const sub = subtitles[index];
        if (!sub) return;

        // Update Editor
        const textField = document.getElementById('currentSubtitleText');
        if (textField) textField.value = sub.text;

        document.getElementById('currentStartTime').textContent = sub.start.toFixed(2);
        document.getElementById('currentEndTime').textContent = sub.end.toFixed(2);

        updateImageMatchIndicator(sub.start); // [NEW] Check Image Match
        renderImageStrip(); // [NEW] Update strip to highlight current image

        // [FIX] Update List View Timestamp
        const listTimeEl = document.getElementById(`sub-time-${index}`);
        if (listTimeEl) {
            listTimeEl.innerHTML = `${sub.start.toFixed(1)}s<br>~${sub.end.toFixed(1)}s`;
        }

        // Update Preview
        const previewText = document.getElementById('previewTextMain');
        if (previewText) previewText.textContent = sub.text;

        // Update Background Image
        // Update Background Image & Selector
        const container = document.getElementById('previewContainer');

        // Find rough image match
        if (sub.preview_url) {
            if (container) container.innerHTML = `<img src="${sub.preview_url}" style="width: 100%; height: 100%; object-fit: cover; object-position: center;" class="w-full h-full">`;
        } else if (images.length > 0) {
            const durationPerImg = audioDuration / images.length;
            // Find active image index based on time
            let imgIdx = -1;
            if (imageTimings && imageTimings.length > 0) {
                for (let i = 0; i < imageTimings.length; i++) {
                    if (sub.start >= imageTimings[i] - 0.05) imgIdx = i;
                    else break;
                }
            } else {
                // Fallback if no timings
                const mid = (sub.start + sub.end) / 2;
                imgIdx = Math.min(Math.floor(mid / durationPerImg), images.length - 1);
            }

            if (imgIdx >= 0 && imgIdx < images.length) {
                const rawUrl = images[imgIdx];
                const imgUrl = Utils.convertToWebPath(rawUrl);
                const isVideo = imgUrl.toLowerCase().endsWith('.mp4');
                const isShorts = (window.currentAppMode === 'shorts');

                if (container) {
                    if (isVideo) {
                        container.innerHTML = `
                            <video src="${imgUrl}" 
                                   style="width: 100%; height: 100%; object-fit: cover; background: black;" 
                                   class="w-full h-full" 
                                   autoplay muted loop playsinline>
                            </video>`;
                    } else if (isShorts) {
                        container.innerHTML = `
                            <div class="relative w-full h-full overflow-hidden bg-black">
                                <img src="${imgUrl}" class="absolute inset-0 w-full h-full object-cover blur-md opacity-50 scale-110">
                                <img src="${imgUrl}" class="relative z-10 w-full h-full object-contain">
                            </div>`;
                    } else {
                        container.innerHTML = `<img src="${imgUrl}" style="width: 100%; height: 100%; object-fit: cover; object-position: center;" class="w-full h-full">`;
                    }
                }
            }
        }
    }

    function applySettings(s) {
        if (s.subtitle_font) {
            const el = document.getElementById('fontFamilySelect');
            if (el) el.value = s.subtitle_font;
        }
        if (s.subtitle_font_size) {
            const el = document.getElementById('fontSizeSlider');
            const valueEl = document.getElementById('fontSizeValue');
            if (el) {
                const percent = parseFloat(s.subtitle_font_size);
                // Legacy support: >15 means pixels, convert to %
                const finalPercent = percent > 15 ? 5.0 : percent;
                el.value = finalPercent;
                if (valueEl) valueEl.textContent = finalPercent.toFixed(1) + '%';
                styleSettings.font_size = finalPercent;
            }
        }
        if (s.subtitle_base_color) {
            const el = document.getElementById('textColorInput');
            if (el) el.value = s.subtitle_base_color;
        }
        if (s.subtitle_stroke_color) {
            const el = document.getElementById('strokeColorInput');
            if (el) el.value = s.subtitle_stroke_color;
        }
        if (s.subtitle_stroke_width !== undefined) {
            const el = document.getElementById('strokeWidthSlider');
            if (el) {
                el.value = s.subtitle_stroke_width;
                document.getElementById('strokeWidthValue').textContent = s.subtitle_stroke_width;
            }
        }
        // [NEW] Aspect Ratio
        if (s.aspect_ratio) {
            setAspectRatio(s.aspect_ratio);
        }

        const preview = document.getElementById('previewTextMain');
        if (preview) {
            if (s.subtitle_pos_x) preview.style.left = s.subtitle_pos_x;
            if (s.subtitle_pos_y) preview.style.top = s.subtitle_pos_y;
        }

        updateSubtitlePreview();
    }

    // [NEW] Update Image Match Indicator
    function updateImageMatchIndicator(startTime) {
        const el = document.getElementById('currentImageIndicator');
        const timeEl = document.getElementById('currentImageTime'); // [NEW]

        if (!el || !imageTimings || imageTimings.length === 0) {
            if (el) el.textContent = "?뼹截영상대?吏: 留ㅼ묶 정보 없음";
            if (timeEl) timeEl.textContent = "-";
            return;
        }

        // Find which image is active at startTime
        let imgIndex = -1;
        for (let i = 0; i < imageTimings.length; i++) {
            if (startTime >= imageTimings[i] - 0.05) { // tolerance
                imgIndex = i;
            } else {
                break;
            }
        }

        // Ensure index is within images array bounds
        if (imgIndex !== -1 && images.length > 0) {
            const actualIndex = Math.min(imgIndex, images.length - 1);
            el.textContent = `현재 이미지 #${actualIndex + 1}`;

            // [NEW] Update Time Display
            if (timeEl) timeEl.textContent = `${imageTimings[imgIndex].toFixed(1)}s`;

            // [NEW] Update End Time Display & Buttons
            const endTimeEl = document.getElementById('currentImageEndTime');
            const btnMinus = document.getElementById('btnImgEndMinus');
            const btnPlus = document.getElementById('btnImgEndPlus');

            let endTime = audioDuration;
            let isLast = false;
            // Check if there is a next image timing
            if (actualIndex < imageTimings.length - 1) {
                endTime = imageTimings[actualIndex + 1];
            } else {
                isLast = true;
            }

            if (endTimeEl) endTimeEl.textContent = `${endTime.toFixed(1)}s`;

            if (btnMinus) btnMinus.disabled = isLast;
            if (btnPlus) btnPlus.disabled = isLast;
            if (isLast) {
                if (btnMinus) btnMinus.classList.add('opacity-50', 'cursor-not-allowed');
                if (btnPlus) btnPlus.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                if (btnMinus) btnMinus.classList.remove('opacity-50', 'cursor-not-allowed');
                if (btnPlus) btnPlus.classList.remove('opacity-50', 'cursor-not-allowed');
            }

            // Optional: Update Preview Image
            // We show the CURRENT image in preview usually.
            // ... (existing preview update logic if any)
            const previewBg = document.getElementById('previewContainer');
            if (actualIndex >= 0 && actualIndex < images.length) {
                const rawUrl = images[actualIndex];
                const imgUrl = Utils.convertToWebPath(rawUrl);
                const isVideo = imgUrl.toLowerCase().includes('.mp4'); // [FIX] Robust check
                const isShorts = (window.currentAppMode === 'shorts');

                if (isVideo) {
                    // Video Preview
                    previewBg.innerHTML = `
                        <video src="${imgUrl}" 
                               style="width: 100%; height: 100%; object-fit: cover; background: black;" 
                               class="w-full h-full" 
                               autoplay muted loop playsinline>
                        </video>`;
                } else if (isShorts) {
                    // Simulate "Cinematic Frame" for Images: Blurred Background + Centered Image (Fit)
                    previewBg.innerHTML = `
                        <div class="relative w-full h-full overflow-hidden bg-black">
                            <!-- Blurry Background -->
                            <img src="${imgUrl}" 
                                 class="absolute inset-0 w-full h-full object-cover blur-md opacity-50 scale-110">
                            <!-- Main Image (Fit) -->
                            <img src="${imgUrl}" 
                                 class="relative z-10 w-full h-full object-contain">
                        </div>
                    `;
                } else {
                    // Normal Longform Image (Fill)
                    previewBg.innerHTML = `<img src="${imgUrl}" style="width: 100%; height: 100%; object-fit: cover; object-position: center;" class="w-full h-full">`;
                }
            }

        } else {
            if (el) el.textContent = "현재영상이미지: 매칭 정보 없음";
            if (timeEl) timeEl.textContent = "-";
            const endTimeEl = document.getElementById('currentImageEndTime');
            if (endTimeEl) endTimeEl.textContent = "-";
        }
    }

    // [NEW] Adjust Image End Time (Next Image Start)
    function adjustImageEndTime(seconds) {
        if (!imageTimings || imageTimings.length === 0) return;

        // Find current image index from subtitle start time
        // Note: 'currentStartTime' logic might be slightly off if user clicked a subtitle mid-image, 
        // but generally correct for "active subtitle".
        const startTime = parseFloat(document.getElementById('currentStartTime').textContent);

        let imgIndex = -1;
        for (let i = 0; i < imageTimings.length; i++) {
            if (startTime >= imageTimings[i] - 0.05) imgIndex = i;
            else break;
        }

        if (imgIndex === -1) return;

        // Target is the NEXT image's start time
        // If imgIndex is last, we cannot adjust end time (it's fixed to audio end).
        const targetIndex = imgIndex + 1;

        if (targetIndex >= imageTimings.length) {
            Utils.showToast("마지막 이미지는 종료 시간을 오디오 길이로 고정합니다.", "warning");
            return;
        }

        // Use existing logic to change timing
        const currentEnd = imageTimings[targetIndex]; // Current "End Time" (Next Start)
        const newTime = Math.max(0, Math.min(audioDuration, currentEnd + seconds));

        // Simple clamp against previous start (current image start) and next-next start
        const prevStart = imageTimings[imgIndex];
        const nextStart = (targetIndex + 1 < imageTimings.length) ? imageTimings[targetIndex + 1] : audioDuration;

        if (newTime <= prevStart) {
            Utils.showToast("시작 시간보다 앞설 수 없습니다.", "warning");
            return;
        }
        if (newTime >= nextStart) {
            Utils.showToast("다음 이미지 시간과 겹칠 수 없습니다.", "warning");
            return;
        }

        imageTimings[targetIndex] = newTime;

        saveSubtitles();
        renderSubtitles();

        // Refresh Indicator
        updateImageMatchIndicator(startTime);
    }



    // [NEW] Aspect Ratio Logic
    function setAspectRatio(ratio) {
        const box = document.getElementById('mainPreviewBox');
        if (box) {
            // Apply Aspect Ratio
            box.style.aspectRatio = ratio.replace(':', '/');

            // Adjust Width for Mobile vs Desktop feel
            if (ratio === '9:16') {
                box.classList.remove('max-w-2xl');
                box.classList.add('max-w-[300px]'); // Phone width (reduced)
            } else {
                box.classList.remove('max-w-[300px]');
                box.classList.add('max-w-2xl'); // Desktop width (reduced)
            }
        }

        // Update toggle button state if exists
        const btn = document.getElementById('ratioToggleBtn');
        if (btn) {
            btn.textContent = ratio === '9:16' ? '세로 9:16' : '가로 16:9';
        }
    }

    async function toggleAspectRatio() {
        const box = document.getElementById('mainPreviewBox');
        let current = box.style.aspectRatio;
        // normalize
        if (current.includes('16 / 9') || current.includes('1.77')) current = '16:9';
        else current = '9:16';

        const newRatio = current === '16:9' ? '9:16' : '16:9';
        setAspectRatio(newRatio);
        await API.project.updateSetting(projectId, 'aspect_ratio', newRatio);
    }

    function updateSubtitlePreview() {
        const text = document.getElementById('previewTextMain');
        if (!text) return;

        const fontEl = document.getElementById('fontFamilySelect');
        const sizeEl = document.getElementById('fontSizeSlider');
        const colorEl = document.getElementById('textColorInput');
        const strokeColorEl = document.getElementById('strokeColorInput');
        const strokeWidthEl = document.getElementById('strokeWidthInput');

        if (!fontEl || !sizeEl || !colorEl || !strokeColorEl || !strokeWidthEl) {
            console.warn('One or more preview controls missing from DOM');
            return;
        }

        const font = fontEl.value;
        const fontSizePercent = parseFloat(sizeEl.value || 5.4);
        const color = colorEl.value;
        const strokeColor = strokeColorEl.value;
        const strokeWidth = parseFloat(strokeWidthEl.value || 0);

        const previewBox = document.getElementById('mainPreviewBox');
        const previewContainer = document.getElementById('previewContainer');
        if (!previewBox || !previewContainer) return;

        const aspectRatio = styleSettings.aspect_ratio || '9:16';
        const [w, h] = aspectRatio.split(':').map(Number);
        const imageWidth = previewContainer.clientWidth;
        const videoHeight = (imageWidth * h) / w;

        const previewHeight = previewBox.clientHeight;
        const scaleFactor = previewHeight / videoHeight;

        const actualSize = Math.round(videoHeight * (fontSizePercent / 100) * scaleFactor * 1.7);
        const containerWidth = Math.round(imageWidth * 0.98);

        text.style.color = color;
        text.style.fontSize = `${actualSize}px`;
        text.style.fontFamily = font;

        // [FIX] Gungsuh font breaks stroke when 'bold' is applied (Synthetic Bold issue)
        if (font.includes('Gungsuh') || font.includes('궁서')) {
            text.style.fontWeight = 'normal';
        } else {
            text.style.fontWeight = 'bold';
        }

        // Stroke (Robust Text-Shadow Method)
        // [FIX] 'Gungsuh' font with 'Bold' often breaks SVG/Webkit strokes due to faux-bold rendering.
        // We use multi-layered text-shadow to simulate stroke perfectly.

        if (strokeWidth > 0) {
            const shadows = [];
            const steps = 24; // 15 degree steps
            const layers = Math.min(Math.ceil(strokeWidth * scaleFactor), 10); // Cap layers for perf

            for (let r = 1; r <= layers; r++) {
                for (let i = 0; i < steps; i++) {
                    const angle = (i * (360 / steps)) * (Math.PI / 180);
                    const x = (r * Math.cos(angle)).toFixed(1);
                    const y = (r * Math.sin(angle)).toFixed(1);
                    shadows.push(`${x}px ${y}px 0 ${strokeColor}`);
                }
            }

            text.style.textShadow = shadows.join(',');
            text.style.webkitTextStroke = '0';
            text.style.filter = 'none';
        } else {
            text.style.textShadow = 'none';
            text.style.webkitTextStroke = '0';
            text.style.filter = 'none';
        }
        text.style.webkitTextFillColor = color;

        text.style.width = containerWidth + 'px';
        text.style.maxWidth = containerWidth + 'px';
        text.style.wordWrap = 'break-word';
        text.style.whiteSpace = 'pre-wrap';
        text.style.textAlign = 'center';
        text.style.boxSizing = 'border-box';

        // [Cleaned up] No extra textShadow clearing here

        // Background Strip
        const bgToggle = document.getElementById('bgStripToggle');
        const bgColorEl = document.getElementById('bgColorInput');
        const bgOpacityEl = document.getElementById('bgOpacityInput');

        if (bgToggle && bgColorEl && bgOpacityEl) {
            if (bgToggle.checked) {
                const bgColor = bgColorEl.value;
                const bgOpacity = parseFloat(bgOpacityEl.value || 0.5);
                const r = parseInt(bgColor.slice(1, 3), 16);
                const g = parseInt(bgColor.slice(3, 5), 16);
                const b = parseInt(bgColor.slice(5, 7), 16);
                text.style.backgroundColor = `rgba(${r},${g},${b},${bgOpacity})`;
                text.style.padding = '10px 0';
            } else {
                text.style.backgroundColor = 'transparent';
                text.style.padding = '0';
            }
        }

        // Line Spacing
        const spacingEl = document.getElementById('lineSpacingInput');
        if (spacingEl) {
            const lineSpacing = parseFloat(spacingEl.value || 0.1);
            text.style.lineHeight = (1 + lineSpacing).toString();
        }
    }

    function setupStyleListeners() {
        // Debounced or direct auto-save logic
        const update = async (key, val) => {
            styleSettings[key] = val;
            updateSubtitlePreview();
            await API.project.updateSetting(projectId, key, val);
        };

        const fontEl = document.getElementById('fontFamilySelect');
        if (fontEl) fontEl.addEventListener('change', e => update('subtitle_font', e.target.value));

        const sizeSlider = document.getElementById('fontSizeSlider');
        if (sizeSlider) {
            sizeSlider.addEventListener('input', e => {
                const percent = parseFloat(e.target.value);
                document.getElementById('fontSizeValue').textContent = percent.toFixed(1) + '%';
                updateSubtitlePreview();
            });
            sizeSlider.addEventListener('change', e => {
                update('subtitle_font_size', parseFloat(e.target.value));
            });
        }

        const colorEl = document.getElementById('textColorInput');
        if (colorEl) colorEl.addEventListener('change', e => update('subtitle_base_color', e.target.value));

        const strokeWidthInput = document.getElementById('strokeWidthInput');
        if (strokeWidthInput) {
            strokeWidthInput.addEventListener('input', e => updateSubtitlePreview());
            strokeWidthInput.addEventListener('change', e => update('subtitle_stroke_width', parseFloat(e.target.value || 0)));
        }

        const lineSpacingInput = document.getElementById('lineSpacingInput');
        if (lineSpacingInput) {
            lineSpacingInput.addEventListener('input', e => updateSubtitlePreview());
            lineSpacingInput.addEventListener('change', e => update('subtitle_line_spacing', parseFloat(e.target.value || 0.1)));
        }

        const bgColorInput = document.getElementById('bgColorInput');
        if (bgColorInput) bgColorInput.addEventListener('change', e => update('subtitle_bg_color', e.target.value));

        const bgOpacityInput = document.getElementById('bgOpacityInput');
        if (bgOpacityInput) {
            bgOpacityInput.addEventListener('input', e => updateSubtitlePreview());
            bgOpacityInput.addEventListener('change', e => update('subtitle_bg_opacity', parseFloat(e.target.value || 0.5)));
        }

        // Text Input Listener
        const textInput = document.getElementById('currentSubtitleText');
        if (textInput) {
            textInput.addEventListener('input', (e) => {
                if (selectedIndex >= 0 && subtitles[selectedIndex]) {
                    subtitles[selectedIndex].text = e.target.value;
                    const preview = document.getElementById('previewTextMain');
                    if (preview) preview.textContent = e.target.value;
                    // Update List Item text too
                    const row = document.getElementById(`sub-row-${selectedIndex}`);
                    if (row) row.querySelector('.sub-text').textContent = e.target.value;
                }
            });
        }
    }

    // [NEW] Save Style Settings Bulk
    async function saveStyleSettings(btn) {
        if (!projectId) {
            alert("❌ 프로젝트 ID가 확인되지 않아 설정을 저장할 수 없습니다.\n페이지를 새로고침하거나 메인 화면에서 프로젝트를 다시 선택해주세요.");
            console.error("saveStyleSettings failed: projectId is null/undefined");
            return;
        }

        const originalText = btn ? btn.innerHTML : "세팅저장";
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = `<span>🔄</span> 저장중...`;
        }

        try {
            const font = document.getElementById('fontFamilySelect').value;
            const fontSize = parseFloat(document.getElementById('fontSizeSlider').value);
            const color = document.getElementById('textColorInput').value;
            const strokeColor = document.getElementById('strokeColorInput').value;
            const strokeWidth = parseFloat(document.getElementById('strokeWidthInput').value || 0);
            const lineSpacing = parseFloat(document.getElementById('lineSpacingInput').value || 0.1);
            const bgEnabled = document.getElementById('bgStripToggle').checked ? 1 : 0;
            const bgColor = document.getElementById('bgColorInput').value;
            const bgOpacity = parseFloat(document.getElementById('bgOpacityInput').value || 0.5);

            // Get current positions
            const preview = document.getElementById('previewTextMain');
            const posX = preview ? preview.style.left : '50%';
            const posY = preview ? preview.style.top : '75%';
            const ratio = (document.getElementById('ratioToggleBtn').textContent.includes('9:16')) ? '9:16' : '16:9';

            const settings = {
                subtitle_font: font,
                subtitle_font_size: fontSize,
                subtitle_base_color: color,
                subtitle_stroke_color: strokeColor,
                subtitle_stroke_width: strokeWidth,
                subtitle_line_spacing: lineSpacing,
                subtitle_bg_enabled: bgEnabled,
                subtitle_bg_color: bgColor,
                subtitle_bg_opacity: bgOpacity,
                subtitle_pos_x: posX,
                subtitle_pos_y: posY,
                aspect_ratio: ratio
            };

            const result = await API.project.saveSettings(projectId, settings);
            if (result.status === 'ok') {
                Utils.showToast("스타일 설정이 영구 저장되었습니다.", "success");
            } else {
                throw new Error(result.error || "Unknown Error");
            }
        } catch (e) {
            console.error(e);
            Utils.showToast("설정 저장 실패: " + e.message, "error");
        } finally {
            if (btn) {
                btn.disabled = false;
                btn.innerHTML = originalText;
            }
        }
    }

    // --- Action Functions ---
    async function saveSubtitles(isAutoSave = false) {
        const btn = document.getElementById('saveBtn');
        if (!isAutoSave) Utils.setLoading(btn, true, '저장..');
        try {
            // Update Position before save
            const preview = document.getElementById('previewTextMain');
            if (preview) {
                await API.project.updateSetting(projectId, 'subtitle_pos_x', preview.style.left);
                await API.project.updateSetting(projectId, 'subtitle_pos_y', preview.style.top);
            }

            // [Fix] Force save font size to ensure consistency and update timestamp
            const sizeSlider = document.getElementById('fontSizeSlider');
            if (sizeSlider) {
                await API.project.updateSetting(projectId, 'subtitle_font_size', parseFloat(sizeSlider.value));
            }

            const res = await fetch('/api/subtitle/save', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    project_id: projectId,
                    subtitles: subtitles,
                    image_timings: imageTimings,
                    images: images,
                    image_effects: imageEffects
                })
            });
            console.log("[Save] Sending Image Effects:", imageEffects);
            // alert(`[DEBUG] Saving Effects: ${JSON.stringify(imageEffects)}`); // Explicit User Feedback
            updateDebug(`[Save] Effects Sent: ${JSON.stringify(imageEffects)}`);
            const data = await res.json();
            if (data.status === 'ok') {
                if (!isAutoSave) Utils.showToast("자막 및 이미지 저장 완료", "success");
                if (window.updateStepStatus) window.updateStepStatus('subtitle', true);

                if (data.subtitles) {
                    subtitles = data.subtitles;
                    renderSubtitles();
                    if (selectedIndex >= 0) selectSubtitle(selectedIndex);
                }
            } else throw new Error(data.error);
        } catch (e) {
            if (!isAutoSave) Utils.showToast('저장 실패: ' + e.message, 'error');
            else console.error("AutoSave Failed:", e);
        } finally {
            if (!isAutoSave) Utils.setLoading(btn, false);
        }
    }

    async function generateSubtitles() {
        Utils.showToast('자막 생성 요청...', 'info');
        try {
            const res = await fetch('/api/subtitle/generate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ project_id: projectId })
            });
            const data = await res.json();
            if (data.status === 'ok') {
                subtitles = data.subtitles;
                images = data.images || images; // Update images if provided
                imageTimings = data.image_timings || []; // Update timings
                renderSubtitles();
                selectSubtitle(0);
                Utils.showToast('생성 완료', 'success');
            } else throw new Error(data.error);
        } catch (e) {
            Utils.showToast('오류: ' + e.message, 'error');
        }
    }

    async function regenerateSubtitles() {
        if (!confirm('모든 자막을 다시 분석합니다. 수동 편집이 사라집니다.')) return;
        Utils.showToast('재분석 중..', 'info');
        try {
            const res = await fetch(`/api/project/${projectId}/subtitle/regenerate`, { method: 'POST' });
            const data = await res.json();
            if (data.status === 'ok') {
                subtitles = data.subtitles;
                images = data.images || images;
                imageTimings = data.image_timings || [];
                renderSubtitles();
                selectSubtitle(0);
                Utils.showToast('재분석 완료', 'success');
            } else throw new Error(data.error);
        } catch (e) { Utils.showToast('실패: ' + e.message, 'error'); }
    }







    Utils.showToast('자막-이미지 싱크가 로드되었습니다.', 'success');

    // [NEW] Adjust Time -> Sync Images -> Save
    async function saveAndSync() {
        if (!subtitles || subtitles.length === 0) return;

        // 1. Save to backend (No auto-distribute)
        await saveSubtitles();

        // 3. Feedback handled by saveSubtitles
    }

    function applyPreset(name) {
        if (name === 'basic_white') {
            document.getElementById('textColorInput').value = '#ffffff';
            document.getElementById('strokeColorInput').value = '#000000';
            updateSubtitlePreview();
        } else if (name === 'basic_black') {
            document.getElementById('textColorInput').value = '#000000';
            document.getElementById('strokeColorInput').value = '#ffffff';
            updateSubtitlePreview();
        } else if (name === 'yellow_shadow') {
            document.getElementById('textColorInput').value = '#fbbf24'; // Yellow
            document.getElementById('strokeColorInput').value = '#000000';
            updateSubtitlePreview();
        }
        document.getElementById('textColorInput').dispatchEvent(new Event('change'));
        document.getElementById('strokeColorInput').dispatchEvent(new Event('change'));
    }

    function addSubtitleRow() {
        const last = subtitles[subtitles.length - 1];
        const start = last ? last.end : 0;
        subtitles.push({ start: start, end: start + 2, text: "영상자막" });
        renderSubtitles();
        selectSubtitle(subtitles.length - 1);
    }

    function adjustTime(delta) {
        if (selectedIndex < 0 || !subtitles[selectedIndex]) return;

        console.log('Adjusting time', delta, subtitles[selectedIndex]);

        let newStart = subtitles[selectedIndex].start + delta;
        let newEnd = subtitles[selectedIndex].end + delta;

        if (newStart < 0) {
            newEnd = newEnd - newStart; // Shift end if start hits 0? Or just clamp?
            newStart = 0;
            // Actually just clamp start, let duration change? Or keep duration?
            // User probably wants shift.
            // If start < 0, shift back.
        }

        subtitles[selectedIndex].start = parseFloat(newStart.toFixed(2));
        subtitles[selectedIndex].end = parseFloat(newEnd.toFixed(2));

        // Force full re-render to ensure list is updated (inefficient but safe)
        // Actually, just updating the DOM element for time is better UX (no flicker).
        // I verified the ID exists. Let's stick to updateElement but make sure it works.
        // Maybe the ID search is failing?

        // Update List UI to reflect new time (thumbnails/time text)
        renderSubtitles();

        // Re-call selectSubtitle to update specific UI parts
        selectSubtitle(selectedIndex);
    }

    // [NEW] Upload Source Media (Directly from Subtitle Page)
    async function uploadSourceMedia(imageIndex, input) {
        if (!input.files || input.files.length === 0) return;

        const file = input.files[0];
        if (!projectId) {
            Utils.showToast('프로젝트 정보를 찾을 수 없습니다.', 'error');
            return;
        }

        const formData = new FormData();
        formData.append('file', file);
        formData.append('project_id', projectId);
        formData.append('scene_index', imageIndex + 1); // 1-based index for backend

        try {
            Utils.showToast('미디어 업로드 중...', 'info');

            const response = await fetch('/api/image/upload-scene', {
                method: 'POST',
                body: formData
            });

            const result = await response.json();

            if (result.status === 'ok') {
                // Update local image state
                if (result.video_url) {
                    images[imageIndex] = result.video_url;
                    Utils.showToast('영상 업로드 완료!', 'success');
                } else {
                    images[imageIndex] = result.image_url || result.url || result.path; // Fallback
                    Utils.showToast('이미지 업로드 완료!', 'success');
                }

                // Force Re-render to show new media
                renderSubtitles();

                // If currently selected row uses this image, refresh preview
                if (selectedIndex >= 0) {
                    const sub = subtitles[selectedIndex];
                    // Check assignment
                    // (Simple way: just re-select current)
                    selectSubtitle(selectedIndex);
                }

                // IMPORTANT: Trigger Save to persist this change in Project JSON if needed?
                // Actually `upload-scene` API updates DB `image_prompts`.
                // But `images` array in `main.py` -> `project_data` might need refresh or it is loaded from DB?
                // When we `saveSubtitles`, we send `subtitles`. We don't send `images`.
                // Typically we reload `images` from DB on load. 
                // To be safe, we might want to reload project data or ensure `images` is accurate.
                // Since we updated `images[imageIndex]`, and usually `images` are derived from DB rows.
                // Let's assume frontend update is enough for now, as DB is already updated by the upload API.

            } else {
                throw new Error(result.error || 'Server Error');
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('업로드 실패: ' + e.message, 'error');
        } finally {
            // Reset input so same file can be selected again
            input.value = '';
        }
    }

    // [NEW] Adjust Image Time separately
    function adjustImageTime(delta) {
        if (selectedIndex < 0) return;
        const sub = subtitles[selectedIndex];

        // Find which image segment corresponds to this subtitle
        // We look for image index 'i' where imageTimings[i] <= sub.start
        let imgIdx = -1;
        if (!imageTimings || imageTimings.length === 0) imageTimings = [0.0];

        for (let i = 0; i < imageTimings.length; i++) {
            if (sub.start >= imageTimings[i] - 0.05) { // tolerance
                imgIdx = i;
            } else {
                break;
            }
        }

        if (imgIdx !== -1) {
            let newT = imageTimings[imgIdx] + delta;
            if (newT < 0) newT = 0;
            // Ensure it doesn't cross previous image? Maybe not strictly required but safer.
            if (imgIdx > 0 && newT <= imageTimings[imgIdx - 1]) newT = imageTimings[imgIdx - 1] + 0.1;

            imageTimings[imgIdx] = parseFloat(newT.toFixed(2));

            // Update UI
            renderSubtitles();
            selectSubtitle(selectedIndex); // Refresh right panel display
        }
    }

    // [NEW] Update Image Effect
    function updateImageEffect(index, value) {
        if (!imageEffects) imageEffects = [];
        // Ensure array size
        if (index >= imageEffects.length) {
            // Fill gaps
            while (imageEffects.length <= index) imageEffects.push('random');
        }
        imageEffects[index] = value;
        // Auto-save logic? Or just wait for manual save. 
        // User might expect auto-save or explicit save.
        // Let's rely on global Save button or enable auto save if consistent with other UI.
        // Current UI has explicit Save button for subtitles.
    }

    // [NEW] Delete Image Timing
    function deleteImageStart(imgIdx) {
        if (imgIdx < 0 || imgIdx >= imageTimings.length) return;

        // Optionally prevent deleting the very first image at 0.0
        // if (imgIdx === 0 && imageTimings[imgIdx] === 0) return Utils.showToast("첫 번째 이미지는 삭제할 수 없습니다.", "warning");

        if (!confirm("이 자막구간에서 썸네일을 삭제하시겠습니까? (이전 이미지가 계속 표시됩니다)")) return;

        // Remove from parallel arrays
        imageTimings.splice(imgIdx, 1);
        images.splice(imgIdx, 1);
        if (imageEffects && imageEffects.length > imgIdx) {
            imageEffects.splice(imgIdx, 1);
        }

        renderImageStrip();
        saveSubtitles();
        Utils.showToast("이미지가 삭제되었습니다.", "success");
    }

    // [NEW] Separate Image Strip Renderer (Global)
    // [NEW] Separate Image Strip Renderer (Global) -> Renders SOURCE PALETTE (Fixed)
    function renderImageStrip() {
        const stripFn = document.getElementById('imageThumbnailStrip');
        if (!stripFn) return;

        // Use sourceImages (Palette) instead of images (Timeline)
        if (!sourceImages || sourceImages.length === 0) {
            stripFn.innerHTML = '<div class="text-[9px] text-gray-400 text-center p-2">이미지 없음</div>';
            return;
        }

        const html = sourceImages.map((imgUrl, idx) => {
            const webPath = Utils.convertToWebPath(imgUrl);
            const isVideo = webPath.toLowerCase().includes('.mp4');

            // Check if this Source Image is currently active in the timeline
            // We need to check if the current playing time falls into a timeline segment that uses THIS source image.
            // 1. Find which timeline-image is active
            let activeTimelineImgIdx = -1;
            if (subtitleList && subtitles.length > 0) {
                // But easier: We know 'selectedIndex' is the active subtitle.
                // Which image does selectedIndex use?
                const sub = subtitles[selectedIndex];
                if (sub && imageTimings) {
                    // Find active timeline segment
                    for (let k = 0; k < imageTimings.length; k++) {
                        if (sub.start >= imageTimings[k] - 0.05) activeTimelineImgIdx = k;
                        else break;
                    }
                }
            }

            // 2. Does the active timeline segment use this source image?
            let isActive = false;
            // imageTimings aligns with 'images' array.
            if (activeTimelineImgIdx >= 0 && activeTimelineImgIdx < images.length) {
                // Compare URLs (robustly)
                // We compare the raw URL or basename?
                // images[activeTimelineImgIdx] vs imgUrl
                const tImg = images[activeTimelineImgIdx];
                // Simple string check or basename check
                if (tImg === imgUrl || Utils.convertToWebPath(tImg) === webPath) {
                    isActive = true;
                }
            }

            const activeClass = isActive ? 'ring-2 ring-blue-500 opacity-100 scale-[1.02]' : 'opacity-70 hover:opacity-100';

            return `
            <div 
                 draggable="true"
                 ondragstart="handleDragStart(event, ${idx})"
                 class="relative w-full cursor-pointer transition-all duration-200 group mb-2 shrink-0 ${activeClass}"
                 style="flex-shrink: 0;"
                 title="소스 이미지 #${idx + 1} (드래그하여 자막에 적용 가능)">
                ${isVideo ?
                    `<video src="${webPath}" class="w-full h-auto min-h-[40px] rounded bg-black border border-gray-600 object-contain" muted loop onmouseover="this.play()" onmouseout="this.pause()"></video>` :
                    `<img src="${webPath}" class="w-full h-auto min-h-[40px] rounded bg-black border border-gray-600 object-contain" loading="lazy">`
                }
                <div class="absolute top-0.5 left-0.5 bg-black/60 text-white text-[8px] px-1 rounded backdrop-blur-sm z-10">
                    ${idx + 1}
                </div>
            </div>`;
        }).join('');

        stripFn.innerHTML = html;
    }

    // [NEW] Move Image Boundary (Start Time)
    function moveImageStart(imgIdx, direction) {
        // imgIdx: Index in imageTimings array
        // direction: -1 (move earlier, Up), 1 (move later, Down)

        if (imgIdx < 0 || imgIdx >= imageTimings.length) return;

        // Find current start time
        const currentT = imageTimings[imgIdx];

        // Find which subtitle corresponds to this time
        let subIdx = -1;
        for (let i = 0; i < subtitles.length; i++) {
            // Basic tolerance matching
            if (Math.abs(subtitles[i].start - currentT) < 0.1) {
                subIdx = i;
                break;
            }
        }

        // Fallback or explicit check if failed
        if (subIdx === -1) {
            let minDiff = 999;
            for (let i = 0; i < subtitles.length; i++) {
                const diff = Math.abs(subtitles[i].start - currentT);
                if (diff < minDiff) {
                    minDiff = diff;
                    subIdx = i;
                }
            }
        }

        const targetSubIdx = subIdx + direction;

        if (targetSubIdx >= 0 && targetSubIdx < subtitles.length) {

            const newStart = subtitles[targetSubIdx].start;

            // Validate: Must be > previous image start, < next image start
            if (imgIdx > 0 && newStart <= imageTimings[imgIdx - 1]) {
                return Utils.showToast("다음 이미지보다 늦을 수 없습니다.", 'warning');
            }
            if (imgIdx < imageTimings.length - 1 && newStart >= imageTimings[imgIdx + 1]) {
                return Utils.showToast("다음 이미지보다 앞설 수 없습니다.", 'warning');
            }

            // Update time
            imageTimings[imgIdx] = newStart;

            // Update UI
            renderSubtitles();

            // [NEW] Persist Change
            saveSubtitles();
        }
    }


    function playSegment(idx) {
        const sub = subtitles[idx];
        const audio = document.getElementById('audioPlayer');
        audio.currentTime = sub.start;
        audio.play();
        setTimeout(() => audio.pause(), (sub.end - sub.start) * 1000);
    }

    // Draggable Functionality
    function makeDraggable(elmnt) {
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        elmnt.onmousedown = dragMouseDown;

        function dragMouseDown(e) {
            e = e || window.event;
            e.preventDefault();
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            document.onmousemove = elementDrag;
        }

        function elementDrag(e) {
            e = e || window.event;
            e.preventDefault();
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
            elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
        }

        function closeDragElement() {
            document.onmouseup = null;
            document.onmousemove = null;
            if (projectId) {
                API.project.updateSetting(projectId, 'subtitle_pos_x', elmnt.style.left);
                API.project.updateSetting(projectId, 'subtitle_pos_y', elmnt.style.top);
            }
        }
    }



    function previewImage(idx) {
        if (idx < 0 || idx >= sourceImages.length) return;
        const rawUrl = sourceImages[idx];
        const url = Utils.convertToWebPath(rawUrl);
        const container = document.getElementById('previewContainer');

        if (container) {
            const isVideo = url.toLowerCase().includes('.mp4');
            if (isVideo) {
                container.innerHTML = `
                    <video src="${url}" 
                           style="width: 100%; height: 100%; object-fit: cover; background: black;" 
                           class="w-full h-full" 
                           autoplay muted loop playsinline>
                    </video>`;
            } else {
                container.innerHTML = `<img src="${url}" style="width: 100%; height: 100%; object-fit: cover; object-position: center;" class="w-full h-full">`;
            }
        }
        Utils.showToast(`이미지 #${idx + 1} 미리보기`, 'info');
    }

    // [NEW] Drag & Drop Logic
    function handleDragStart(ev, idx) {
        // Dragging from Palette (Source Images)
        ev.dataTransfer.setData("text/plain", idx);
        ev.dataTransfer.setData("type", "palette_image"); // Explicit Type
        ev.dataTransfer.effectAllowed = "copy"; // Palette items are COPIED, not MOVED
    }



    function handleSubtitleDragStart(ev, index) {
        ev.dataTransfer.effectAllowed = "move";
        ev.dataTransfer.setData("type", "subtitle");
        ev.dataTransfer.setData("index", index);
        // Optional: Set drag image
    }

    function handleCombinedDrop(ev, targetIndex) {
        ev.preventDefault();

        const type = ev.dataTransfer.getData("type");

        // CASE 1: Subtitle Reordering (Move)
        if (type === "subtitle") {
            const sourceIndexStr = ev.dataTransfer.getData("index");
            if (sourceIndexStr === "" || isNaN(sourceIndexStr)) return;
            const sourceIndex = parseInt(sourceIndexStr);

            if (sourceIndex === targetIndex) return;

            // Reorder Array
            const [movedItem] = subtitles.splice(sourceIndex, 1);
            subtitles.splice(targetIndex, 0, movedItem);

            saveSubtitles();
            renderSubtitles();
            Utils.showToast("자막 순서가 변경되었습니다.", "success");
            return;
        }

        // CASE 2: Image Assignment from Palette (Copy)
        if (type === "palette_image") {
            const srcIdx = ev.dataTransfer.getData("text/plain");
            if (srcIdx === "" || isNaN(srcIdx)) return;

            const imageIndex = parseInt(srcIdx);
            // Validate against sourceImages (Palette)
            if (imageIndex < 0 || imageIndex >= sourceImages.length) return;

            // Logic: Apply Image #imageIndex to start at Subtitle #subIdx
            if (targetIndex < 0 || targetIndex >= subtitles.length) return;

            const targetTime = subtitles[targetIndex].start;
            const targetUrl = sourceImages[imageIndex]; // Get from Palette (Copy Source)

            if (!imageTimings) imageTimings = [];

            // Insert/Overwrite Logic for Timeline (Thumbnail 2)
            let insertPos = 0;
            while (insertPos < imageTimings.length && imageTimings[insertPos] < targetTime) {
                insertPos++;
            }

            // Prevent duplicate time exact match (overwrite instead)
            // This modifies 'images' (Timeline), NOT 'sourceImages' (Palette)
            if (insertPos < imageTimings.length && Math.abs(imageTimings[insertPos] - targetTime) < 0.1) {
                images[insertPos] = targetUrl;
                imageTimings[insertPos] = targetTime;
            } else {
                imageTimings.splice(insertPos, 0, targetTime);
                images.splice(insertPos, 0, targetUrl);
            }

            renderSubtitles();
            renderImageStrip();
            Utils.showToast(`이미지 #${imageIndex + 1} 적용 완료`, 'success');
            saveSubtitles();
            return;
        }

        // Handle legacy/other types if necessary
        // ...
    }

    // [NEW] In-Place Rendering Logic
    async function renderVideoInPlace() {
        const btn = document.getElementById('renderBtn');
        const originalText = btn.innerHTML;

        if (!confirm('현재 설정으로 영상을 렌더링하시겠습니까?')) return;

        // UI Loading State
        btn.disabled = true;
        btn.innerHTML = `<svg class="animate-spin h-4 w-4 text-white" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> 저장 및 렌더링 중...`;

        try {
            // [FIX] Ensure current state is saved before rendering
            await saveSubtitles(true);

            // 1. Request Render
            // Note: API expects resolution, use_subtitles, etc. Defaulting for now.
            const res = await fetch(`/api/projects/${projectId}/render`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    project_id: projectId,
                    use_subtitles: true,
                    resolution: "1080p" // or load from settings
                })
            });
            const data = await res.json();

            if (data.status === 'processing') {
                Utils.showToast("렌더링이 시작되었습니다. 잠시만 기다려주세요...", "info");
                // Start Polling
                pollRenderStatus(btn, originalText);
            } else {
                throw new Error(data.error || "Unknown Error");
            }

        } catch (e) {
            console.error(e);
            Utils.showToast("렌더링 요청 실패: " + e.message, 'error');
            btn.disabled = false;
            btn.innerHTML = originalText;
        }
    }

    async function pollRenderStatus(btn, originalText) {
        const pollInterval = 2000; // 2 seconds

        const timer = setInterval(async () => {
            try {
                const res = await fetch(`/api/projects/${projectId}/status`);
                const data = await res.json();

                if (data.status === 'ok') {
                    if (data.project_status === 'rendered' && data.video_path) {
                        clearInterval(timer);
                        onRenderComplete(data.video_path, btn, originalText);
                    } else if (data.project_status === 'failed') {
                        clearInterval(timer);
                        throw new Error("Render Failed on Server");
                    }
                    // Else: keep polling
                }
            } catch (e) {
                console.error("Polling Error", e);
                clearInterval(timer);
                Utils.showToast("상태 확인 중 오류 발생: " + e.message, 'error');
                btn.disabled = false;
                btn.innerHTML = originalText;
            }
        }, pollInterval);
    } // Close pollRenderStatus

    // [NEW] Call Auto Sync API
    async function distributeImages(btn) {
        if (!confirm("AI를 사용하여 이미지를 자막에 자동으로 배치하시겠습니까?\n이전의 수동 배치는 덮어씌워집니다.")) {
            return;
        }

        // Fallback if btn not passed
        if (!btn) btn = document.querySelector('button[onclick*="distributeImages"]');

        const originalText = btn ? btn.innerHTML : "AI 이미지 싱크 맞추기";
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = `<span class="animate-spin">🔄</span> 처리중...`;
        }

        try {
            // [FIX] Current backend expects POST to /api/subtitle/auto_sync_images
            const response = await fetch(`/api/subtitle/auto_sync_images`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ project_id: projectId })
            });

            const data = await response.json();

            if (data.status === 'ok') {
                const count = data.timeline_images ? data.timeline_images.length : (data.matched_count || 0);
                Utils.showToast(`${count}개의 이미지가 자동으로 배치되었습니다.`, 'success');
                // Reload data to reflect changes
                await loadProjectAndSubtitles();
            } else {
                throw new Error(data.error || "Unknown Error");
            }

        } catch (e) {
            console.error(e);
            Utils.showToast(`이미지 자동 배치 실패: ${e.message}`, 'error');
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalText;
        }
    }

    // [NEW] Reset and Reload Function
    async function resetAndReload(btn) {
        if (!confirm("모든 데이터를 다시 불러오시겠습니까? 저장하지 않은 내용은 사라질 수 있습니다.")) return;

        const originalText = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = `<span class="animate-spin">🔄</span> 로딩중...`;

        try {
            // [FIX] Force Refetch with refresh flag
            await loadProjectAndSubtitles(true);
            Utils.showToast("데이터가 초기화되고 최신 상태로 로드되었습니다.", "success");
        } catch (e) {
            Utils.showToast("데이터 로드 실패: " + e.message, "error");
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalText;
        }
    }

    function onRenderComplete(videoPath, btn, originalText) {
        Utils.showToast("렌더링 완료! 렌더링 페이지로 이동합니다.", "success");

        // Reset Button
        btn.disabled = false;
        btn.innerHTML = originalText;

        // [CHANGED] Redirect to render page instead of showing video here
        setTimeout(() => {
            window.location.href = `/render?project_id=${currentProjectId}`;
        }, 1000); // 1초 후 이동 (토스트 메시지를 볼 수 있도록)
    }

    function closeRenderedVideo() {
        const renderedSection = document.getElementById('renderedVideoSection');
        const videoPlayer = document.getElementById('renderedVideoPlayer');

        if (renderedSection) {
            renderedSection.classList.add('hidden');
        }

        if (videoPlayer) {
            videoPlayer.innerHTML = ''; // Clear video to stop playback
        }
    }

    function allowDrop(ev) {
        ev.preventDefault();
        ev.target.closest('.group').classList.add('bg-blue-50', 'dark:bg-blue-900/20');
    }

    // Reset visual on drag leave (optional but good)
    // We didn't add ondragleave, so might skip visual reset for simplicity or add it.
    // Let's keep it simple. The hover (dragover) effect might stick if not careful, 
    // but the `renderSubtitles()` call will clear everything instantly on drop.

    function handleCombinedDrop(ev, subIdx) {
        ev.preventDefault();
        const srcIdx = ev.dataTransfer.getData("text/plain");
        if (srcIdx === "" || isNaN(srcIdx)) return;

        const imageIndex = parseInt(srcIdx);
        // Validate against sourceImages (Palette)
        if (imageIndex < 0 || imageIndex >= sourceImages.length) return;

        // Logic: Apply Image #imageIndex to start at Subtitle #subIdx
        if (subIdx < 0 || subIdx >= subtitles.length) return;

        const targetTime = subtitles[subIdx].start;
        const targetUrl = sourceImages[imageIndex]; // Get from Palette

        // 1. Check if an image timing already exists nearby (tolerance)
        // If so, update it. If not, insert it.
        // Actually, for reuse/insert, we should insert into the lists.
        // But `imageTimings` and `images` must be parallel.
        // But `imageTimings` is float[], `images` is string[].

        // Current structure assumption:
        // images uses separate index? No.
        // `imageTimings` maps 1:1 to `images`?
        // Let's check `get_subtitles`.
        // `images = [url, url, ...]`
        // `image_timings = [0.0, 5.0, ...]`
        // They MUST be parallel arrays index-wise.

        // So validation:
        // We need to insert `targetTime` into `imageTimings`.
        // And insert `targetUrl` into `images` at the SAME index.

        if (!imageTimings) imageTimings = [];

        // Find insert position
        let insertPos = 0;
        while (insertPos < imageTimings.length && imageTimings[insertPos] < targetTime) {
            insertPos++;
        }

        // Prevent duplicate time exact match (overwrite instead)
        if (insertPos < imageTimings.length && Math.abs(imageTimings[insertPos] - targetTime) < 0.1) {
            // Overwrite existing at this time
            images[insertPos] = targetUrl;
            imageTimings[insertPos] = targetTime;
        } else {
            // Insert new
            imageTimings.splice(insertPos, 0, targetTime);
            images.splice(insertPos, 0, targetUrl);
        }

        // Update UI
        renderSubtitles();
        renderImageStrip();
        Utils.showToast(`?대?吏 #${imageIndex + 1} 적용 완료`, 'success');

        // Auto Save to persist custom order
        // We use a debounced save or immediate? Immediate is fine for interaction.
        saveSubtitles();
    }

    async function loadProjectAndSubtitles(forceRefresh = false) {
        updateDebug(`[Func] loadProjectAndSubtitles START. Pid: ${projectId}, Force: ${forceRefresh}`);
        if (!projectId) {
            Utils.showToast('프로젝트 ID를 찾을 수 없습니다.', 'error');
            updateDebug('[Func] No Project ID');
            return;
        }

        if (typeof Utils === 'undefined') {
            updateDebug('CRITICAL: Utils is undefined!');
            return;
        }

        try {
            updateDebug('[Func] Fetching data...');

            let url = `/api/projects/${projectId}/subtitles?t=${new Date().getTime()}`;
            if (forceRefresh) {
                url += '&force_refresh=true';
            }

            const res = await fetch(url);
            updateDebug(`[Func] Fetch Res: ${res.status}`);
            const data = await res.json();
            updateDebug(`[Func] Data JSON parsed. Status: ${data.status}`);

            if (data.status === 'ok') {
                // 1. Set Data
                subtitles = data.subtitles || [];
                imageTimings = (data.image_timings || [0.0]).map(Number);
                images = data.timeline_images || [];
                sourceImages = data.source_images || [];
                // [NEW] Load Effects
                imageEffects = data.image_effects || [];
                console.log("[Load] Received Image Effects:", imageEffects);
                updateDebug(`[Load] Effects Raw: ${JSON.stringify(imageEffects)}`);

                // Ensure imageEffects matches images length
                // If loaded effects are fewer than images, pad with 'random'
                // If more, truncate or keep? Keep is safer.
                while (imageEffects.length < images.length) {
                    imageEffects.push('random');
                }

                // Also validate that each item is valid string
                for (let i = 0; i < imageEffects.length; i++) {
                    if (!imageEffects[i]) imageEffects[i] = 'random';
                }

                updateDebug(`[Data] Effects Loaded: ${imageEffects.length} items.`);


                updateDebug(`[Data] Subtitles: ${subtitles.length}, Images: ${images.length}, Timings: ${imageTimings.length}, Source: ${sourceImages.length}`);
                console.log("[Data Detail]", { imageTimings, images, sourceImages });



                // Style Settings
                if (data.settings) {
                    styleSettings = {
                        font: data.settings.subtitle_font || 'GmarketSansBold',
                        fontSize: parseFloat(data.settings.subtitle_font_size || 5.4),
                        color: data.settings.subtitle_base_color || '#ffffff',
                        strokeColor: data.settings.subtitle_stroke_color || '#000000',
                        strokeWidth: parseFloat(data.settings.subtitle_stroke_width || 0),
                        bgEnabled: parseInt(data.settings.subtitle_bg_enabled || 0) === 1,
                        lineSpacing: parseFloat(data.settings.subtitle_line_spacing || 0.1),
                        bgColor: data.settings.subtitle_bg_color || '#000000',
                        bgOpacity: parseFloat(data.settings.subtitle_bg_opacity || 0.5),
                        aspect_ratio: data.settings.aspect_ratio || '9:16'
                    };

                    // [NEW] Store App Mode for UI Logic
                    window.currentAppMode = data.settings.app_mode || 'longform';
                    console.log("App Mode:", window.currentAppMode);

                    // Apply UI
                    const fontEl = document.getElementById('fontFamilySelect');
                    if (fontEl) fontEl.value = styleSettings.font;

                    const sizeEl = document.getElementById('fontSizeSlider');
                    if (sizeEl) {
                        sizeEl.value = styleSettings.fontSize;
                        const valueEl = document.getElementById('fontSizeValue');
                        if (valueEl) valueEl.textContent = styleSettings.fontSize + '%';
                    }

                    const colorEl = document.getElementById('textColorInput');
                    if (colorEl) colorEl.value = styleSettings.color;

                    const strokeWidthInput = document.getElementById('strokeWidthInput');
                    if (strokeWidthInput) strokeWidthInput.value = styleSettings.strokeWidth;

                    const bgToggle = document.getElementById('bgStripToggle');
                    if (bgToggle) bgToggle.checked = styleSettings.bgEnabled;

                    const spacingEl = document.getElementById('lineSpacingInput');
                    if (spacingEl) spacingEl.value = styleSettings.lineSpacing;

                    const bgColorEl = document.getElementById('bgColorInput');
                    if (bgColorEl) bgColorEl.value = styleSettings.bgColor;

                    const bgOpacityEl = document.getElementById('bgOpacityInput');
                    if (bgOpacityEl) bgOpacityEl.value = styleSettings.bgOpacity;

                    // Position
                    if (data.settings.subtitle_pos_x && data.settings.subtitle_pos_y) {
                        const preview = document.getElementById('previewTextMain');
                        if (preview) {
                            preview.style.left = data.settings.subtitle_pos_x;
                            preview.style.top = data.settings.subtitle_pos_y;
                        }
                    } else if (window.currentAppMode === 'shorts') {
                        // [NEW] Default Position for Shorts (11/16ths down)
                        const preview = document.getElementById('previewTextMain');
                        if (preview) {
                            // 11/16 = 68.75%
                            preview.style.top = '68.75%';
                            // Ensure centered horizontally if not set
                            if (!data.settings.subtitle_pos_x) preview.style.left = '50%';

                            // Save this default so it persists? 
                            // Or just visual default. Let's apply visually.
                        }
                    }

                    // Aspect Ratio
                    if (data.settings.aspect_ratio) {
                        setAspectRatio(data.settings.aspect_ratio);
                    }
                    else if (data.settings.app_mode === 'shorts') {
                        setAspectRatio('9:16');
                    }
                    else {
                        // Default for Longform
                        setAspectRatio('16:9');
                    }
                }

                // 2. Render
                // 2. Render
                renderSubtitles();
                const listEl = document.getElementById('subtitleList');
                updateDebug(`Render Called. List Element: ${!!listEl}, InnerHTML Length: ${listEl ? listEl.innerHTML.length : 0}`);
                renderImageStrip();
                updateSubtitlePreview();

                if (subtitles.length > 0) {
                    selectSubtitle(0);
                    updateDebug(`Loaded and Selected. Subtitles: ${subtitles.length}`);
                } else {
                    Utils.showToast('생성된 자막이 없습니다. 자막 생성을 진행해주세요.', 'info');
                    updateDebug('Loaded but empty subtitles.');
                }

            } else {
                throw new Error(data.error);
            }
        } catch (e) {
            console.error(e);
            Utils.showToast("데이터 로딩 실패: " + e.message, 'error');
        } finally {

        }
    }




    // [DEBUG] Helper
    function updateDebug(msg) {
        const el = document.getElementById('debug-overlay');
        if (el) {
            const time = new Date().toLocaleTimeString();
            el.innerHTML = `[${time}] ${msg}<br>` + el.innerHTML;
        }
        console.log('[DEBUG]', msg);
    }

    // Global Error Handler
    window.onerror = function (msg, url, lineNo, columnNo, error) {
        updateDebug(`SCRIPT ERROR: ${msg} (Line: ${lineNo})`);
        return false;
    };

    // Global Setting Handlers for HTML onchange
    function updateBgStrip(el) {
        if (!projectId) return;
        const val = el.checked ? 1 : 0;
        styleSettings.bgEnabled = !!el.checked;
        API.project.updateSetting(projectId, 'subtitle_bg_enabled', val);
        updateSubtitlePreview();
    }

    function updateStrokeToggle(el) {
        // Redundant with numeric input, but keeping for compatibility if referenced
        if (!projectId) return;
        const val = el.checked ? 1 : 0;
        API.project.updateSetting(projectId, 'subtitle_stroke_enabled', val);
        updateSubtitlePreview();
    }
</script>
{% endblock %}