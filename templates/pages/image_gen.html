{% extends "base.html" %}

{% block content %}


<div class="card mb-6">
    <div class="flex flex-wrap items-center gap-6 mb-6">
        <h3 class="font-bold text-gray-800 dark:text-white shrink-0 flex items-center gap-2">
            <span>{{ t('image_settings_title') }}</span>
            <span id="scriptStatusBadge"
                class="text-[10px] items-center gap-1 px-2 py-0.5 rounded-full bg-gray-100 text-gray-400 font-normal hidden md:flex">
                <span>ğŸ”„</span> {{ t('status_checking_script') }}
            </span>
        </h3>

        <div class="flex flex-wrap items-center gap-4">
            <!-- Image Options -->
            <div id="imageOptions" class="flex flex-wrap items-center gap-4">
                <!-- Aspect Ratio -->
                <div class="flex bg-gray-100 dark:bg-gray-700 p-1 rounded-lg shadow-inner">
                    <label class="cursor-pointer" id="ratio-16-9">
                        <input type="radio" name="aspectRatio" value="16:9" checked class="peer sr-only">
                        <div
                            class="px-4 py-1.5 rounded-md text-xs font-bold peer-checked:bg-blue-600 peer-checked:text-white text-gray-600 dark:text-white transition-all">
                            16:9</div>
                    </label>
                    <label class="cursor-pointer" id="ratio-1-1">
                        <input type="radio" name="aspectRatio" value="1:1" class="peer sr-only">
                        <div
                            class="px-4 py-1.5 rounded-md text-xs font-bold peer-checked:bg-blue-600 peer-checked:text-white text-gray-600 dark:text-white transition-all">
                            1:1</div>
                    </label>
                    <label class="cursor-pointer" id="ratio-9-16">
                        <input type="radio" name="aspectRatio" value="9:16" class="peer sr-only">
                        <div
                            class="px-4 py-1.5 rounded-md text-xs font-bold peer-checked:bg-blue-600 peer-checked:text-white text-gray-600 dark:text-white transition-all">
                            9:16</div>
                    </label>
                    <label class="cursor-pointer" id="ratio-3-4">
                        <input type="radio" name="aspectRatio" value="3:4" class="peer sr-only">
                        <div
                            class="px-4 py-1.5 rounded-md text-xs font-bold peer-checked:bg-blue-600 peer-checked:text-white text-gray-600 dark:text-white transition-all">
                            3:4</div>
                    </label>
                </div>

                <!-- Character Analysis Button (Moved here) -->
                <button onclick="analyzeCharacters()" id="analyzeCharacterBtn"
                    class="btn-secondary py-2 px-4 flex items-center justify-center gap-2 text-xs font-bold shadow-sm hover:scale-105 transition-transform bg-white border border-gray-300 dark:bg-gray-700 dark:border-gray-600">
                    <span>ğŸ§™â€â™‚ï¸</span>
                    <span class="hidden sm:inline">{{ t('btn_char_analysis') }}</span>
                </button>

                <!-- Scene Analysis Button -->
                <button onclick="analyzeScenes()" id="analyzeSceneBtn"
                    class="btn-secondary py-2 px-4 flex items-center justify-center gap-2 text-xs font-bold shadow-sm hover:scale-105 transition-transform bg-white border border-gray-300 dark:bg-gray-700 dark:border-gray-600">
                    <span>ğŸ”</span>
                    <span class="hidden sm:inline">{{ t('btn_scene_analysis') }}</span>
                </button>
                <span id="sceneCountBadge"
                    class="hidden text-xs font-bold bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 px-3 py-2 rounded-lg">
                    0 Scenes
                </span>

                <!-- Save Settings Button -->
                <button onclick="saveImageSettings(this)" id="saveSettingsBtn"
                    class="btn-secondary py-2 px-4 flex items-center justify-center gap-2 text-xs font-bold shadow-sm hover:scale-105 transition-transform bg-white border border-gray-300 dark:bg-gray-700 dark:border-gray-600">
                    <span>ğŸ’¾</span>
                    <span>{{ t('btn_save_settings') }}</span>
                </button>

                <!-- Generate Prompt Button -->
                <button onclick="generatePrompts()" id="generateBtn"
                    class="btn-primary py-2 px-4 flex items-center justify-center gap-2 text-xs font-bold shadow-md hover:scale-105 transition-transform bg-gradient-to-r from-blue-600 to-indigo-600">
                    <span>ğŸª„</span>
                    <span>{{ t('btn_gen_prompt') }}</span>
                </button>
            </div>
        </div>

        <!-- Character Consistency Input -->
        <div class="w-full mt-4 bg-gray-50 dark:bg-gray-800 p-4 rounded-lg border border-gray-200 dark:border-gray-700">
            <div class="flex flex-col md:flex-row gap-6">
                <!-- Left: Controls -->
                <div class="flex-1">
                    <label class="block text-sm font-bold text-gray-800 dark:text-gray-200 mb-3">ğŸ‘¤ ì£¼ì¸ê³µ/ìºë¦­í„° ì¼ê´€ì„± ìœ ì§€
                        (Reference)</label>

                    <div class="flex flex-col gap-3">
                        <div class="flex items-center flex-wrap gap-4">
                            <!-- Upload Button -->
                            <div class="flex items-center gap-2">
                                <button onclick="document.getElementById('charUploadInput').click()"
                                    class="btn-secondary text-xs py-2 px-3 flex items-center gap-1">
                                    <span>ğŸ“‚</span> {{ t('btn_upload_image') }}
                                </button>
                                <input type="file" id="charUploadInput" class="hidden" accept="image/*"
                                    onchange="previewCharImage(this)">
                            </div>

                            <span class="text-xs text-gray-400">OR</span>

                            <!-- Use Thumbnail Checkbox -->
                            <label
                                class="flex items-center gap-2 cursor-pointer p-2 rounded hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                                <input type="checkbox" id="useThumbnailCheck"
                                    class="rounded border-gray-300 text-blue-600 focus:ring-blue-500" checked>
                                <span class="text-xs font-medium text-gray-700 dark:text-white">{{
                                    t('curr_thumb_as_char') }}</span>
                            </label>
                        </div>

                        <!-- Preview (Upload) -->
                        <div id="charPreviewArea"
                            class="hidden items-center gap-3 bg-white dark:bg-gray-900 p-2 rounded border border-gray-200 dark:border-gray-700 w-fit">
                            <img id="charPreviewImg" src=""
                                class="w-10 h-10 rounded object-cover border border-gray-300">
                            <span class="text-xs text-gray-500" id="charPreviewName">{{ t('img_selected') }}</span>
                            <button onclick="clearCharImage()"
                                class="text-red-500 hover:text-red-700 text-xs ml-2">âŒ</button>
                        </div>

                        <!-- Analyze Button -->
                        <div class="flex items-center gap-2 mt-1">
                            <button onclick="analyzeAndSetConsistency()" id="analyzeBtn"
                                class="btn-primary flex-1 md:flex-none text-xs py-2 px-4 bg-indigo-600 hover:bg-indigo-700">
                                {{ t('btn_ai_vision_apply') }}
                            </button>
                            <p class="text-[10px] text-gray-400">
                                {{ t('ai_vision_helper') }}
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Right: Thumbnail Reference Display -->
                <div
                    class="w-full md:w-1/3 flex flex-col items-center justify-center border-l border-gray-200 dark:border-gray-600 pl-0 md:pl-6 pt-4 md:pt-0 border-dashed">
                    <label class="block text-xs font-medium text-gray-500 mb-2 w-full text-center">{{
                        t('curr_proj_thumb') }}</label>
                    <div id="thumbnailReferenceContainer"
                        class="relative w-[30%] aspect-video bg-gray-800 rounded-lg overflow-hidden shadow-sm group border border-gray-200 dark:border-gray-700">
                        <img id="currentProjectThumbnail" src=""
                            class="w-full h-full object-contain opacity-50 transition-opacity duration-300"
                            alt="Thumbnail" onerror="this.style.opacity=0">
                        <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
                            <span class="text-xs text-gray-400" id="thumbPlaceholder">{{ t('no_thumb') }}</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="w-full mt-3">
            <label class="block text-sm font-medium text-gray-700 dark:text-white mb-1">{{ t('global_consistency_label')
                }}</label>
            <textarea id="globalPrompt"
                class="input-field w-full text-sm p-3 h-24 bg-yellow-50 dark:bg-yellow-900/10 border-yellow-200 dark:border-yellow-800 focus:border-yellow-400 focus:ring-yellow-400"
                placeholder="{{ t('global_consistency_placeholder') }}"></textarea>

            <!-- [MOVED] ìºë¦­í„° ë¶„ì„ ê²°ê³¼ -->
            <div id="characterResultContainer"
                class="hidden mt-4 bg-white dark:bg-gray-800 p-4 rounded-lg border border-gray-200 dark:border-gray-700 shadow-sm">
                <div id="characterList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
            </div>

            <!-- [MOVED] ë¡œë”© ì¸ë””ì¼€ì´í„° -->
            <div id="characterLoading" class="hidden mt-4 text-center py-4">
                <div
                    class="inline-block animate-spin rounded-full h-6 w-6 border-4 border-indigo-500 border-t-transparent">
                </div>
                <p class="mt-2 text-xs text-indigo-600 font-medium">{{ t('status_analyzing') }}</p>
            </div>
        </div>
    </div>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div class="col-span-1 md:col-span-2">
            <label class="block text-sm font-medium text-gray-700 dark:text-white mb-2">{{ t('select_style_label')
                }}</label>
            <input type="hidden" id="imageStyle" value="realistic">

            <!-- [Modified] Styles loaded dynamically -->
            <div id="styleSelectorGrid" class="grid grid-cols-6 md:grid-cols-12 gap-3">
                <!-- Loaded via JS -->
            </div>


        </div>
    </div>
</div>


<div id="resultSection" class="hidden">
    <div class="card">
        <div class="flex items-center justify-between mb-6 pb-4 border-b border-gray-100 dark:border-gray-700">
            <h3 class="font-bold text-gray-800 dark:text-white flex items-center gap-2">
                <span>ğŸ¨</span> {{ t('gen_prompts_title') }}
            </h3>
            <div class="flex gap-2">
                <button onclick="toggleSelectAll()" id="selectAllBtn"
                    class="btn-secondary text-sm px-4 flex items-center gap-2">
                    <span id="selectAllIcon">â˜</span> {{ t('btn_select_all') }}
                </button>
                <button onclick="downloadAllImages()" class="btn-secondary text-sm px-4 flex items-center gap-2">
                    {{ t('btn_download_images') }}
                </button>
                <button onclick="copyAllPrompts()" class="btn-secondary text-sm px-4">{{ t('btn_copy_all') }}</button>
                <button onclick="generateSelectedImages()" id="autoGenBtn"
                    class="btn-primary text-sm px-4 flex items-center gap-2 bg-gradient-to-r from-purple-600 to-indigo-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled>
                    <span>ğŸš€</span> {{ t('btn_gen_images') }}
                </button>
            </div>
        </div>

        <div id="promptsList" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"></div>

        <!-- ë‹¤ìŒ ë‹¨ê³„ ë²„íŠ¼ (ìˆ¨ê¹€ ìƒíƒœë¡œ ì‹œì‘) -->
        <div id="nextStepSection" class="hidden mt-6 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg text-center">
            <h4 class="font-bold text-lg mb-2 text-blue-800 dark:text-blue-300">{{ t('gen_complete_title') }}</h4>
            <p class="mb-4 text-sm text-gray-600 dark:text-gray-400">{{ t('gen_complete_desc') }}</p>
            <a href="/video-gen" class="btn-primary inline-flex items-center gap-2">
                {{ t('btn_go_video_check') }}
            </a>
            <div class="mt-2 text-xs text-gray-500">{{ t('or') }} <a href="/tts"
                    class="underline hover:text-blue-600">{{ t('btn_go_tts_direct') }}</a></div>
        </div>

        <div class="mt-6 pt-6 border-t border-gray-200 dark:border-gray-700">
            <h4 class="font-medium text-gray-800 dark:text-white mb-3">{{ t('external_services_title') }}</h4>
            <div class="flex flex-wrap gap-2">
                <a href="https://midjourney.com" target="_blank" class="btn-secondary text-sm">Midjourney</a>
                <a href="https://labs.openai.com" target="_blank" class="btn-secondary text-sm">DALL-E</a>
                <a href="https://leonardo.ai" target="_blank" class="btn-secondary text-sm">Leonardo AI</a>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
</script>
<script>
    let prompts = [];

    const i18n = {
        err_no_script: "{{ t('err_no_script') }}",
        status_analyzing: "{{ t('status_analyzing') }}",
        char_not_found: "{{ t('char_not_found') }}",
        img_not_generated: "{{ t('img_not_generated') }}",
        btn_ai_gen: "{{ t('btn_ai_gen') }}",
        btn_apply: "{{ t('btn_apply') }}",
        toast_char_prompt_regen: "{{ t('toast_char_prompt_regen') }}",
        toast_vision_success: "{{ t('toast_vision_success') }}",
        toast_vision_fail: "{{ t('toast_vision_fail') }}",
        status_analyzing_script: "{{ t('status_analyzing_script') }}",
        msg_scenes_analyzed: "{{ t('msg_scenes_analyzed') }}",
        confirm_delete_char: "ì´ ìºë¦­í„° ì¹´ë“œë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
        label_fadein: "{{ t('label_fadein') }}",
        no_script_desc: "{{ t('no_script_desc') }}",
        label_start: "{{ t('label_start') }}",
        label_end: "{{ t('label_end') }}",
        toast_json_copied: "{{ t('toast_json_copied') }}",
        opt_motion_standard: "âš¡ 5s (í‘œì¤€)",
        opt_motion_extend: "ğŸ’ 8s (ê³ í™”ì§ˆ ì—°ì¥)",
        opt_motion_slowmo: "ğŸ¢ 8s (ë¶€ë“œëŸ¬ìš´ ìŠ¬ë¡œìš°ëª¨)",
        btn_media_upload_v2: "{{ t('btn_media_upload_v2') }}",
        char_name_unknown: "Unknown",
        char_role: "Character",
        btn_json_copy: "ğŸ“‹ JSON {{ t('btn_copy') }}",
        btn_gen_single_img: "ğŸ¨ {{ t('btn_gen_images') }}",
        err_server_comm: "ì„œë²„ í†µì‹  ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
        err_char_analysis_fail: "ìºë¦­í„° ë¶„ì„ ì‹¤íŒ¨",
        btn_regen_prompt: "{{ t('btn_regen_prompt') }}",
        btn_delete: "{{ t('btn_delete') }}",
        no_desc: "{{ t('label_no_desc') }}",
        status_generating: "ìƒì„± ì¤‘..."
    };

    // [NEW] ìºë¦­í„° ë¶„ì„ í•¨ìˆ˜
    async function analyzeCharacters() {
        // [Fix] ìŠ¤í¬ë¦½íŠ¸ ë°ì´í„° ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜¤ê¸° (ê°ì²´ì¼ ê²½ìš° ì²˜ë¦¬)
        const scriptData = Utils.storage.get('fullScript');
        let script = "";

        if (scriptData && typeof scriptData === 'object') {
            // ë§Œì•½ ê°ì²´ë¼ë©´ í…ìŠ¤íŠ¸ í•„ë“œë¥¼ ì°¾ê±°ë‚˜ ì „ì²´ë¥¼ ë¬¸ìì—´í™”
            script = scriptData.content || scriptData.text || scriptData.script || JSON.stringify(scriptData);
        } else {
            script = String(scriptData || "");
        }

        if (!script || script === "null" || script.length < 10) {
            alert(i18n.err_no_script);
            return;
        }

        const btn = document.getElementById('analyzeCharacterBtn');
        const loader = document.getElementById('characterLoading');
        const container = document.getElementById('characterResultContainer');
        const list = document.getElementById('characterList');

        // UI ìƒíƒœ ì—…ë°ì´íŠ¸
        btn.disabled = true;
        btn.classList.add('opacity-50', 'cursor-not-allowed');
        loader.classList.remove('hidden');
        container.classList.add('hidden');
        list.innerHTML = '';

        try {
            // [Fix] PROJECT_ID ì „ì—­ ë³€ìˆ˜ ëŒ€ì‹  í•¨ìˆ˜ ì‚¬ìš©
            const pid = (typeof getCurrentProject === 'function') ? getCurrentProject() : null;

            const response = await fetch('/api/image/character-prompts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    script: script,
                    project_id: pid
                })
            });

            const result = await response.json();

            if (result.status === 'ok' && result.characters) {
                // [NEW] Save to local storage for persistence
                Utils.storage.set('characterPrompts', result.characters);

                renderCharacters(result.characters);
                container.classList.remove('hidden');

                // ê²°ê³¼ ìŠ¤í¬ë¡¤ ì´ë™
                container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            } else {
                alert(i18n.err_char_analysis_fail + ':\n' + (result.error || JSON.stringify(result, null, 2)));
            }
        } catch (error) {
            console.error('Error analyzing characters:', error);
            alert(i18n.err_server_comm);
        } finally {
            btn.disabled = false;
            btn.classList.remove('opacity-50', 'cursor-not-allowed');
            loader.classList.add('hidden');
        }
    }

    // ìºë¦­í„° ì¹´ë“œ ë Œë”ë§
    function renderCharacters(characters) {
        const list = document.getElementById('characterList');

        if (characters.length === 0) {
            list.innerHTML = `<p class="col-span-full text-center text-gray-500 py-4">${i18n.char_not_found}</p>`;
            return;
        }

        characters.forEach((char, index) => {
            const card = document.createElement('div');
            card.className = "bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-4 shadow-sm hover:shadow-md transition-shadow relative group";

            // ì—­í• ì— ë”°ë¥¸ ë°°ì§€ ìƒ‰ìƒ
            let roleBadgeColor = "bg-gray-100 text-gray-600";
            if (char.role && char.role.includes("ì£¼ì¸ê³µ")) roleBadgeColor = "bg-blue-100 text-blue-700";
            else if (char.role && char.role.includes("ì¡°ì—°")) roleBadgeColor = "bg-green-100 text-green-700";

            card.innerHTML = `
                <div class="flex justify-between items-start mb-2">
                    <h4 class="font-bold text-gray-800 dark:text-white">${char.name || i18n.char_name_unknown}</h4>
                    <span class="text-xs px-2 py-1 rounded-full ${roleBadgeColor} font-medium">${char.role || i18n.char_role}</span>
                </div>
                
                <!-- Character Image Preview -->
                <div class="mb-3 aspect-square bg-gray-100 dark:bg-gray-900 rounded-lg overflow-hidden border border-gray-200 dark:border-gray-700 flex items-center justify-center relative group/char">
                    <img id="char-img-${index}" src="${char.image_url || ''}" class="w-full h-full object-cover ${char.image_url ? '' : 'hidden'}" alt="${char.name}">
                    <div id="char-placeholder-${index}" class="text-gray-400 text-[10px] ${char.image_url ? 'hidden' : ''}">${i18n.img_not_generated}</div>
                    
                    <div class="absolute inset-0 bg-black/40 opacity-0 group-hover/char:opacity-100 transition-opacity flex items-center justify-center">
                         <button onclick="generateCharacterImage(${index})" class="bg-blue-600 hover:bg-blue-700 text-white text-[10px] font-bold py-1.5 px-3 rounded-full shadow-lg transform hover:scale-105 transition-all">
                             ${i18n.btn_ai_gen}
                         </button>
                    </div>
                </div>

                <p class="text-[11px] text-gray-500 mb-2 border-b border-gray-100 dark:border-gray-700 pb-2 min-h-[3em] line-clamp-2" title="${char.description_ko}">
                    ${char.description_ko || i18n.no_desc}
                </p>

                <div class="bg-gray-50 dark:bg-gray-900/50 p-2 rounded text-[10px] text-gray-600 dark:text-gray-400 font-mono break-words mb-3 h-16 overflow-y-auto scrollbar-thin">
                    ${char.prompt_en}
                </div>

                <div class="flex gap-2">
                    <button onclick="applyCharacter(${index})" 
                        class="flex-1 btn-secondary text-xs py-1.5 flex items-center justify-center gap-1 hover:bg-blue-50 hover:text-blue-600 hover:border-blue-200">
                        <span>â¬‡ï¸</span> ${i18n.btn_apply}
                    </button>
                    
                    <button id="regen-btn-${index}" onclick="regenerateCharacter(${index})" 
                        class="px-2 py-1.5 border border-gray-200 dark:border-gray-700 rounded text-gray-500 hover:bg-green-50 dark:hover:bg-green-900/20 hover:text-green-600 transition-colors" title="${i18n.btn_regen_prompt}">
                        ğŸ”„
                    </button>
                    
                    <button onclick="deleteCharacter(${index})" 
                        class="px-2 py-1.5 border border-gray-200 dark:border-gray-700 rounded text-gray-500 hover:bg-red-50 dark:hover:bg-red-900/20 hover:text-red-600 transition-colors" title="${i18n.btn_delete}">
                        ğŸ—‘ï¸
                    </button>
                </div>
            `;
            list.appendChild(card);
        });
    }

    // [NEW] Delete Character
    async function deleteCharacter(index) {
        if (!confirm(i18n.confirm_delete_char)) return;

        let chars = Utils.storage.get('characterPrompts') || [];
        chars.splice(index, 1);
        Utils.storage.set('characterPrompts', chars);
        renderCharacters(chars);
    }

    // [NEW] Regenerate Character Prompt
    async function regenerateCharacter(index) {
        let chars = Utils.storage.get('characterPrompts') || [];
        const char = chars[index];
        if (!char) return;

        const btn = document.getElementById(`regen-btn-${index}`);
        if (btn) {
            btn.innerHTML = `<div class="animate-spin h-3 w-3 border-2 border-green-500 border-t-transparent rounded-full"></div>`;
            btn.disabled = true;
        }

        try {
            const prompt = `Rewrite and improve this visual image generation prompt for a character. Keep strictly to the visual description in English. Output only the prompt text.\n\nDescription (Korean): ${char.description_ko}\nCurrent Prompt: ${char.prompt_en}`;
            const res = await API.gemini.generate(prompt);

            if (res.text || res.candidates?.[0]?.content?.parts?.[0]?.text) {
                const newText = res.text || res.candidates[0].content.parts[0].text;
                chars[index].prompt_en = newText.trim();
                Utils.storage.set('characterPrompts', chars);
                renderCharacters(chars);
                Utils.showToast(i18n.toast_char_prompt_regen, 'success');
            } else {
                throw new Error("No response text");
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('ì¬ìƒì„± ì‹¤íŒ¨: ' + e.message, 'error');
            if (btn) {
                btn.innerHTML = 'ğŸ”„';
                btn.disabled = false;
            }
        }
    }

    // [NEW] ìºë¦­í„° ì´ë¯¸ì§€ ê°œë³„ ìƒì„±
    async function generateCharacterImage(index) {
        let chars = Utils.storage.get('characterPrompts') || [];
        const char = chars[index];
        if (!char) return;

        const projectId = getCurrentProject();
        if (!projectId) {
            Utils.showToast('í”„ë¡œì íŠ¸ë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.', 'warning');
            return;
        }

        const style = document.getElementById('imageStyle').value;
        const placeholder = document.getElementById(`char-placeholder-${index}`);
        const img = document.getElementById(`char-img-${index}`);

        // UI ìƒíƒœ ì—…ë°ì´íŠ¸
        placeholder.textContent = i18n.status_generating;
        placeholder.classList.remove('hidden');
        if (img) img.classList.add('hidden');

        try {
            const response = await fetch('/api/image/generate-character', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    prompt: char.prompt_en,
                    project_id: projectId,
                    style: style,
                    name: char.name // [NEW] Pass name for DB update
                })
            });
            const result = await response.json();

            if (result.status === 'ok') {
                char.image_url = result.url;
                char.image_path = result.path;
                chars[index] = char;
                Utils.storage.set('characterPrompts', chars);

                img.src = result.url;
                img.classList.remove('hidden');
                placeholder.classList.add('hidden');
                Utils.showToast('ìºë¦­í„° ì´ë¯¸ì§€ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
            } else {
                throw new Error(result.error || 'ìƒì„± ì‹¤íŒ¨');
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨: ' + e.message, 'error');
            placeholder.textContent = "ì´ë¯¸ì§€ ë¯¸ìƒì„±";
        }
    }

    // ìºë¦­í„° í”„ë¡¬í”„íŠ¸ ë° ì´ë¯¸ì§€ ì ìš©
    async function applyCharacter(index) {
        let chars = Utils.storage.get('characterPrompts') || [];
        const char = chars[index];
        if (!char) return;

        // 1. í”„ë¡¬í”„íŠ¸ ì ìš©
        const globalTextarea = document.getElementById('globalPrompt');
        const currentVal = globalTextarea.value.trim();
        if (currentVal) {
            globalTextarea.value = currentVal + "\n\n" + char.prompt_en;
        } else {
            globalTextarea.value = char.prompt_en;
        }

        // 2. ì´ë¯¸ì§€ ë ˆí¼ëŸ°ìŠ¤ ì ìš© (ìˆì„ ê²½ìš°)
        if (char.image_path) {
            const projectId = getCurrentProject();
            if (projectId) {
                try {
                    await API.project.updateSetting(projectId, 'character_ref_image_path', char.image_path);
                    await API.project.updateSetting(projectId, 'character_ref_text', char.prompt_en);

                    // UI ë ˆí¼ëŸ°ìŠ¤ ì´ë¯¸ì§€ ì—…ë°ì´íŠ¸
                    const thumbImg = document.getElementById('currentProjectThumbnail');
                    if (thumbImg) {
                        thumbImg.src = char.image_url;
                        thumbImg.style.opacity = 1;
                        const placeholder = document.getElementById('thumbPlaceholder');
                        if (placeholder) placeholder.classList.add('hidden');
                    }
                    Utils.showToast('ìºë¦­í„° ì´ë¯¸ì§€ê°€ ë ˆí¼ëŸ°ìŠ¤ë¡œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                } catch (e) {
                    console.error(e);
                }
            }
        }

        // íš¨ê³¼: ê¹œë¹¡ì„
        globalTextarea.classList.add('ring-2', 'ring-indigo-400');
        setTimeout(() => globalTextarea.classList.remove('ring-2', 'ring-indigo-400'), 500);
    }

    async function generatePrompts() {
        const scriptData = Utils.storage.get('fullScript');
        let script = "";

        if (scriptData) {
            if (typeof scriptData === 'object') {
                script = scriptData.content || scriptData.text || scriptData.script || JSON.stringify(scriptData);
            } else {
                script = String(scriptData);
            }
        }

        // ê¸°ì¡´ ë¡œì§ ìœ ì§€ (DB Fallback ë“±)
        if (!script) {
            // [NEW] ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì—†ìœ¼ë©´ DBì—ì„œ ê°€ì ¸ì˜¤ê¸° ì‹œë„
            const projectId = getCurrentProject();
            if (projectId) {
                try {
                    const result = await API.project.getScript(projectId);
                    if (result && result.full_script) {
                        script = result.full_script;
                        console.log("Script fetched from DB for image prompt generation.");
                    }
                } catch (e) {
                    console.error("Failed to fetch script from DB:", e);
                }
            }
        }

        if (!script) {
            Utils.showToast(i18n.err_no_script, 'warning');
            return;
        }

        const styleVal = document.getElementById('imageStyle').value;
        const globalPrompt = document.getElementById('globalPrompt').value;
        // Use analyzed scene count if available, otherwise let AI decide (0)
        const count = analyzedSceneCount || 0;

        const btn = document.getElementById('generateBtn');
        Utils.setLoading(btn, true, i18n.status_generating);

        try {
            // [Modified] Pass global prompt separately for intelligent application
            const result = await API.image.generatePrompts(script, styleVal, parseInt(count), globalPrompt.trim(), getCurrentProject());

            if (result.prompts) {
                prompts = result.prompts;
                drawPromptsUI(prompts);
                document.getElementById('resultSection').classList.remove('hidden');

                // í™œì„±í™”
                const autoBtn = document.getElementById('autoGenBtn');
                autoBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                autoBtn.disabled = false;

                Utils.storage.set('imagePrompts', prompts);

                // [FIX] Save to DB to ensure persistence of all fields (script_start/end, etc.)
                const pid = getCurrentProject();
                if (pid) {
                    API.project.saveImagePrompts(pid, prompts).then(() => {
                        console.log("Prompts saved to DB successfully");
                    }).catch(err => {
                        console.error("Failed to save prompts to DB:", err);
                    });
                }
            }
        } catch (error) {
            Utils.showToast('ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', 'error');
        } finally {
            Utils.setLoading(btn, false);
        }
    }

    function drawPromptsUI(data) {
        if (!data) data = prompts;
        console.log("Drawing UI with items:", data.length);

        const container = document.getElementById('promptsList');

        // Change to vertical list layout
        container.className = 'space-y-4';

        container.innerHTML = data.map((p, i) => {
            // [Fix] í‚¤ ê°’ í˜¸í™˜ì„± ì²˜ë¦¬ (scene vs scene_text, prompt vs prompt_en)
            // ëŒ€ë³¸ í…ìŠ¤íŠ¸ë¥¼ ìµœëŒ€í•œ ì°¾ì•„ë‚´ê¸° ìœ„í•´ prompt_koì™€ scene_titleê¹Œì§€ í™•ì¸
            const rawSceneText = p.scene_text || p.scene || p.scene_title || p.prompt_ko || '';
            const rawPromptKo = p.prompt_ko || p.scene || '';
            const rawPromptEn = p.prompt_en || p.prompt_content || p.prompt || '';
            // [NEW] Script segment info
            const scriptStart = p.script_start || '';
            const scriptEnd = p.script_end || '';

            // Extract first and last portions (Visual only)
            const words = rawSceneText.split(/\s+/);
            const firstText = words.slice(0, 10).join(' ') + (words.length > 10 ? '...' : '');
            const lastText = words.length > 20 ? '...' + words.slice(-10).join(' ') : '';

            // Build JSON object for display
            const jsonData = {
                scene_number: i + 1,
                scene_text: rawSceneText,
                prompt_ko: rawPromptKo,
                prompt_en: rawPromptEn,
                ...(scriptStart && { script_start: scriptStart }),
                ...(scriptEnd && { script_end: scriptEnd })
            };
            const jsonString = JSON.stringify(jsonData, null, 2);

            return `
            <div id="prompt-card-${i}" class="bg-gray-800 rounded-xl border border-gray-700 overflow-hidden shadow-md hover:shadow-lg transition-shadow">
                <!-- Header -->
                <div class="flex items-center justify-between px-4 py-3 bg-gray-900 border-b border-gray-700">
                    <div class="flex items-center gap-3">
                        <input type="checkbox" 
                               id="scene-checkbox-${i}" 
                               class="scene-checkbox w-5 h-5 rounded border-gray-500 text-blue-600 focus:ring-blue-500 cursor-pointer"
                               onchange="handleSceneSelection()">
                        <span class="flex items-center justify-center w-8 h-8 rounded-full bg-blue-600 text-white font-bold text-sm">${i + 1}</span>
                        <div>
                            <span class="font-bold text-white">Scene ${i + 1}</span>
                            <span class="text-xs text-gray-400 ml-2">ğŸ¬ ${firstText || i18n.no_script_desc}</span>
                        </div>
                        <!-- Fade-in Checkbox -->
                        <div class="flex items-center gap-1 ml-4 px-2 py-1 bg-gray-800/50 rounded border border-gray-600">
                            <input type="checkbox" 
                                   id="fadein-checkbox-${i}" 
                                   class="fadein-checkbox w-4 h-4 rounded border-gray-500 text-purple-600 focus:ring-purple-500 cursor-pointer"
                                   ${prompt.fade_in ? 'checked' : ''}
                                   onchange="updateFadeInSetting(${i}, this.checked)">
                            <label for="fadein-checkbox-${i}" class="text-xs text-gray-300 cursor-pointer select-none">${i18n.label_fadein}</label>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="copyPromptJson(${i})" class="btn-secondary text-xs px-3 py-1">${i18n.btn_json_copy}</button>
                        <button onclick="generateSingleImage(${i})" class="btn-primary text-xs px-3 py-1 bg-purple-600 hover:bg-purple-700">${i18n.btn_gen_single_img}</button>
                    </div>
                </div>
                
                <!-- Content -->
                <div class="p-4">
                    <div class="grid grid-cols-1 lg:grid-cols-12 gap-4">
                        <!-- Left: Image (2 columns) -->
                        <div class="lg:col-span-2 space-y-3">
                            <!-- Image Container -->
                            <div class="image-container relative flex justify-center"> <!-- [FIX] Center align -->
                                ${p.video_url ? `
                                <div class="aspect-video bg-black rounded-lg overflow-hidden border border-purple-500 w-[90%] relative group/video">
                                    <video src="${p.video_url}" class="w-full h-full object-contain" controls autoplay loop muted></video>
                                    <div class="absolute top-2 right-2 bg-purple-600 text-white text-xs px-2 py-1 rounded flex items-center gap-1">
                                        <span>ğŸ¬ Motion</span>
                                    </div>
                                </div>
                                ` : p.image_url ? `
                                <div class="aspect-video bg-black rounded-lg overflow-hidden border border-gray-600 w-[90%] relative group/image">
                                    <img src="${p.image_url}" class="w-full h-full object-contain" alt="Scene ${i + 1}">
                                    <div class="absolute top-2 right-2 bg-green-500 text-white text-xs px-2 py-1 rounded">âœ“ Image</div>
                                    
                                    <!-- Motion Button Overlay -->
                                     <div class="absolute inset-0 bg-black/50 opacity-0 group-hover/image:opacity-100 transition-opacity flex flex-col items-center justify-center gap-2">
                                          <button id="motion-btn-${i}" onclick="generateMotion(${i})" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-full shadow-lg transform hover:scale-105 transition-all flex items-center gap-2">
                                             <span>ğŸ¬ Motion</span>
                                          </button>
                                          <select id="motion-opt-${i}" class="text-[10px] bg-black/80 text-white rounded px-2 py-1 border border-purple-500 cursor-pointer hover:bg-black" onclick="event.stopPropagation()">
                                             <option value="5.0|standard" selected>${i18n.opt_motion_standard}</option>
                                             <option value="8.0|extend">${i18n.opt_motion_extend}</option>
                                             <option value="8.0|slowmo">${i18n.opt_motion_slowmo}</option>
                                          </select>
                                     </div>
                                </div>
                                ` : `
                                <div class="aspect-video bg-gray-900 rounded-lg border border-dashed border-gray-600 flex flex-col items-center justify-center w-[90%] transition-colors hover:bg-gray-800">
                                    <span class="text-gray-500 text-sm">ğŸ–¼ï¸ ${i18n.img_not_generated}</span>
                                </div>
                                `}
                            </div>
                            
                            <!-- [NEW] Upload Button (Common for all states) -->
                            <div class="w-[90%] mx-auto mt-2"> <!-- Center align with mx-auto -->
                                <button onclick="document.getElementById('scene-upload-${i}').click()" 
                                        class="w-full btn-secondary text-xs py-2 flex items-center justify-center gap-2 border border-dashed border-gray-600 hover:border-blue-500 hover:text-blue-500 transition-colors bg-gray-800/50">
                                    <span>ğŸ“‚</span> ${i18n.btn_media_upload_v2}
                                </button>
                                <input type="file" id="scene-upload-${i}" class="hidden" accept="image/*,video/*,video/mp4,video/x-m4v" onchange="uploadSceneImage(${i}, this)">
                            </div>
                        </div>
                        
                        <!-- Right: JSON Prompt (10 columns) -->
                        <div class="lg:col-span-10 space-y-2">
                            <div class="bg-gray-900 rounded-lg min-h-32 max-h-96 border border-gray-700 overflow-hidden relative">
                                <textarea 
                                    id="prompt-json-${i}"
                                    class="w-full h-auto min-h-32 bg-gray-900 text-xs text-green-400 font-mono p-3 resize-y focus:outline-none focus:ring-1 focus:ring-blue-500"
                                    oninput="updatePromptData(${i}, this.value); this.style.height = 'auto'; this.style.height = this.scrollHeight + 'px'"
                                    spellcheck="false"
                                >${escapeHtml(jsonString)}</textarea>
                            </div>
                            <!-- [NEW] Script Segments Info -->
                            ${scriptStart || scriptEnd ? `
                            <div class="bg-gray-800 rounded px-3 py-2 text-xs border border-gray-700">
                                <div class="flex gap-4 text-gray-400">
                                    ${scriptStart ? `<span>ğŸ”µ ${i18n.label_start}: <span class="text-gray-300">${scriptStart}</span></span>` : ''}
                                    ${scriptEnd ? `<span>ğŸ”´ ${i18n.label_end}: <span class="text-gray-300">${scriptEnd}</span></span>` : ''}
                                </div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
                
                <!-- Status Indicator (for generation progress) -->
                <div class="status-indicator hidden px-4 py-2 bg-gray-900 border-t border-gray-700 text-sm"></div>
            </div>
            `;
        }).join('');

        // Auto-adjust textarea heights after rendering
        setTimeout(() => {
            data.forEach((p, i) => {
                const textarea = document.getElementById(`prompt-json-${i}`);
                if (textarea) {
                    textarea.style.height = 'auto';
                    textarea.style.height = textarea.scrollHeight + 'px';
                }
            });
        }, 100);
    }

    // [NEW] Update prompt data from JSON editor
    function updatePromptData(index, jsonStr) {
        try {
            const newData = JSON.parse(jsonStr);
            if (prompts[index]) {
                const p = prompts[index];
                // Update editable fields
                if (newData.prompt_en) p.prompt_en = newData.prompt_en;
                if (newData.prompt_ko) p.prompt_ko = newData.prompt_ko;
                if (newData.scene_text) p.scene_text = newData.scene_text;
                // Update script info if edited
                if (newData.script_start) p.script_start = newData.script_start;
                if (newData.script_end) p.script_end = newData.script_end;

                // Clear validation error
                const textarea = document.getElementById(`prompt-json-${index}`);
                if (textarea) textarea.classList.remove('border-red-500', 'border-2');

                // Save to storage
                Utils.storage.set('imagePrompts', prompts);
            }
        } catch (e) {
            // Show validation error
            const textarea = document.getElementById(`prompt-json-${index}`);
            if (textarea) textarea.classList.add('border-red-500', 'border-2');
        }
    }

    // Helper function to escape HTML
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Copy JSON prompt
    function copyPromptJson(index) {
        const p = prompts[index];
        const jsonData = {
            scene_number: index + 1,
            scene_text: p.scene_text || p.scene || p.prompt_ko || '',
            prompt_ko: p.prompt_ko || p.scene || '',
            prompt_en: p.prompt_en || p.prompt_content || p.prompt || ''
        };
        Utils.copyToClipboard(JSON.stringify(jsonData, null, 2));
        Utils.showToast(i18n.toast_json_copied, 'success');
    }

    // Generate single image
    async function generateSingleImage(index) {
        const projectId = getCurrentProject();
        if (!projectId) {
            Utils.showToast('í”„ë¡œì íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
            return;
        }

        const p = prompts[index];
        const card = document.getElementById(`prompt-card-${index}`);
        if (!card) return;

        const statusDiv = card.querySelector('.status-indicator');
        statusDiv.classList.remove('hidden');
        statusDiv.className = 'status-indicator px-4 py-2 bg-yellow-900/30 border-t border-gray-700 text-sm text-yellow-400';
        statusDiv.textContent = 'â³ ' + i18n.status_generating;

        try {
            // [Fix] í‚¤ ê°’ í˜¸í™˜ì„± ì²˜ë¦¬
            const fullPrompt = p.prompt_en || p.prompt_content || p.prompt || '';
            const aspectRatio = document.querySelector('input[name="aspectRatio"]:checked')?.value || '16:9';

            const result = await API.image.generate(fullPrompt, projectId, index + 1, document.getElementById('imageStyle').value, aspectRatio);

            if (result.status === 'ok') {
                prompts[index].image_url = result.image_url;
                Utils.storage.set('imagePrompts', prompts);

                // [FIX] Save to DB immediately so Subtitle page can see it
                API.project.saveImagePrompts(projectId, prompts);

                // [Fix] UI ê°•ì œ ì—…ë°ì´íŠ¸ (ì´ë¯¸ì§€ ë¯¸í‘œì‹œ ë¬¸ì œ í•´ê²°)
                const scrollY = window.scrollY;
                drawPromptsUI(prompts);
                window.scrollTo(0, scrollY);

                Utils.showToast('Image generated', 'success');

                if (window.updateStepStatus) window.updateStepStatus('image', true);
            } else {
                throw new Error(result.error);
            }
        } catch (error) {
            console.error(error);
            Utils.showToast('ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨: ' + error.message, 'error');
            statusDiv.classList.add('hidden');
        }
    }

    // [NEW] Upload Scene Image
    async function uploadSceneImage(index, input) {
        if (!input.files || input.files.length === 0) return;

        const file = input.files[0];
        const projectId = getCurrentProject();

        if (!projectId) {
            Utils.showToast('Project not found', 'error');
            return;
        }

        // Show loading state
        const btn = input.previousElementSibling;
        const originalText = btn ? btn.innerHTML : '';
        if (btn) {
            btn.innerHTML = '<span>â³</span> ...';
            btn.disabled = true;
        }

        const formData = new FormData();
        formData.append('file', file);
        formData.append('project_id', projectId);
        formData.append('scene_index', index + 1);

        try {
            const response = await fetch('/api/image/upload-scene', {
                method: 'POST',
                body: formData
            });

            const result = await response.json();

            if (result.status === 'ok') {
                // Update prompts array based on type
                if (result.video_url) {
                    prompts[index].video_url = result.video_url;
                    prompts[index].image_url = null;
                } else {
                    prompts[index].image_url = result.image_url || result.url;
                    prompts[index].video_url = null;
                }

                // Save to Storage & DB to persist
                Utils.storage.set('imagePrompts', prompts);
                API.project.saveImagePrompts(projectId, prompts); // Async save

                // Refresh UI (Keep scroll position)
                const scrollY = window.scrollY;
                drawPromptsUI(prompts);
                window.scrollTo(0, scrollY);

                Utils.showToast('Media uploaded', 'success');
            } else {
                throw new Error(result.error || 'Server Error');
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('ì—…ë¡œë“œ ì‹¤íŒ¨: ' + e.message, 'error');
            // Reset button text via redraw or manual reset
            if (btn) {
                btn.innerHTML = originalText || '<span>ğŸ“‚</span> ë¯¸ë””ì–´ ì—…ë¡œë“œ';
                btn.disabled = false;
            }
        } finally {
            input.value = ''; // Reset input
        }
    }


    function copyPrompt(index) {
        const p = prompts[index];
        const content = p.prompt_en || p.prompt_content || p.prompt || '';
        Utils.copyToClipboard(content);
        Utils.showToast('Copied', 'success');
    }

    function copyAllPrompts() {
        const text = prompts.map((p, i) => `[ì¥ë©´ ${i + 1}] ${p.scene_text || p.scene || ''}\n${p.prompt_en || p.prompt_content || p.prompt || ''}`).join('\n\n');
        Utils.copyToClipboard(text);
        Utils.showToast('All copied', 'success');
    }

    async function downloadAllImages() {
        const imagesToDownload = prompts.filter(p => p.image_url);

        if (imagesToDownload.length === 0) {
            Utils.showToast('ë‹¤ìš´ë¡œë“œí•  ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤', 'warning');
            return;
        }

        Utils.showToast(`${imagesToDownload.length}ê°œ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì¤‘...`, 'info');

        for (let i = 0; i < imagesToDownload.length; i++) {
            const p = imagesToDownload[i];
            const sceneNum = prompts.indexOf(p) + 1;

            try {
                // Fetch image as blob
                const response = await fetch(p.image_url);
                const blob = await response.blob();

                // Create download link
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `Scene_${sceneNum}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);

                // Small delay between downloads to avoid browser blocking
                await new Promise(resolve => setTimeout(resolve, 300));
            } catch (e) {
                console.error(`Failed to download scene ${sceneNum}:`, e);
            }
        }

        Utils.showToast(`${imagesToDownload.length}ê°œ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ!`, 'success');
    }

    async function generateSelectedImages() {
        const projectId = getCurrentProject();
        if (!projectId) {
            Utils.showToast('í”„ë¡œì íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
            return;
        }

        if (prompts.length === 0) {
            Utils.showToast(i18n.err_no_script, 'warning');
            return;
        }

        const btn = document.getElementById('autoGenBtn');
        Utils.setLoading(btn, true, i18n.status_generating);

        let processedCount = 0;

        try {
            for (let i = 0; i < prompts.length; i++) {
                // Check selection
                const checkbox = document.getElementById(`scene-checkbox-${i}`);
                if (!checkbox || !checkbox.checked) continue;

                processedCount++;
                const p = prompts[i];

                // Skip if already generating (optional check, but good for safety)
                // if (p.image_url) continue; // User might want to regenerate selected, so allow it.

                const card = document.getElementById(`prompt-card-${i}`);
                if (!card) continue;

                // ìƒíƒœ í‘œì‹œ ì—…ë°ì´íŠ¸
                let statusDiv = card.querySelector('.status-indicator');
                if (statusDiv) {
                    statusDiv.classList.remove('hidden');
                    statusDiv.className = 'status-indicator px-4 py-2 bg-yellow-900/30 border-t border-gray-700 text-sm text-yellow-400';
                    statusDiv.textContent = 'â³ ' + i18n.status_generating;
                }

                // API í˜¸ì¶œ
                // [Fix] í‚¤ ê°’ í˜¸í™˜ì„± ì²˜ë¦¬
                const fullPrompt = p.prompt_en || p.prompt_content || p.prompt || '';
                const aspectRatio = document.querySelector('input[name="aspectRatio"]:checked')?.value || '16:9';

                const result = await API.image.generate(fullPrompt, projectId, i + 1, document.getElementById('imageStyle').value, aspectRatio);

                if (result.status === 'ok') {
                    // ì„±ê³µ ì‹œ UI ì—…ë°ì´íŠ¸: DOM ì¡°ì‘ì„ í†µí•´ ì´ë¯¸ì§€ ì»¨í…Œì´ë„ˆ êµì²´
                    const imageContainer = card.querySelector('.image-container');

                    if (imageContainer) {
                        // ê¸°ì¡´ ë‚´ìš©(placeholder ë˜ëŠ” ì´ì „ ì´ë¯¸ì§€) ì œê±°
                        imageContainer.innerHTML = '';

                        // ìƒˆ ì´ë¯¸ì§€ ìš”ì†Œ ìƒì„±
                        const imgDiv = document.createElement('div');
                        imgDiv.className = 'aspect-video bg-black rounded-lg overflow-hidden border border-gray-600 w-[90%] relative group/image';
                        imgDiv.innerHTML = `
                            <img src="${result.image_url}" class="w-full h-full object-contain" alt="Scene ${i + 1}">
                            <div class="absolute top-2 right-2 bg-green-500 text-white text-xs px-2 py-1 rounded">âœ“ Image</div>
                            
                            <!-- Motion Button Overlay (Re-added) -->
                            <div class="absolute inset-0 bg-black/50 opacity-0 group-hover/image:opacity-100 transition-opacity flex flex-col items-center justify-center gap-2">
                                 <button id="motion-btn-${i}" onclick="generateMotion(${i})" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-full shadow-lg transform hover:scale-105 transition-all flex items-center gap-2">
                                    <span>ğŸ¬ Motion</span>
                                 </button>
                                 <select id="motion-opt-${i}" class="text-[10px] bg-black/80 text-white rounded px-2 py-1 border border-purple-500 cursor-pointer hover:bg-black" onclick="event.stopPropagation()">
                                    <option value="5.0|standard" selected>${i18n.opt_motion_standard}</option>
                                    <option value="8.0|extend">${i18n.opt_motion_extend}</option>
                                    <option value="8.0|slowmo">${i18n.opt_motion_slowmo}</option>
                                 </select>
                            </div>
                        `;

                        imageContainer.appendChild(imgDiv);
                    }

                    if (statusDiv) {
                        statusDiv.textContent = 'âœ… Done';
                        statusDiv.className = 'status-indicator px-4 py-2 bg-green-900/30 border-t border-gray-700 text-sm text-green-400';
                    }

                    // ìŠ¤í† ë¦¬ì§€ì— ê²°ê³¼ ì €ì¥ (ìƒˆë¡œê³ ì¹¨ ì‹œ ìœ ì§€)
                    prompts[i].image_url = result.image_url;
                    Utils.storage.set('imagePrompts', prompts);

                    // [NEW] Update Progress Stepper (If at least one image generated)
                    if (window.updateStepStatus) window.updateStepStatus('image', true);
                } else {
                    if (statusDiv) {
                        statusDiv.textContent = 'âŒ ìƒì„± ì‹¤íŒ¨: ' + result.error;
                        statusDiv.className = 'status-indicator px-4 py-2 bg-red-900/30 border-t border-gray-700 text-sm text-red-400';
                    }
                }
            }

            if (processedCount === 0) {
                Utils.showToast('No items selected', 'warning');
            } else {
                Utils.showToast(`${processedCount} images processed`, 'success');
            }

            // ë‹¤ìŒ ë‹¨ê³„ (ìˆ˜ë™ ì´ë™)
            const nextSection = document.getElementById('nextStepSection');
            if (nextSection) {
                nextSection.classList.remove('hidden');
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('Error during image generation', 'error');
        } finally {
            Utils.setLoading(btn, false);
        }
    }

    // ========== Scene Selection Functions ==========

    // ì „ì²´ ì„ íƒ/í•´ì œ í† ê¸€
    function toggleSelectAll() {
        const checkboxes = document.querySelectorAll('.scene-checkbox');
        const selectAllBtn = document.getElementById('selectAllBtn');
        const selectAllIcon = document.getElementById('selectAllIcon');
        const allChecked = Array.from(checkboxes).every(cb => cb.checked);

        checkboxes.forEach(cb => {
            cb.checked = !allChecked;
        });

        // Update button state
        if (!allChecked) {
            selectAllIcon.textContent = 'â˜‘';
        } else {
            selectAllIcon.textContent = 'â˜';
        }

        handleSceneSelection();
    }

    // Scene ì„ íƒ ì‹œ ë²„íŠ¼ í™œì„±í™” ìƒíƒœ ì—…ë°ì´íŠ¸
    function handleSceneSelection() {
        const checkboxes = document.querySelectorAll('.scene-checkbox');
        const anySelected = Array.from(checkboxes).some(cb => cb.checked);
        const btn = document.getElementById('autoGenBtn');

        if (anySelected) {
            btn.disabled = false;
            btn.classList.remove('opacity-50', 'cursor-not-allowed');
        } else {
            btn.disabled = true;
            btn.classList.add('opacity-50', 'cursor-not-allowed');
        }

        // Update select-all button icon
        const selectAllIcon = document.getElementById('selectAllIcon');
        const allChecked = Array.from(checkboxes).every(cb => cb.checked);
        selectAllIcon.textContent = allChecked ? 'â˜‘' : 'â˜';
    }

    // [NEW] í˜ì´ë“œì¸ ì„¤ì • ì—…ë°ì´íŠ¸
    async function updateFadeInSetting(sceneIndex, fadeIn) {
        if (!currentProjectId) return;

        try {
            // Update local prompts data
            if (currentPrompts && currentPrompts.prompts && currentPrompts.prompts[sceneIndex]) {
                currentPrompts.prompts[sceneIndex].fade_in = fadeIn;

                // Save to backend
                const res = await fetch(`/api/projects/${currentProjectId}/image-prompts`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompts: currentPrompts.prompts })
                });

                const data = await res.json();
                if (data.status === 'ok') {
                    console.log(`í˜ì´ë“œì¸ ì„¤ì • ì €ì¥: Scene ${sceneIndex + 1} = ${fadeIn}`);
                } else {
                    throw new Error(data.error || 'ì €ì¥ ì‹¤íŒ¨');
                }
            }
        } catch (e) {
            console.error('í˜ì´ë“œì¸ ì„¤ì • ì €ì¥ ì‹¤íŒ¨:', e);
            Utils.showToast(`í˜ì´ë“œì¸ ì„¤ì • ì €ì¥ ì‹¤íŒ¨: ${e.message}`, 'error');
        }
    }





    // [NEW] Motion Generation (Wan 2.2)
    async function generateMotion(index) {
        const projectId = getCurrentProject();
        if (!projectId) return Utils.showToast('í”„ë¡œì íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');

        const p = prompts[index];
        if (!p || !p.image_url) return Utils.showToast('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”', 'warning');

        const card = document.getElementById(`prompt-card-${index}`);
        const statusDiv = card.querySelector('.status-indicator');

        // UI Update
        const btn = document.getElementById(`motion-btn-${index}`);
        if (btn) {
            btn.disabled = true;
            btn.innerHTML = 'â³ ìƒì„± ì¤‘...';
        }

        if (statusDiv) {
            statusDiv.classList.remove('hidden');
            statusDiv.className = 'status-indicator px-4 py-2 bg-purple-900/30 border-t border-gray-700 text-sm text-purple-300';
            statusDiv.textContent = 'ğŸ¬ ' + i18n.status_generating;
        }

        try {
            // [NEW] Use actual scene prompt for motion
            const basePrompt = p.prompt_en || p.prompt_content || p.prompt || "Cinematic scene";
            const motionPrompt = `${basePrompt}, cinematic slow motion, high quality, 4k`;

            const optVal = document.getElementById(`motion-opt-${index}`)?.value || "5.0|standard";
            const [duration, method] = optVal.split("|");

            const res = await fetch(`/api/projects/${projectId}/scenes/animate`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    scene_number: index + 1,
                    prompt: motionPrompt,
                    duration: parseFloat(duration),
                    method: method
                })
            });

            const result = await res.json();

            if (res.ok && result.status === 'ok') {
                // Success
                prompts[index].video_url = result.video_url;
                Utils.storage.set('imagePrompts', prompts);

                // Refresh UI
                drawPromptsUI(prompts);

                Utils.showToast('Motion generated', 'success');
            } else {
                throw new Error(result.detail || 'ìƒì„± ì‹¤íŒ¨');
            }
        } catch (e) {
            console.error(e);
            if (statusDiv) {
                statusDiv.className = 'status-indicator px-4 py-2 bg-red-900/30 border-t border-gray-700 text-sm text-red-400';
                statusDiv.textContent = 'âŒ ëª¨ì…˜ ìƒì„± ì‹¤íŒ¨: ' + e.message;
            }
            if (btn) {
                btn.disabled = false;
                btn.innerHTML = 'ğŸ¬ Motion';
            }
        }
    }

    // ========== Scene Analysis ==========

    let analyzedSceneCount = null; // Store analyzed scene count

    async function analyzeScenes() {
        const projectId = getCurrentProject();
        if (!projectId) {
            Utils.showToast('í”„ë¡œì íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
            return;
        }

        const btn = document.getElementById('analyzeSceneBtn');
        Utils.setLoading(btn, true, i18n.status_analyzing);

        try {
            const response = await fetch(`/api/projects/${projectId}/analyze-scenes`, {
                method: 'POST'
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            const result = await response.json();

            if (result.scene_count) {
                analyzedSceneCount = result.scene_count;

                // Display result next to button
                const resultBadge = document.getElementById('sceneCountBadge');
                if (resultBadge) {
                    resultBadge.textContent = `${result.scene_count} Scenes`;
                    resultBadge.classList.remove('hidden');
                }

                Utils.showToast(i18n.msg_scenes_analyzed.replace('{count}', result.scene_count), 'success');
            }
        } catch (e) {
            console.error('Scene analysis error:', e);
            Utils.showToast(`Scene ë¶„ì„ ì‹¤íŒ¨: ${e.message}`, 'error');
        } finally {
            Utils.setLoading(btn, false);
        }
    }


    // ìŠ¤íƒ€ì¼ ì„ íƒ í•¨ìˆ˜
    async function saveImageSettings(btn) {
        const projectId = getCurrentProject();
        if (!projectId) return;

        const originalHtml = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = `<span>ğŸ”„</span> ...`;

        try {
            const style = document.getElementById('imageStyle').value;
            const globalPrompt = document.getElementById('globalPrompt').value;

            const settings = {
                image_style: style,  // For autopilot sync
                image_style_prompt: style,
                character_ref_text: globalPrompt
            };

            const result = await API.project.saveSettings(projectId, settings);
            if (result.status === 'ok') {
                Utils.showToast('Settings saved', "success");
            } else {
                throw new Error(result.error || "ì €ì¥ ì‹¤íŒ¨");
            }
        } catch (e) {
            console.error(e);
            Utils.showToast("ì„¤ì • ì €ì¥ ì‹¤íŒ¨: " + e.message, "error");
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalHtml;
        }
    }

    function selectStyle(style, element) {
        // 1. Update Hidden Input
        document.getElementById('imageStyle').value = style;

        // 2. Visual Update
        // Reset all cards
        document.querySelectorAll('.style-card').forEach(card => {
            card.classList.remove('border-blue-600', 'ring-2', 'ring-blue-100');
            card.classList.add('border-transparent');

            const checkIcon = card.querySelector('.check-icon');
            if (checkIcon) checkIcon.classList.add('opacity-0');
        });

        // Highlight selected
        if (element) {
            element.classList.remove('border-transparent');
            element.classList.add('border-blue-600', 'ring-2', 'ring-blue-100');

            const checkIcon = element.querySelector('.check-icon');
            if (checkIcon) checkIcon.classList.remove('opacity-0');
        }
    }

    // í”„ë¡œì íŠ¸ ìƒíƒœ ë³µêµ¬ ì´ë²¤íŠ¸ ìˆ˜ì‹ 
    window.addEventListener('projectStateRestored', (e) => {
        const data = e.detail;

        // [RESET] Clear previous project data
        const gp = document.getElementById('globalPrompt');
        if (gp) gp.value = '';

        const preview = document.getElementById('charPreviewImg');
        const placeholder = document.getElementById('charPlaceholder');
        const charArea = document.getElementById('charPreviewArea');
        if (preview && placeholder && charArea) {
            preview.src = '';
            preview.classList.add('hidden');
            placeholder.classList.remove('hidden');
            charArea.classList.add('hidden');
        }

        // Clear Prompts List
        const promptsContainer = document.getElementById('promptsList');
        if (promptsContainer) promptsContainer.innerHTML = '';
        document.getElementById('resultSection').classList.add('hidden');
        prompts = [];

        // [NEW] Reload thumbnail reference explicitly when project context changes
        if (data) loadProjectThumbnail(data);

        // [RESTORE] Global Settings
        if (data && data.settings) {
            if (data.settings.character_ref_text && gp) {
                gp.value = data.settings.character_ref_text;
            }
            if (data.settings.character_ref_image_path && preview) {
                preview.src = data.settings.character_ref_image_path;
                preview.classList.remove('hidden');
                placeholder.classList.add('hidden');
                charArea.classList.remove('hidden');
                charArea.classList.add('flex');
            }

            // [NEW] Restore Image Style
            if (data.settings.image_style_prompt) {
                const styleId = data.settings.image_style_prompt;
                const element = document.querySelector(`.style-card[data-value="${styleId}"]`);
                if (element) {
                    selectStyle(styleId, element);
                    console.log("[StyleRestored]", styleId);
                }
            }
        }

        if (data && data.image_prompts && data.image_prompts.length > 0) {
            prompts = data.image_prompts;
            // Map legacy format if needed
            if (prompts[0] && !prompts[0].scene_title) {
                prompts = prompts.map(p => ({
                    ...p, // [FIX] Preserve fields
                    scene_title: p.scene_text || p.prompt_ko || `Scene ${p.scene_number || ''}`,
                    prompt_content: p.prompt_en || '',
                    image_url: p.image_url,
                    style_tags: ''
                }));
            }
            drawPromptsUI(prompts);
            document.getElementById('resultSection').classList.remove('hidden');
        }

        // [NEW] Restore Character Analysis
        if (data && data.characters && data.characters.length > 0) {
            Utils.storage.set('characterPrompts', data.characters);
            renderCharacters(data.characters);
            document.getElementById('characterResultContainer').classList.remove('hidden');
        } else {
            // [FIX] Clear data to prevent project cross-contamination
            // Do NOT load from local storage fallback here
            const container = document.getElementById('characterCards');
            if (container) container.innerHTML = '';
            document.getElementById('characterResultContainer').classList.add('hidden');
            Utils.storage.remove('characterPrompts');
        }
    });

    // Script Status Check
    async function checkScriptStatus() {
        const badge = document.getElementById('scriptStatusBadge');
        if (!badge) return;

        let hasScript = false;
        let topicText = '';

        const projectId = getCurrentProject();

        // 1. Check DB for Script & Topic
        if (projectId) {
            try {
                // Fetch Project Details for Topic
                const project = await API.project.get(projectId);
                if (project && project.topic) {
                    topicText = project.topic;
                }

                // Check Local Storage for script
                const localData = Utils.storage.get('fullScript');
                if (localData && localData.script) {
                    hasScript = true;
                } else {
                    // Check DB for script
                    const result = await API.project.getScript(projectId);
                    if (result && result.full_script) {
                        hasScript = true;
                        Utils.storage.set('fullScript', { script: result.full_script });
                    }
                }
            } catch (e) {
                console.error("Script/Topic check failed:", e);
            }
        }

        if (hasScript) {
            badge.className = "text-[10px] items-center gap-1 px-2 py-0.5 rounded-full bg-green-100 dark:bg-green-900/30 text-green-600 dark:text-green-400 font-normal hidden md:flex";
            // [Modified] Add topic text
            const label = "{{ t('script_ready') }}";
            const text = topicText ? `[${topicText}] ${label}` : label;
            badge.innerHTML = `<span>âœ…</span> ${text}`;
        } else {
            badge.className = "text-[10px] items-center gap-1 px-2 py-0.5 rounded-full bg-red-100 dark:bg-red-900/30 text-red-600 dark:text-red-400 font-normal hidden md:flex";
            const label = "{{ t('no_script') }}";
            const text = topicText ? `[${topicText}] ${label}` : label;
            badge.innerHTML = `<span>ğŸš«</span> ${text}`;
        }
    }

    // ì´ˆê¸° ë¡œë“œ ì‹œ DB ë° ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ í™•ì¸
    document.addEventListener('DOMContentLoaded', async () => {
        checkScriptStatus();
        loadProjectThumbnail();

        const projectId = getCurrentProject();
        const autoBtn = document.getElementById('autoGenBtn');
        let loadedFromDB = false;

        // 1. DBì—ì„œ í”„ë¡¬í”„íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸° (ê¶Œì¥)
        if (projectId) {
            try {
                const fullData = await API.project.getFull(projectId);

                // [NEW] Load Persistent Settings
                if (fullData.settings) {
                    if (fullData.settings.character_ref_text) {
                        const gp = document.getElementById('globalPrompt');
                        if (gp) gp.value = fullData.settings.character_ref_text;
                    }
                    if (fullData.settings.character_ref_image_path) {
                        const preview = document.getElementById('charPreviewImg');
                        const placeholder = document.getElementById('charPlaceholder');
                        if (preview) {
                            preview.src = fullData.settings.character_ref_image_path;
                            preview.classList.remove('hidden');
                            if (placeholder) placeholder.classList.add('hidden');
                            const area = document.getElementById('charPreviewArea');
                            if (area) {
                                area.classList.remove('hidden');
                                area.classList.add('flex');
                            }
                        }
                    }
                    if (fullData.settings.image_style_prompt) {
                        const styleId = fullData.settings.image_style_prompt;
                        const element = document.querySelector(`.style-card[data-value="${styleId}"]`);
                        if (element) {
                            selectStyle(styleId, element);
                        }
                    }
                }

                if (fullData && fullData.image_prompts && fullData.image_prompts.length > 0) {
                    // DB í¬ë§· -> í”„ë¡ íŠ¸ì—”ë“œ í¬ë§· ë§¤í•‘
                    prompts = fullData.image_prompts.map(p => ({
                        ...p, // [FIX] Preserve all DB fields (script_start, etc.)
                        scene_title: p.scene_text || p.prompt_ko || `Scene ${p.scene_number || ''}`,
                        prompt_content: p.prompt_en || '',
                        image_url: p.image_url,
                        style_tags: ''
                    }));

                    drawPromptsUI(prompts);
                    document.getElementById('resultSection').classList.remove('hidden');

                    if (autoBtn) {
                        autoBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                        autoBtn.disabled = false;
                    }
                    loadedFromDB = true;

                    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ë™ê¸°í™”
                    Utils.storage.set('imagePrompts', prompts);
                    console.log('Loaded prompts from DB:', prompts.length);

                    // [DEBUG REMOVED] Dump first prompt to textarea for diagnosis
                    // const gp = document.getElementById('globalPrompt');
                    // if (gp && prompts.length > 0) {
                    //     gp.value = "[DEBUG DATA]: " + JSON.stringify(prompts[0], null, 2) + "\n\n" + gp.value;
                    // }

                    Utils.showToast(`${prompts.length}ê°œì˜ í”„ë¡¬í”„íŠ¸ë¥¼ ì„œë²„ì—ì„œ ë³µêµ¬í–ˆìŠµë‹ˆë‹¤.`, 'success');
                } else {
                    console.log("No image prompts in DB");
                }
            } catch (e) {
                console.warn("Failed to load prompts from DB:", e);
            }
        }

        // 2. DBì— ì—†ìœ¼ë©´ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ í™•ì¸ (Fallback)
        if (!loadedFromDB) {
            const savedPrompts = Utils.storage.get('imagePrompts');
            if (savedPrompts && savedPrompts.length > 0) {
                prompts = savedPrompts;
                renderPrompts();
                document.getElementById('resultSection').classList.remove('hidden');

                if (autoBtn) {
                    autoBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    autoBtn.disabled = false;
                }
            }
        }
    });

    // ==========================================
    // Character Consistency Logic
    // ==========================================

    function previewCharImage(input) {
        if (input.files && input.files[0]) {
            const reader = new FileReader();
            reader.onload = function (e) {
                document.getElementById('charPreviewImg').src = e.target.result;
                document.getElementById('charPreviewName').textContent = input.files[0].name;

                const area = document.getElementById('charPreviewArea');
                area.classList.remove('hidden');
                area.classList.add('flex');

                // Clear checkbox if explicit upload
                document.getElementById('useThumbnailCheck').checked = false;
            };
            reader.readAsDataURL(input.files[0]);
        }
    }

    function clearCharImage() {
        document.getElementById('charUploadInput').value = '';

        const area = document.getElementById('charPreviewArea');
        area.classList.add('hidden');
        area.classList.remove('flex');

        document.getElementById('useThumbnailCheck').checked = true;
    }

    async function analyzeAndSetConsistency() {
        const btn = document.getElementById('analyzeBtn');
        const uploadInput = document.getElementById('charUploadInput');
        const useThumb = document.getElementById('useThumbnailCheck').checked;

        let formData = new FormData();
        let hasSource = false;
        let pid = getCurrentProject(); // Define pid here for broader scope

        if (!pid) return Utils.showToast('í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”', 'warning');
        formData.append('project_id', pid); // Append project_id here

        if (uploadInput.files && uploadInput.files[0]) {
            formData.append('file', uploadInput.files[0]);
            hasSource = true;
        } else if (useThumb) {
            try {
                // Fetch settings for thumbnail path
                const fullData = await API.project.getFull(pid);
                // Try to find thumbnail path in settings or project root
                const settings = fullData.settings || {};
                const thumb = settings.thumbnail_path || fullData.project?.thumbnail_path;

                if (thumb) {
                    formData.append('image_path', thumb);
                    hasSource = true;
                } else {
                    return Utils.showToast('ì¸ë„¤ì¼ ì´ë¯¸ì§€ê°€ í™•ì¸ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¨¼ì € ì¸ë„¤ì¼ì„ ìƒì„±í•˜ê±°ë‚˜ ì´ë¯¸ì§€ë¥¼ ì§ì ‘ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.', 'warning');
                }
            } catch (e) {
                console.error(e);
                return Utils.showToast('í”„ë¡œì íŠ¸ ì •ë³´ ë¡œë“œ ë¡œë“œ ì‹¤íŒ¨', 'error');
            }
        }

        if (!hasSource) {
            return Utils.showToast('ì´ë¯¸ì§€ë¥¼ ì„ íƒí•˜ê±°ë‚˜ "ì¸ë„¤ì¼ ì‚¬ìš©"ì„ ì²´í¬í•´ì£¼ì„¸ìš”.', 'warning');
        }

        Utils.setLoading(btn, true, 'ì´ë¯¸ì§€ ë¶„ì„ ì¤‘... (Vision AI)');
        try {
            const result = await API.image.analyzeCharacter(formData);

            if (result.description) {
                const textArea = document.getElementById('globalPrompt');
                const currentVal = textArea.value;

                // Formatted prompt
                const newText = `[Character Visual Reference]: ${result.description}`;

                if (currentVal.includes('[Character Visual Reference]:')) {
                    // Alert user it's appended
                    textArea.value = currentVal + "\n\n" + newText;
                } else {
                    textArea.value = (currentVal ? currentVal + "\n\n" : "") + newText;
                }

                // [NEW] Save to DB
                if (pid) {
                    API.project.updateSetting(pid, 'character_ref_text', textArea.value).then(() => {
                        console.log("Character ref text saved");
                    });

                    if (result.image_url) {
                        API.project.updateSetting(pid, 'character_ref_image_path', result.image_url).then(() => {
                            console.log("Character ref image saved:", result.image_url);
                            // Also update preview if needed (though user just uploaded it)
                            // But maybe cleaner to use server URL? 
                            // We already showed preview via FileReader. No need to reload.
                            const preview = document.getElementById('charPreviewImg');
                            const placeholder = document.getElementById('charPlaceholder');
                            const area = document.getElementById('charPreviewArea');
                            if (preview && placeholder && area) {
                                preview.src = result.image_url;
                                preview.classList.remove('hidden');
                                placeholder.classList.add('hidden');
                                area.classList.remove('hidden');
                                area.classList.add('flex');
                            }
                        });
                    }
                }

                Utils.showToast('âœ… ìºë¦­í„° ì™¸í˜• ë¶„ì„ì´ ì™„ë£Œë˜ì–´ ì„¤ì •ì— ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤. (ìë™ ì €ì¥ë¨)', 'success');
            } else {
                const errMsg = result.error || 'ë¶„ì„ ê²°ê³¼ ì—†ìŒ';
                Utils.showToast('ë¶„ì„ ì‹¤íŒ¨: ' + errMsg, 'error');
            }
        } catch (e) {
            Utils.showToast('ë¶„ì„ ì¤‘ í†µì‹  ì˜¤ë¥˜: ' + e.message, 'error');
            console.error(e);
        } finally {
            Utils.setLoading(btn, false);
        }
    }
    async function loadProjectThumbnail(providedData = null) {
        const pid = getCurrentProject();
        if (!pid) return;

        try {
            let fullData = providedData;
            if (!fullData) {
                fullData = await API.project.getFull(pid);
            }

            let thumb = fullData.settings?.thumbnail_url || fullData.project?.thumbnail_url;
            const thumbPath = fullData.settings?.thumbnail_path || fullData.project?.thumbnail_path;

            // [Fallback] If URL is missing, try to construct likely path
            if (!thumb) {
                // 1. If path exists and contains 'static', use it
                if (thumbPath && thumbPath.includes('static')) {
                    const parts = thumbPath.split('static');
                    // Handle regex slash/backslash safely
                    const relativePath = parts[1].replace(/\\/g, '/');
                    thumb = '/static' + relativePath;
                }
                // 2. Force Try Standard Path (Cache Busting) even if path is C:\... or missing
                else {
                    thumb = `/static/projects/${pid}/thumbnail.png`;
                    console.log("Forcing standard thumbnail path:", thumb);
                }
            }

            const imgEl = document.getElementById('currentProjectThumbnail');
            const placeholder = document.getElementById('thumbPlaceholder');

            if (imgEl && thumb) {
                // Cache busting
                const srcWithCache = thumb.startsWith('data:') ? thumb : `${thumb}?t=${new Date().getTime()}`;

                imgEl.src = srcWithCache;

                imgEl.classList.remove('opacity-50');
                imgEl.style.opacity = 1;
                if (placeholder) placeholder.classList.add('hidden');

                // Error handler with JPG fallback
                imgEl.onerror = function () {
                    if (this.src.includes('.png') && !this.src.includes('retry')) {
                        console.warn("Retrying with .jpg fallback...");
                        this.src = this.src.replace('.png', '.jpg') + '&retry=1';
                    } else {
                        console.warn("Thumbnail failed to load at:", this.src);
                        this.style.opacity = 0;
                        if (placeholder) placeholder.classList.remove('hidden');
                    }
                };
            } else {
                console.warn("Thumbnail URL not found in project data.");
                if (imgEl) {
                    imgEl.style.opacity = 0;
                    imgEl.src = '';
                }
                if (placeholder) placeholder.classList.remove('hidden');
            }
        } catch (e) {
            console.error("Failed to load thumbnail for reference UI", e);
        }
    }

    // [NEW] App Mode Logic
    async function applyAppMode() {
        try {
            const res = await fetch('/api/settings');
            const settings = await res.json();
            const mode = settings.app_mode || 'longform';

            const r169 = document.getElementById('ratio-16-9');
            const r11 = document.getElementById('ratio-1-1');
            const r916 = document.getElementById('ratio-9-16');
            const r34 = document.getElementById('ratio-3-4');

            // Reset all to visible first (or hidden then toggle)
            // But Tailwind 'hidden' class is what we toggle

            if (mode === 'shorts') {
                // Show 9:16, 3:4. Hide 16:9, 1:1
                if (r169) r169.classList.add('hidden');
                if (r11) r11.classList.add('hidden');
                if (r916) r916.classList.remove('hidden');
                if (r34) r34.classList.remove('hidden');

                // Default to 3:4
                const radio34 = document.querySelector('input[value="3:4"]');
                if (radio34) radio34.checked = true;

                // [NEW] Adjust Thumbnail Reference for Vertical
                const thumbRef = document.getElementById('thumbnailReferenceContainer');
                if (thumbRef) {
                    thumbRef.classList.remove('aspect-video');
                    thumbRef.classList.add('aspect-[9/16]');
                }

            } else {
                // Longform
                // Hide 9:16. Show 16:9, 1:1, 3:4(optional? User said 'remove 9:16').
                // Let's hide 9:16 only as requested.
                if (r916) r916.classList.add('hidden');

                if (r169) r169.classList.remove('hidden');
                if (r11) r11.classList.remove('hidden');
                if (r34) r34.classList.remove('hidden');

                // Default to 16:9 if 9:16 was somehow checked or just ensure 16:9 is default
                const radio169 = document.querySelector('input[value="16:9"]');
                if (radio169 && !document.querySelector('input[name="aspectRatio"]:checked')) {
                    radio169.checked = true;
                }
                if (radio169) radio169.checked = true;

                // [NEW] Restor Thumbnail Reference to 16:9
                const thumbRef = document.getElementById('thumbnailReferenceContainer');
                if (thumbRef) {
                    thumbRef.classList.remove('aspect-[9/16]');
                    thumbRef.classList.add('aspect-video');
                }
            }

            console.log("App Mode Applied:", mode);

        } catch (e) {
            console.error("Failed to apply app mode:", e);
        }
    }

    // [NEW] Dynamically load styles
    async function loadStyles() {
        const grid = document.getElementById('styleSelectorGrid');
        if (!grid) return;

        try {
            const res = await fetch('/api/settings/style-presets');
            const presets = await res.json();

            // Default mappings for display names
            const displayNames = {
                'realistic': 'ì‚¬ì‹¤ì ì¸\n(Realistic)',
                'anime': 'ì• ë‹ˆë©”ì´ì…˜\n(Anime)',
                'cinematic': 'ì‹œë„¤ë§ˆí‹±\n(Cinematic)',
                'cartoon': 'ì¹´íˆ°\n(Cartoon)',
                'oil_painting': 'ìœ í™”\n(Oil Painting)',
                'watercolor': 'ìˆ˜ì±„í™”\n(Watercolor)',
                'sketch': 'ìŠ¤ì¼€ì¹˜\n(Sketch)',
                'pixel_art': 'í”½ì…€ì•„íŠ¸\n(Pixel Art)',
                '3d': '3D ë Œë”\n(3D Render)',
                'webtoon': 'ì›¹íˆ°\n(Webtoon)',
                'ghibli': 'ì§€ë¸Œë¦¬\n(Ghibli)',
                'wimpy': 'ìœ”í”¼í‚¤ë“œ\n(Wimpy Kid)',
                'minimal': 'ë¯¸ë‹ˆë©€\n(Minimal)'
            };

            grid.innerHTML = Object.entries(presets).map(([key, data]) => {
                const imageUrl = (typeof data === 'object' && data.image_url) ? data.image_url : `/static/img/styles/style_${key}.png`;
                const displayName = displayNames[key] || key;
                const [krName, enName] = displayName.includes('\n') ? displayName.split('\n') : [displayName, key];

                // Check if currently selected
                const currentStyle = document.getElementById('imageStyle').value;
                const isSelected = key === currentStyle;

                return `
                <div class="style-card relative cursor-pointer border-2 ${isSelected ? 'border-blue-600' : 'border-transparent'} hover:border-blue-300 rounded-lg overflow-hidden shadow-sm hover:shadow-md transition-all"
                    onclick="selectStyle('${key}', this)" data-value="${key}">
                    <div class="aspect-square bg-gradient-to-br from-gray-100 to-gray-200 dark:from-gray-700 dark:to-gray-800 overflow-hidden flex items-center justify-center">
                        <img src="${imageUrl}"
                            class="w-full h-full object-cover transition-transform duration-500 hover:scale-110"
                            onerror="this.style.display='none'; this.parentElement.innerHTML='<div class=\'text-center p-2\'><div class=\'text-2xl mb-1\'>ğŸ¨</div><div class=\'text-xs text-gray-600 dark:text-gray-300 font-medium\'>${krName.replace(/\n/g, ' ')}</div></div>';">
                    </div>
                    <div class="p-2 text-center bg-white dark:bg-gray-800">
                        <span class="text-xs font-bold block dark:text-white truncate">${krName}</span>
                        <span class="text-[10px] text-gray-500 truncate">${enName.replace(/[()]/g, '')}</span>
                    </div>
                    <div
                        class="check-icon absolute top-2 right-2 w-5 h-5 bg-blue-600 rounded-full flex items-center justify-center text-white text-xs shadow-sm ${isSelected ? '' : 'opacity-0'}">
                        âœ“</div>
                </div>
                `;
            }).join('');

        } catch (e) {
            console.error("Failed to load styles:", e);
        }
    }

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => {
        applyAppMode();
        loadStyles(); // [NEW]
        // Removed auto-load of characterPrompts to prevent data leakage between projects
    });
</script>
{% endblock %}