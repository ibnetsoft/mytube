{% extends "base.html" %}

{% block content %}


<div class="h-[calc(100vh-80px)] overflow-y-auto p-4 custom-scrollbar">
    <!-- Header with Actions -->
    <div
        class="flex justify-between items-center mb-4 sticky top-0 bg-gray-50 dark:bg-gray-900 z-10 py-2 border-b border-gray-200 dark:border-gray-700">
        <h2 class="text-lg font-bold flex items-center gap-2">
            <span>⚙️ 환경 설정</span>
        </h2>
        <div class="flex gap-2">
            <button onclick="loadAllSettings()" class="btn-secondary py-1.5 px-3 text-xs flex items-center gap-1">
                <span>🔄</span> 새로고침
            </button>
            <button onclick="saveAllSettings()"
                class="btn-primary py-1.5 px-4 text-xs font-bold shadow-sm flex items-center gap-1">
                <span>💾</span> 변경사항 저장
            </button>
        </div>
    </div>

    <!-- Tab Navigation -->
    <div class="mb-4 border-b border-gray-200 dark:border-gray-700">
        <div class="flex space-x-1 overflow-x-auto custom-scrollbar">
            <button onclick="switchTab('api')" id="tab-api" class="tab-button active">
                🔑 API 설정
            </button>
            <button onclick="switchTab('content')" id="tab-content" class="tab-button">
                🎨 콘텐츠 설정
            </button>
            <button onclick="switchTab('image-styles')" id="tab-image-styles" class="tab-button">
                🖼️ 이미지 스타일
            </button>
            <button onclick="switchTab('script-styles')" id="tab-script-styles" class="tab-button">
                📝 대본 스타일
            </button>
            <button onclick="switchTab('thumbnail-styles')" id="tab-thumbnail-styles" class="tab-button">
                🖼️ 썸네일 스타일
            </button>
            <button onclick="switchTab('data')" id="tab-data" class="tab-button">
                🗂️ 데이터 관리
            </button>
            <button onclick="switchTab('webtoon')" id="tab-webtoon" class="tab-button">
                🎨 웹툰 설정
            </button>
        </div>
    </div>

    <!-- Tab Content Container -->
    <div id="settings-content">
        <!-- API Settings Tab -->
        <div id="tab-content-api" class="tab-content active">
            <div class="grid grid-cols-1 xl:grid-cols-12 gap-4">
                <!-- Left Column: API Keys & Connections (5/12) -->
                <div class="xl:col-span-5 space-y-4">

                    <!-- API Keys & Connectivity -->
                    <div class="card p-3 shadow-sm border border-gray-200 dark:border-gray-700">
                        <h3
                            class="font-bold text-sm text-gray-800 dark:text-gray-100 mb-3 flex items-center justify-between">
                            <span>🔑 API 인증 및 연결 상태</span>
                            <a href="https://console.cloud.google.com/apis/credentials" target="_blank"
                                class="text-[10px] text-blue-500 hover:underline">Console 바로가기 ↗</a>
                        </h3>

                        <div class="space-y-3">
                            <!-- YouTube -->
                            <div
                                class="bg-gray-50 dark:bg-gray-800/50 rounded-md p-2 border border-gray-100 dark:border-gray-700">
                                <div class="flex items-center justify-between mb-1">
                                    <label
                                        class="text-xs font-bold text-gray-700 dark:text-white flex items-center gap-1">
                                        <span>📺 YouTube Data API</span>
                                        <span id="youtubeStatus" class="text-[10px] font-normal text-gray-400"></span>
                                    </label>
                                    <span id="youtubeConnectionStatus"
                                        class="text-[10px] bg-gray-200 dark:bg-gray-700 px-1.5 rounded text-gray-500">대기</span>
                                </div>
                                <div class="flex gap-1">
                                    <input type="password" id="youtubeApiKey"
                                        class="flex-1 input-field text-xs py-1 px-2 h-8" placeholder="API Key 입력">
                                    <button onclick="toggleKeyVisibility('youtubeApiKey')"
                                        class="btn-secondary px-2 h-8 text-xs">👁️</button>
                                </div>
                                <p id="youtubeKeyMasked" class="text-[10px] text-gray-400 mt-0.5 truncate h-3"></p>
                            </div>

                            <!-- Gemini -->
                            <div
                                class="bg-gray-50 dark:bg-gray-800/50 rounded-md p-2 border border-gray-100 dark:border-gray-700">
                                <div class="flex items-center justify-between mb-1">
                                    <label
                                        class="text-xs font-bold text-gray-700 dark:text-white flex items-center gap-1">
                                        <span>🤖 Gemini API</span>
                                        <span id="geminiStatus" class="text-[10px] font-normal text-gray-400"></span>
                                    </label>
                                    <span id="geminiConnectionStatus"
                                        class="text-[10px] bg-gray-200 dark:bg-gray-700 px-1.5 rounded text-gray-500">대기</span>
                                </div>
                                <div class="flex gap-1">
                                    <input type="password" id="geminiApiKey"
                                        class="flex-1 input-field text-xs py-1 px-2 h-8" placeholder="API Key 입력">
                                    <button onclick="toggleKeyVisibility('geminiApiKey')"
                                        class="btn-secondary px-2 h-8 text-xs">👁️</button>
                                </div>
                                <p id="geminiKeyMasked" class="text-[10px] text-gray-400 mt-0.5 truncate h-3"></p>
                            </div>

                            <!-- ElevenLabs -->
                            <div
                                class="bg-gray-50 dark:bg-gray-800/50 rounded-md p-2 border border-gray-100 dark:border-gray-700">
                                <div class="flex items-center justify-between mb-1">
                                    <label
                                        class="text-xs font-bold text-gray-700 dark:text-white flex items-center gap-1">
                                        <span>🔊 ElevenLabs API</span>
                                        <span class="text-[10px] text-gray-400 font-normal">(선택)</span>
                                        <span id="elevenlabsStatus"
                                            class="text-[10px] font-normal text-gray-400"></span>
                                    </label>
                                    <span id="elevenlabsConnectionStatus"
                                        class="text-[10px] bg-gray-200 dark:bg-gray-700 px-1.5 rounded text-gray-500">미설정</span>
                                </div>
                                <div class="flex gap-1">
                                    <input type="password" id="elevenlabsApiKey"
                                        class="flex-1 input-field text-xs py-1 px-2 h-8" placeholder="API Key 입력">
                                    <button onclick="toggleKeyVisibility('elevenlabsApiKey')"
                                        class="btn-secondary px-2 h-8 text-xs">👁️</button>
                                </div>
                                <p id="elevenlabsKeyMasked" class="text-[10px] text-gray-400 mt-0.5 truncate h-3">
                                </p>

                                <!-- [NEW] Voice List Toggle -->
                                <div id="elevenVoicesContainer"
                                    class="mt-2 pt-2 border-t border-dashed border-gray-200 dark:border-gray-700 hidden">
                                    <div class="flex justify-between items-center mb-2">
                                        <span class="text-[10px] font-bold text-gray-600 dark:text-gray-400">내 계정 목소리
                                            (VoiceLab)</span>
                                        <button onclick="refreshElevenVoices()"
                                            class="text-[9px] bg-blue-50 text-blue-600 px-1.5 py-0.5 rounded hover:bg-blue-100 hover:text-blue-800 transition-colors">
                                            🔄 동기화 (Sync)
                                        </button>
                                    </div>
                                    <div id="elevenVoiceList"
                                        class="bg-white dark:bg-gray-900 border border-gray-100 dark:border-gray-700 rounded p-1 max-h-32 overflow-y-auto custom-scrollbar space-y-0.5">
                                        <p class="text-[9px] text-gray-400 text-center py-2">불러오는 중...</p>
                                    </div>
                                    <p class="text-[9px] text-gray-400 mt-1 leading-tight">
                                        * ElevenLabs 웹사이트에서 목소리를 추가(Add/Clone)하시면 이곳에 자동 반영됩니다.
                                    </p>
                                </div>
                                <div class="text-right mt-1">
                                    <button onclick="toggleVoiceList(this)"
                                        class="text-[10px] text-blue-500 hover:text-blue-700 hover:underline transition-colors">
                                        목소리 목록 보기 ▼
                                    </button>
                                </div>
                            </div>

                            <!-- Replicate -->
                            <div
                                class="bg-gray-50 dark:bg-gray-800/50 rounded-md p-2 border border-gray-100 dark:border-gray-700">
                                <div class="flex items-center justify-between mb-1">
                                    <label
                                        class="text-xs font-bold text-gray-700 dark:text-white flex items-center gap-1">
                                        <span>🚀 Replicate API</span>
                                        <span class="text-[10px] text-gray-400 font-normal">(AI영상)</span>
                                        <span id="replicateStatus" class="text-[10px] font-normal text-gray-400"></span>
                                    </label>
                                    <span id="replicateConnectionStatus"
                                        class="text-[10px] bg-gray-200 dark:bg-gray-700 px-1.5 rounded text-gray-500">미설정</span>
                                </div>
                                <div class="flex gap-1">
                                    <input type="password" id="replicateApiKey"
                                        class="flex-1 input-field text-xs py-1 px-2 h-8" placeholder="API Token 입력">
                                    <button onclick="toggleKeyVisibility('replicateApiKey')"
                                        class="btn-secondary px-2 h-8 text-xs">👁️</button>
                                </div>
                                <p id="replicateKeyMasked" class="text-[10px] text-gray-400 mt-0.5 truncate h-3">
                                </p>
                            </div>

                            <!-- TopView -->
                            <div
                                class="bg-gray-50 dark:bg-gray-800/50 rounded-md p-2 border border-gray-100 dark:border-gray-700">
                                <div class="flex items-center justify-between mb-1">
                                    <label
                                        class="text-xs font-bold text-gray-700 dark:text-white flex items-center gap-1">
                                        <span>🎬 TopView API</span>
                                        <span class="text-[10px] text-gray-400 font-normal">(Commerce)</span>
                                        <span id="topviewStatus" class="text-[10px] font-normal text-gray-400"></span>
                                    </label>
                                    <span id="topviewConnectionStatus"
                                        class="text-[10px] bg-gray-200 dark:bg-gray-700 px-1.5 rounded text-gray-500">미설정</span>
                                </div>
                                <div class="flex gap-1">
                                    <input type="password" id="topviewApiKey"
                                        class="flex-1 input-field text-xs py-1 px-2 h-8" placeholder="API Key 입력">
                                    <button onclick="toggleKeyVisibility('topviewApiKey')"
                                        class="btn-secondary px-2 h-8 text-xs">👁️</button>
                                </div>
                                <p id="topviewKeyMasked" class="text-[10px] text-gray-400 mt-0.5 truncate h-3">
                                </p>
                            </div>

                            <!-- Akool -->
                            <div
                                class="bg-gray-50 dark:bg-gray-800/50 rounded-md p-2 border border-gray-100 dark:border-gray-700">
                                <div class="flex items-center justify-between mb-1">
                                    <label
                                        class="text-xs font-bold text-gray-700 dark:text-white flex items-center gap-1">
                                        <span>🎨 Akool API</span>
                                        <span class="text-[10px] text-gray-400 font-normal">(Avatar/Creative)</span>
                                        <span id="akoolClientIdStatus"
                                            class="text-[10px] font-normal text-gray-400"></span>
                                        <span id="akoolClientSecretStatus"
                                            class="text-[10px] font-normal text-gray-400"></span>
                                    </label>
                                    <span id="akoolConnectionStatus"
                                        class="text-[10px] bg-gray-200 dark:bg-gray-700 px-1.5 rounded text-gray-500"></span>
                                </div>

                                <!-- Client ID -->
                                <div class="flex gap-1 mb-1">
                                    <input type="password" id="akoolClientId"
                                        class="flex-1 input-field text-xs py-1 px-2 h-8" placeholder="Client ID 입력">
                                    <button onclick="toggleKeyVisibility('akoolClientId')"
                                        class="btn-secondary px-2 h-8 text-xs">👁️</button>
                                </div>
                                <p id="akoolIdMasked" class="text-[9px] text-gray-400 mb-2 truncate h-3"></p>

                                <!-- Client Secret -->
                                <div class="flex gap-1">
                                    <input type="password" id="akoolClientSecret"
                                        class="flex-1 input-field text-xs py-1 px-2 h-8" placeholder="Client Secret 입력">
                                    <button onclick="toggleKeyVisibility('akoolClientSecret')"
                                        class="btn-secondary px-2 h-8 text-xs">👁️</button>
                                </div>
                                <p id="akoolSecretMasked" class="text-[9px] text-gray-400 mt-0.5 truncate h-3"></p>
                            </div>
                        </div>

                        <div
                            class="mt-3 pt-3 border-t border-gray-100 dark:border-gray-700 flex justify-between text-[10px]">
                            <a href="https://aistudio.google.com/apikey" target="_blank"
                                class="text-blue-500 hover:underline flex items-center gap-1">
                                🔑 Gemini 키 발급
                            </a>
                            <a href="https://elevenlabs.io/app/settings/api-keys" target="_blank"
                                class="text-gray-500 hover:underline flex items-center gap-1">
                                🔑 ElevenLabs 키 발급
                            </a>
                            <a href="https://replicate.com/account/api-tokens" target="_blank"
                                class="text-gray-500 hover:underline flex items-center gap-1">
                                🔑 Replicate 키 발급
                            </a>
                            <a href="https://www.topview.ai/dashboard/api-settings" target="_blank"
                                class="text-blue-500 hover:underline flex items-center gap-1">
                                🔑 TopView 키 발급
                            </a>
                            <a href="https://akool.com/dashboard/api" target="_blank"
                                class="text-gray-500 hover:underline flex items-center gap-1">
                                🔑 Akool 키 발급
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- End API Tab -->

        <!-- Content Settings Tab -->
        <div id="tab-content-content" class="tab-content">
            <div class="grid grid-cols-1 gap-4">

                <!-- Channel Management -->
                <div class="card p-3 shadow-sm border border-gray-200 dark:border-gray-700">
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="font-bold text-sm text-gray-800 dark:text-gray-100 flex items-center gap-2">
                            <span>📺 유튜브 채널 관리</span>
                            <span class="text-[9px] bg-red-500 text-white px-1.5 py-0.5 rounded-full">BETA</span>
                        </h3>
                        <span class="text-[10px] text-gray-400">업로드 대상 채널</span>
                    </div>
                    <div id="channelList"
                        class="space-y-2 mb-3 max-h-40 overflow-y-auto custom-scrollbar bg-gray-50 dark:bg-gray-800/30 rounded p-1">
                        <!-- Loaded via JS -->
                        <p class="text-gray-400 text-xs text-center py-4">등록된 채널이 없습니다.</p>
                    </div>
                    <div
                        class="flex gap-2 p-2 bg-gray-50 dark:bg-gray-800 rounded border border-gray-100 dark:border-gray-700">
                        <input type="text" id="newChannelName" class="input-field text-xs flex-1 h-8"
                            placeholder="채널명 (내 브이로그)">
                        <input type="text" id="newChannelHandle" class="input-field text-xs w-24 h-8"
                            placeholder="@handle">
                        <button onclick="addChannel()"
                            class="btn-primary py-0 px-3 text-xs h-8 whitespace-nowrap">추가</button>
                    </div>
                    <input type="text" id="newChannelDesc" class="input-field text-xs w-full mt-2 h-7"
                        placeholder="채널 설명 (선택)">
                </div>

                <!-- Content Settings (Voice & Scripts) -->
                <div class="card p-3 shadow-sm border border-gray-200 dark:border-gray-700">
                    <h3 class="font-bold text-sm text-gray-800 dark:text-gray-100 mb-3">🎨 콘텐츠 생성 설정</h3>

                    <!-- Platform Mode -->
                    <div class="mb-5 border-b border-gray-100 dark:border-gray-700 pb-4">
                        <label class="text-xs font-bold text-gray-700 dark:text-white mb-2 block">🖥️ 플랫폼 모드</label>
                        <input type="hidden" id="appMode" value="longform">
                        <div class="flex bg-gray-100 dark:bg-gray-800 rounded-lg p-1 w-fit">
                            <button id="btnModeLong" onclick="setAppMode('longform')"
                                class="px-4 py-1.5 rounded-md text-xs font-bold transition-all bg-white dark:bg-gray-600 shadow text-gray-800 dark:text-white">
                                🎞️ 롱폼 (기본)
                            </button>
                            <button id="btnModeShort" onclick="setAppMode('shorts')"
                                class="px-4 py-1.5 rounded-md text-xs font-medium text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200">
                                📱 쇼츠
                            </button>
                            <button id="btnModeWebtoon" onclick="setAppMode('webtoon')"
                                class="px-4 py-1.5 rounded-md text-xs font-medium text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200">
                                🖌️ 웹툰
                            </button>
                            <button id="btnModeCommerce" onclick="setAppMode('commerce')"
                                class="px-4 py-1.5 rounded-md text-xs font-medium text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200">
                                🛍️ 커머스
                            </button>
                        </div>
                        <div class="mt-2 space-y-1">
                            <p class="text-[10px] text-gray-500 dark:text-gray-400">
                                * 모드를 변경하면 메뉴 구성과 영상 생성 설정이 해당 포맷에 최적화됩니다.
                            </p>
                            <p class="text-[10px] text-orange-600 dark:text-orange-400 font-medium">
                                ⚠️ 모드 전환 시 현재 프로젝트 선택이 해제되고 모든 데이터가 초기화됩니다.
                            </p>
                        </div>
                    </div>

                    <!-- [NEW] Template Image (Overlay) -->
                    <div class="mb-5 border-b border-gray-100 dark:border-gray-700 pb-4">
                        <label
                            class="text-xs font-bold text-gray-700 dark:text-white mb-2 flex justify-between items-center">
                            <span>🖼️ 템플릿 이미지 (9:16 오버레이)</span>
                            <span class="text-[10px] text-gray-400 font-normal">.png 투명 배경 권장</span>
                        </label>

                        <div class="flex items-start gap-4">
                            <!-- Preview -->
                            <div
                                class="w-16 h-28 bg-gray-100 dark:bg-gray-800 rounded border border-gray-200 dark:border-gray-700 overflow-hidden flex items-center justify-center relative group">
                                <img id="templatePreview" src="" class="w-full h-full object-cover hidden">
                                <div id="templatePlaceholder" class="text-gray-300 text-[10px] text-center p-1">No
                                    Image
                                </div>
                                <button onclick="deleteTemplate()" id="btnDeleteTemplate"
                                    class="hidden absolute inset-0 bg-black/50 text-white flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                                    🗑️
                                </button>
                            </div>

                            <!-- Upload Control -->
                            <div class="flex-1">
                                <input type="file" id="templateImageInput" accept="image/png, image/jpeg" class="hidden"
                                    onchange="uploadTemplate(this)">
                                <button onclick="document.getElementById('templateImageInput').click()"
                                    class="btn-secondary w-full py-2 text-xs mb-2 border-dashed border-2">
                                    📁 이미지 업로드 (Upload)
                                </button>
                                <p class="text-[10px] text-gray-400 leading-tight">
                                    * 쇼츠 영상 생성 시, 전체 프레임 위에 오버레이로 적용됩니다.<br>
                                    * 프레임, 로고, 테두리 장식 등에 활용하세요.
                                </p>
                            </div>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <!-- Voice -->
                        <div>
                            <label class="text-xs font-bold text-gray-700 dark:text-white mb-2 block">🗣️ 기본 목소리
                                (Gemini)</label>
                            <div class="grid grid-cols-2 gap-2 mb-2">
                                <select id="geminiVoice" class="input-field text-xs h-8"></select>
                                <select id="geminiLanguage" class="input-field text-xs h-8"></select>
                            </div>
                            <textarea id="geminiStylePrompt" rows="2" class="input-field w-full text-xs"
                                placeholder="음성 스타일 (예: 차분하고 신뢰감 있는 톤)"></textarea>
                        </div>

                        <!-- Script Prompts -->
                        <div class="space-y-4">
                            <!-- [NEW] Main Script Writing Prompt -->
                            <div
                                class="bg-purple-50 dark:bg-purple-900/20 rounded-lg p-3 border border-purple-200 dark:border-purple-800">
                                <label
                                    class="text-xs font-bold text-purple-700 dark:text-purple-300 mb-2 flex items-center gap-2">
                                    <span>✍️ 대본 작성 마스터 프롬프트</span>
                                    <span class="text-[10px] text-purple-500 dark:text-purple-400 font-normal">대본 생성
                                        시 AI에게
                                        전달되는 핵심 지침</span>
                                </label>
                                <textarea id="promptScriptMaster" class="input-field w-full text-xs font-mono" rows="8"
                                    placeholder="대본 작성 시 AI에게 전달할 마스터 프롬프트를 입력하세요..."></textarea>
                                <div class="flex justify-between items-center mt-2">
                                    <p class="text-[10px] text-purple-500">* 이 프롬프트는 모든 대본 생성에 적용됩니다.</p>
                                    <button onclick="resetMasterPrompt()"
                                        class="text-[10px] text-purple-600 hover:underline">기본값으로 초기화</button>
                                </div>
                            </div>

                            <div>
                                <label class="text-xs font-bold text-gray-700 dark:text-white mb-1 block">📜 시니어 사연
                                    스타일
                                    프롬프트 (New)</label>
                                <textarea id="promptSeniorStory" class="input-field w-full text-xs" rows="3"
                                    placeholder="중장년층 공감 사연 톤앤매너 지침..."></textarea>
                            </div>
                            <div>
                                <label class="text-xs font-bold text-gray-700 dark:text-white mb-1 block">📜 옛날 이야기
                                    스타일
                                    프롬프트</label>
                                <textarea id="promptStory" class="input-field w-full text-xs" rows="2"
                                    placeholder="구연동화 톤앤매너 지침..."></textarea>
                            </div>
                            <div>
                                <label class="text-xs font-bold text-gray-700 dark:text-white mb-1 block">📜 뉴스 스타일
                                    프롬프트</label>
                                <textarea id="promptNews" class="input-field w-full text-xs" rows="2"
                                    placeholder="뉴스 톤앤매너 지침..."></textarea>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- End Content Tab -->

        <!-- Image Styles Tab -->
        <div id="tab-content-image-styles" class="tab-content">
            <div class="card p-3 shadow-sm border border-gray-200 dark:border-gray-700">
                <h3 class="font-bold text-sm text-gray-800 dark:text-gray-100 mb-3 flex items-center justify-between">
                    <span>🎨 이미지 스타일 프롬프트 설정</span>
                    <button onclick="loadStylePresets()" class="text-[10px] text-blue-500 hover:underline">🔄 서버
                        동기화</button>
                </h3>

                <!-- [NEW] Add Custom Style Form -->
                <div
                    class="bg-blue-50 dark:bg-blue-900/10 p-3 rounded-lg border border-blue-100 dark:border-blue-800 mb-4">
                    <h4 class="text-xs font-bold text-blue-700 dark:text-blue-300 mb-2">➕ 새 스타일 추가 (사용자 정의)</h4>
                    <div class="space-y-2">
                        <div class="flex gap-2">
                            <input type="text" id="customStyleName" class="input-field flex-1 text-xs"
                                placeholder="스타일 이름 (예: my_sketch, dark_fantasy)">
                            <button onclick="document.getElementById('customStyleImage').click()"
                                class="btn-secondary px-3 py-1.5 text-xs whitespace-nowrap">
                                🖼️ 이미지 업로드
                            </button>
                            <input type="file" id="customStyleImage" accept="image/*" class="hidden"
                                onchange="document.getElementById('customStyleImgName').textContent = this.files[0]?.name || ''">
                        </div>
                        <p id="customStyleImgName" class="text-[10px] text-gray-500 pl-1 h-3 truncate"></p>

                        <textarea id="customStylePrompt" class="input-field w-full text-xs h-16"
                            placeholder="스타일 프롬프트 (예: highly detailed, cinematic lighting, 8k resolution)"></textarea>

                        <div class="flex justify-end">
                            <button onclick="addCustomStylePreset()"
                                class="btn-primary px-4 py-1.5 text-xs font-bold bg-blue-600 hover:bg-blue-700">
                                추가하기
                            </button>
                        </div>
                    </div>
                </div>
                <div id="stylePresetList" class="space-y-3">
                    <!-- Loaded via JS -->
                    <div class="text-center py-4 text-gray-400 text-xs">스타일을 불러오는 중...</div>
                </div>
                <p class="text-[10px] text-gray-400 mt-3 leading-tight">
                    * 각 스타일 선택 시 AI에게 전달될 기본 묘사 프롬프트입니다.<br>
                    * 수정 후 '저장' 버튼을 누르면 즉시 반영됩니다.
                </p>
            </div>
        </div>
        <!-- End Image Styles Tab -->

        <!-- Script Styles Tab -->
        <div id="tab-content-script-styles" class="tab-content">
            <div class="card p-3 shadow-sm border border-gray-200 dark:border-gray-700">
                <h3 class="font-bold text-sm text-gray-800 dark:text-gray-100 mb-3 flex items-center justify-between">
                    <span>📝 대본 스타일 프롬프트 설정</span>
                    <button onclick="loadScriptStylePresets()" class="text-[10px] text-blue-500 hover:underline">🔄
                        서버
                        동기화</button>
                </h3>
                <div id="scriptStylePresetList" class="space-y-3">
                    <!-- Loaded via JS -->
                    <div class="text-center py-4 text-gray-400 text-xs">대본 스타일을 불러오는 중...</div>
                </div>
                <p class="text-[10px] text-gray-400 mt-3 leading-tight">
                    * 대본 생성 시 각 스타일별로 AI에게 전달될 작성 지침입니다.<br>
                    * 수정 후 '저장' 버튼을 누르면 즉시 반영됩니다.<br>
                    * 'script_master'는 대본 작성의 전체 프로세스를 정의하는 마스터 프롬프트입니다.
                </p>
            </div>
        </div>
        <!-- End Script Styles Tab -->

        <!-- Thumbnail Styles Tab -->
        <div id="tab-content-thumbnail-styles" class="tab-content">
            <div class="card p-3 shadow-sm border border-gray-200 dark:border-gray-700">
                <h3 class="font-bold text-sm text-gray-800 dark:text-gray-100 mb-3 flex items-center justify-between">
                    <span>🖼️ 썸네일 스타일 프롬프트 설정</span>
                    <button onclick="loadThumbnailStylePresets()" class="text-[10px] text-blue-500 hover:underline">🔄
                        서버
                        동기화</button>
                </h3>

                <!-- [NEW] Add Custom Thumbnail Style -->
                <div
                    class="mb-4 p-3 bg-blue-50/50 dark:bg-blue-900/10 rounded-lg border border-blue-100 dark:border-blue-800">
                    <h4 class="text-xs font-bold text-blue-800 dark:text-blue-300 mb-2">➕ 커스텀 썸네일 스타일 추가</h4>
                    <div class="space-y-2">
                        <div class="flex gap-2">
                            <input type="text" id="customThumbStyleName" placeholder="스타일 영문 코드명 (예: cinematic_thumb)"
                                class="input-field flex-1 text-xs">
                            <div class="relative w-8 h-8 flex-shrink-0">
                                <label for="customThumbStyleImage"
                                    class="w-full h-full bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded flex items-center justify-center cursor-pointer hover:border-blue-500 transition-colors"
                                    title="참조 이미지 업로드">
                                    <span class="text-gray-400 text-[10px]">📷</span>
                                </label>
                                <input type="file" id="customThumbStyleImage" class="hidden" accept="image/*"
                                    onchange="document.getElementById('customThumbStyleImgName').textContent = this.files[0]?.name || ''">
                            </div>
                        </div>
                        <p id="customThumbStyleImgName" class="text-[10px] text-gray-500 pl-1 h-3 truncate"></p>

                        <textarea id="customThumbStylePrompt" class="input-field w-full text-xs h-16"
                            placeholder="스타일 프롬프트 (예: highly detailed thumbnail, vibrant colors, text overlay)"></textarea>

                        <div class="flex justify-end">
                            <button onclick="addCustomThumbnailStylePreset()"
                                class="btn-primary px-4 py-1.5 text-xs font-bold bg-blue-600 hover:bg-blue-700">
                                추가하기
                            </button>
                        </div>
                    </div>
                </div>

                <div id="thumbnailStylePresetList" class="space-y-3">
                    <!-- Loaded via JS -->
                    <div class="text-center py-4 text-gray-400 text-xs">썸네일 스타일을 불러오는 중...</div>
                </div>
                <p class="text-[10px] text-gray-400 mt-3 leading-tight">
                    * 썸네일 생성 시 각 스타일별로 AI에게 전달될 디자인 지침입니다.<br>
                    * 수정 후 '저장' 버튼을 누르면 즉시 반영됩니다.
                </p>
            </div>
        </div>
        <!-- End Thumbnail Styles Tab -->

        <!-- Data Management Tab -->
        <div id="tab-content-data" class="tab-content">
            <!-- Data Management -->
            <div class="card p-3 shadow-sm border border-gray-200 dark:border-gray-700">
                <h3 class="font-bold text-sm text-gray-800 dark:text-gray-100 mb-2">🗂️ 데이터 관리</h3>
                <div class="flex gap-2">
                    <button onclick="exportData()" class="flex-1 btn-secondary py-1.5 text-xs">📤 백업
                        (JSON)</button>
                    <button onclick="clearData()"
                        class="flex-1 btn-secondary text-red-600 bg-red-50 hover:bg-red-100 border-red-200 py-1.5 text-xs">🗑️
                        초기화</button>
                </div>
            </div>
        </div>
        <!-- End Data Tab -->

        <!-- Webtoon Settings Tab -->
        <div id="tab-content-webtoon" class="tab-content">
            <div class="card p-4 shadow-sm border border-gray-200 dark:border-gray-700">
                <h3 class="font-bold text-sm text-gray-800 dark:text-gray-100 mb-4">🎨 웹툰 영상화 설정</h3>

                <!-- [NEW] Workflow Description Block -->
                <div
                    class="bg-blue-50 dark:bg-blue-900/30 p-3 rounded-lg mb-4 text-xs text-blue-800 dark:text-blue-200 border border-blue-200 dark:border-blue-800">
                    <strong>📢 작업 방식 안내 (PSD 자동 추출)</strong>
                    <p class="mt-1 leading-relaxed">
                        이 시스템은 사용자가 컷별로 이미지를 하나씩 업로드하는 방식이 아닙니다.<br>
                        <strong>PSD 원본 파일이 저장된 디렉토리 경로</strong>와 <strong>추출할 레이어명</strong>을 지정해주시면,<br>
                        시스템이 해당 폴더 내의 PSD 파일들에서 <strong>자동으로 이미지를 추출</strong>하여 영상화 작업을 시작합니다.<br>
                        (AI는 추출된 이미지를 받아 [최적화 &rarr; 영상 변환 &rarr; 최종 합성]을 순차적으로 진행합니다.)
                    </p>
                </div>



                <!-- [NEW] Webtoon Plan Prompt -->
                <div class="card p-4 shadow-sm border border-gray-200 dark:border-gray-700 mt-4">
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="font-bold text-sm text-gray-800 dark:text-gray-100 flex items-center gap-2">
                            <span>📝 웹툰 기획 프롬프트 설정 (Webtoon Plan Prompt)</span>
                        </h3>
                        <button onclick="resetWebtoonPrompt()"
                            class="text-[10px] text-gray-400 hover:text-gray-600 underline">
                            기본값으로 초기화
                        </button>
                    </div>
                    <p class="text-xs text-gray-500 mb-2">
                        웹툰 기획서 생성 시 AI에게 전달되는 프롬프트입니다. `[[SCENES_JSON]]` 부분에 장면 데이터가 들어갑니다.
                    </p>
                    <textarea id="ws_plan_prompt"
                        class="w-full h-96 bg-gray-50 dark:bg-gray-800/50 border border-gray-200 dark:border-gray-600 rounded-md p-3 text-xs font-mono leading-relaxed focus:ring-2 focus:ring-purple-500 outline-none resize-none custom-scrollbar"
                        placeholder="프롬프트를 입력하세요..."></textarea>
                </div>

                <!-- Webtoon Image Optimization Prompts -->
                <div class="card p-4 shadow-sm border border-gray-200 dark:border-gray-700 mt-4">
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="font-bold text-sm text-gray-800 dark:text-gray-100 flex items-center gap-2">
                            <span>✨ 이미지 최적화 (Step 1) 프롬프트 설정</span>
                        </h3>
                        <button onclick="resetWebtoonOptPrompts()"
                            class="text-[10px] text-gray-400 hover:text-gray-600 underline">
                            기본값으로 초기화
                        </button>
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label class="text-xs font-bold text-gray-700 dark:text-gray-300 block mb-1">
                                🟦 세로형 (Vertical/Standard) 최적화
                            </label>
                            <textarea id="ws_vertical_prompt" rows="6"
                                class="input-field w-full text-xs font-mono"></textarea>
                            <p class="text-[10px] text-gray-400 mt-1">
                                * 세로형 이미지의 여백 확장 및 화질 개선 시 사용됩니다.
                            </p>
                        </div>
                        <div>
                            <label class="text-xs font-bold text-gray-700 dark:text-gray-300 block mb-1">
                                🟧 가로형 (Horizontal/Wide) 확장
                            </label>
                            <textarea id="ws_horizontal_prompt" rows="6"
                                class="input-field w-full text-xs font-mono"></textarea>
                            <p class="text-[10px] text-gray-400 mt-1">
                                * 가로형 이미지를 9:16으로 확장(Outpainting)할 때 사용됩니다.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- [NEW] AI Video Engine Selection -->
                <div class="card p-4 shadow-sm border border-gray-200 dark:border-gray-700 mt-4">
                    <h3 class="font-bold text-sm text-gray-800 dark:text-gray-100 mb-3 flex items-center gap-2">
                        <span>🎞️ 영상 생성 AI 엔진 선택</span>
                        <span
                            class="text-[10px] bg-purple-100 text-purple-600 px-1.5 py-0.5 rounded border border-purple-200">중요</span>
                    </h3>

                    <div class="flex gap-4">
                        <!-- Option A: Replicate -->
                        <label
                            class="flex items-start gap-2 p-3 rounded-lg border border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800 cursor-pointer flex-1 transition-colors">
                            <input type="radio" name="ws_video_engine" value="wan" class="mt-1" checked>
                            <div>
                                <div class="font-bold text-sm text-gray-800 dark:text-gray-200">Replicate (Wan 2.1)
                                </div>
                                <div class="text-xs text-gray-500 mt-1">
                                    ✅ 검증된 품질, 안정적<br>
                                    기본 설정입니다. Wan 2.1 모델을 사용하여 웹툰 스타일에 최적화된 모션을 생성합니다.
                                </div>
                            </div>
                        </label>

                        <!-- Option B: Akool -->
                        <label
                            class="flex items-start gap-2 p-3 rounded-lg border border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800 cursor-pointer flex-1 transition-colors">
                            <input type="radio" name="ws_video_engine" value="akool">
                            <div>
                                <div class="font-bold text-sm text-gray-800 dark:text-gray-200">Akool (Alternative)
                                </div>
                                <div class="text-xs text-gray-500 mt-1">
                                    🔄 대안 엔진<br>
                                    Replicate가 불안정하거나 크레딧이 부족할 때 사용하세요. Akool의 영상 생성 API를 사용합니다.
                                </div>
                            </div>
                        </label>
                    </div>
                </div>

                <!-- [NEW] Webtoon Video Motion Prompts -->
                <div class="card p-4 shadow-sm border border-gray-200 dark:border-gray-700 mt-4">
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="font-bold text-sm text-gray-800 dark:text-gray-100 flex items-center gap-2">
                            <span>🎥 영상 변환 (Step 2) 모션 프롬프트 설정</span>
                        </h3>
                        <button onclick="resetWebtoonMotionPrompts()"
                            class="text-[10px] text-gray-400 hover:text-gray-600 underline">
                            기본값으로 초기화
                        </button>
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <!-- Pan -->
                        <div>
                            <label class="text-xs font-bold text-gray-700 dark:text-gray-300 block mb-1">
                                ⬆️ 패닝 (Pan: 세로 긴 컷)
                            </label>
                            <textarea id="ws_motion_pan" rows="8"
                                class="input-field w-full text-xs font-mono leading-tight"></textarea>
                            <p class="text-[10px] text-gray-400 mt-1">
                                * 세로로 긴 컷을 천천히 훑어보는 영상 변환 시 사용
                            </p>
                        </div>
                        <!-- Zoom -->
                        <div>
                            <label class="text-xs font-bold text-gray-700 dark:text-gray-300 block mb-1">
                                🔍 줌인 (Zoom: 감정/클로즈업)
                            </label>
                            <textarea id="ws_motion_zoom" rows="8"
                                class="input-field w-full text-xs font-mono leading-tight"></textarea>
                            <p class="text-[10px] text-gray-400 mt-1">
                                * 캐릭터 얼굴이나 감정을 강조하는 줌인 효과 시 사용
                            </p>
                        </div>
                        <!-- Action -->
                        <div>
                            <label class="text-xs font-bold text-gray-700 dark:text-gray-300 block mb-1">
                                💥 액션/다이나믹 (Action: 전투/강조)
                            </label>
                            <textarea id="ws_motion_action" rows="8"
                                class="input-field w-full text-xs font-mono leading-tight"></textarea>
                            <p class="text-[10px] text-gray-400 mt-1">
                                * 전투씬 등 역동적인 움직임과 입자 효과가 필요할 때 사용
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- End Webtoon Tab -->

    </div>
</div>
</div>
{% endblock %}

{% block scripts %}
<style>
    .tab-button {
        padding: 0.5rem 1rem;
        font-size: 0.875rem;
        font-weight: 500;
        color: #6b7280;
        border-bottom: 2px solid transparent;
        transition: all 0.2s;
        white-space: nowrap;
    }

    .tab-button:hover {
        color: #1f2937;
        border-bottom-color: #d1d5db;
    }

    .tab-button.active {
        color: #2563eb;
        border-bottom-color: #2563eb;
        font-weight: 600;
    }

    .dark .tab-button {
        color: #9ca3af;
    }

    .dark .tab-button:hover {
        color: #d1d5db;
        border-bottom-color: #4b5563;
    }

    .dark .tab-button.active {
        color: #60a5fa;
        border-bottom-color: #60a5fa;
    }

    .tab-content {
        display: none;
    }

    .tab-content.active {
        display: block;
    }
</style>
<script>
    // Tab switching
    function switchTab(tabName) {
        console.log('Switching to tab:', tabName);

        // Hide all tabs
        document.querySelectorAll('.tab-content').forEach(tab => {
            tab.classList.remove('active');
            console.log('Hiding tab:', tab.id);
        });
        document.querySelectorAll('.tab-button').forEach(btn => {
            btn.classList.remove('active');
        });

        // Show selected tab
        const targetTab = document.getElementById(`tab-content-${tabName}`);
        const targetBtn = document.getElementById(`tab-${tabName}`);

        if (targetTab && targetBtn) {
            targetTab.classList.add('active');
            targetBtn.classList.add('active');
            console.log('Showing tab:', targetTab.id);
        } else {
            console.error('Tab not found:', tabName, 'targetTab:', targetTab, 'targetBtn:', targetBtn);
        }

        // Load data if needed
        if (tabName === 'image-styles') {
            loadStylePresets();
        } else if (tabName === 'script-styles') {
            loadScriptStylePresets();
        } else if (tabName === 'thumbnail-styles') {
            loadThumbnailStylePresets();
        } else if (tabName === 'webtoon') {
            loadWebtoonSettings();
        }
    }

    // Gemini Constants
    const GEMINI_VOICES = [
        "Puck", "Charon", "Kore", "Fenrir", "Aoede", "Zephyr", "Orpheus", "Cupid",
        "Autonoe", "Callirrhoe", "Laomedeia", "Leda", "Despina", "Sulafat",
        "Algenib", "Alnilam", "Achernar", "Achird", "Enceladus", "Vega",
        "Ursa", "Pegasus", "Nova", "Eclipse", "Lyra", "Orbit", "Dipper",
        "Capella", "Orion"
    ];

    const GEMINI_LANGUAGES = [
        "ko-KR", "en-US", "ja-JP", "es-US", "fr-FR", "de-DE", "hi-IN", "id-ID",
        "it-IT", "pt-BR", "ru-RU", "nl-NL", "pl-PL", "th-TH", "tr-TR", "vi-VN",
        "ro-RO", "uk-UA", "bn-BD", "en-IN", "mr-IN", "ta-IN", "te-IN", "ar-EG"
    ];

    // [NEW] Default Master Prompt for Script Writing
    const DEFAULT_SCRIPT_MASTER_PROMPT = `최종 확정: '딥-다이브' 대본 빌드업 4단계 프로세스 (Ver. 4.0)

[1단계] 대본 정밀 해부 및 흥행 잠재력 진단
임무: 대본을 문장 단위로 정밀 분석하고, '흥행 심리 지도(5070 타겟 제목 리스트)'와 '전문 드라마 기법'을 사용하여 잠재력과 개선점에 대한 '대본 정밀 해부 리포트'를 발행합니다.

실행 원칙:
- [종합 진단] 작품의 가장 매력적인 설정과 개선 필요 지점 명확하게 요약
- [톤앤매너 분석] 나레이션은 시청자에게 정중한 '존댓말' 원칙 (5070 시청자 정서적 유대감)
- [대사 현미경 분석] 감정 설명 대사를 '극적 아이러니(Dramatic Irony)'가 담긴 상황으로 개선
- [장면 구조 분석] 도입부는 '인 미디어스 레스(In medias res)' + '체호프의 총(Chekhov's Gun)' 기법 적용
- [인물 매력도 분석] 주인공에게 '복선(Foreshadowing)'을 통한 숨겨진 능력 암시

[2단계] '감독판 샘플' 제작 및 공동 창작 방향 확정
임무: 지정된 장면을 드라마 기법 + 흥행 코드 + 존댓말 나레이션에 따라 '원본 vs 감독 수정본' 형태로 제공

[3단계] 감독판 대본 전체 집필
임무: 합의된 개선 방향과 스타일을 대본 전체에 일관되게 적용하여 최종 [감독판 대본] 완성

[4단계] 최종 마케팅 에셋 시화
임무: 완성된 대본의 핵심 컨셉을 보여줄 썸네일 비주얼을 구체적으로 묘사`;

    // Reset Master Prompt to Default
    function resetMasterPrompt() {
        document.getElementById('promptScriptMaster').value = DEFAULT_SCRIPT_MASTER_PROMPT;
        Utils.showToast('마스터 프롬프트가 기본값으로 초기화되었습니다', 'success');
    }

    // App Mode Toggle
    function setAppMode(mode) {
        const currentMode = document.getElementById('appMode').value;

        // 현재 모드와 같은 모드를 선택한 경우 아무것도 하지 않음
        if (currentMode === mode) {
            return;
        }

        // 모드 변경 적용 (팝업 제거됨)

        // 모드 변경 적용
        document.getElementById('appMode').value = mode;

        const btnLong = document.getElementById('btnModeLong');
        const btnShort = document.getElementById('btnModeShort');

        const activeClass = "bg-white dark:bg-gray-600 shadow text-gray-800 dark:text-white font-bold";
        const inactiveClass = "text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 font-medium";

        if (mode === 'longform') {
            btnLong.className = `px-4 py-1.5 rounded-md text-xs transition-all ${activeClass}`;
            btnShort.className = `px-4 py-1.5 rounded-md text-xs transition-all ${inactiveClass}`;
        } else {
            btnShort.className = `px-4 py-1.5 rounded-md text-xs transition-all ${activeClass}`;
            btnLong.className = `px-4 py-1.5 rounded-md text-xs transition-all ${inactiveClass}`;
        }

        // 저장 버튼 강조 (사용자에게 저장 필요성 알림)
        const saveBtn = document.querySelector('button[onclick="saveAllSettings()"]');
        if (saveBtn) {
            saveBtn.classList.add('animate-pulse');
            setTimeout(() => {
                saveBtn.classList.remove('animate-pulse');
            }, 3000);
        }
    }

    // Populate Select Options
    function populateOptions() {
        const voiceSelect = document.getElementById('geminiVoice');
        const langSelect = document.getElementById('geminiLanguage');

        voiceSelect.innerHTML = GEMINI_VOICES.map(v => `<option value="${v}">${v}</option>`).join('');
        langSelect.innerHTML = GEMINI_LANGUAGES.map(l => `<option value="${l}">${l}</option>`).join('');
    }

    // Load All Settings
    async function loadAllSettings() {
        try {
            await loadApiKeys();
            await checkApiConnection();

            const res = await fetch('/api/settings');
            const data = await res.json();

            if (data.gemini_tts) {
                document.getElementById('geminiVoice').value = data.gemini_tts.voice_name || 'Puck';
                document.getElementById('geminiLanguage').value = data.gemini_tts.language_code || 'ko-KR';
                document.getElementById('geminiStylePrompt').value = data.gemini_tts.style_prompt || '';
            }

            if (data.script_styles) {
                document.getElementById('promptNews').value = data.script_styles.news || '';
                document.getElementById('promptStory').value = data.script_styles.story || '';
                document.getElementById('promptScriptMaster').value = data.script_styles.script_master || DEFAULT_SCRIPT_MASTER_PROMPT;
                document.getElementById('promptSeniorStory').value = data.script_styles.senior_story || '';
            }

            if (data.app_mode) {
                setAppMode(data.app_mode);
            }

            updateTemplatePreview(data.template_image_url);

            Utils.showToast('설정을 불러왔습니다.', 'info');
        } catch (e) {
            console.error('설정 로드 실패:', e);
        }
    }

    // [NEW] Load Webtoon Settings
    async function loadWebtoonSettings() {
        try {
            const res = await fetch('/api/settings');
            const data = await res.json();

            // Default to true if not set
            const autoSplit = data.webtoon_auto_split; // expecting boolean or string 'true'/'false'
            const smartPan = data.webtoon_smart_pan;
            const convertZoom = data.webtoon_convert_zoom;

            // Helper to check truthiness safely (defaults to TRUE)
            const isTrue = (val) => val === undefined || val === null || val === true || val === 'true';

            document.getElementById('ws_auto_split').checked = isTrue(autoSplit);
            document.getElementById('ws_smart_pan').checked = isTrue(smartPan);
            document.getElementById('ws_convert_zoom').checked = isTrue(convertZoom);

        } catch (e) {
            console.error('Webtoon 설정 로드 실패:', e);
            Utils.showToast('웹툰 설정을 불러오지 못했습니다.', 'error');
        }
    }

    // Save All
    async function saveAllSettings() {
        try {
            // 1. API 키 먼저 저장
            await saveApiKeys();

            // 2. 일반 설정 수집
            const settings = {
                app_mode: document.getElementById('appMode').value,
                gemini_tts: {
                    voice_name: document.getElementById('geminiVoice').value,
                    language_code: document.getElementById('geminiLanguage').value,
                    style_prompt: document.getElementById('geminiStylePrompt').value
                },
                script_styles: {
                    news: document.getElementById('promptNews').value,
                    story: document.getElementById('promptStory').value,
                    script_master: document.getElementById('promptScriptMaster').value,
                    senior_story: document.getElementById('promptSeniorStory').value
                },
                // [NEW] Webtoon Settings
                webtoon_auto_split: document.getElementById('ws_auto_split').checked,
                webtoon_smart_pan: document.getElementById('ws_smart_pan').checked,
                webtoon_convert_zoom: document.getElementById('ws_convert_zoom').checked
            };

            const res = await fetch('/api/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(settings)
            });

            if (res.ok) {
                const data = await res.json();
                if (data.mode_changed) {
                    Utils.showToast(`✅ 설정 저장 및 모드 전환 완료!`, 'success');
                    setTimeout(() => window.location.reload(), 1500);
                } else {
                    Utils.showToast('✅ 모든 설정이 저장되었습니다', 'success');
                    await loadApiKeys();
                    await checkApiConnection();
                }
            }
        } catch (e) {
            console.error('설정 저장 오류:', e);
            Utils.showToast('❌ 설정 저장 중 오류가 발생했습니다.', 'error');
        }
    }

    // 키 보기/숨기기 토글
    function toggleKeyVisibility(inputId) {
        console.log('👁️ [Settings] 토글 클릭:', inputId);
        const input = document.getElementById(inputId);
        if (input) {
            const currentType = input.type;
            input.type = currentType === 'password' ? 'text' : 'password';
            console.log(`👁️ [Settings] ${inputId} 타입 변경: ${currentType} -> ${input.type}`);
        }
    }

    // API 키 상태 로드
    async function loadApiKeys() {
        try {
            const data = await API.apiKeys.get();
            console.log('📡 [Settings] 로드된 API 키 상태:', data);

            if (!data) return;

            // 기본 키 상태 저장 객체 (서버에서 받은 원본 값을 기억)
            window._originalApiValues = {};

            // 기본 키들 업데이트
            const standardKeys = {
                'youtube': 'youtubeApiKey',
                'gemini': 'geminiApiKey',
                'elevenlabs': 'elevenlabsApiKey',
                'replicate': 'replicateApiKey',
                'topview': 'topviewApiKey'
            };

            for (const [key, inputId] of Object.entries(standardKeys)) {
                if (data[key] && data[key].set) {
                    window._originalApiValues[inputId] = data[key].value || "";
                }
                updateKeyStatus(key, data[key], inputId);
            }

            // Akool 특수 처리
            const akoolConn = document.getElementById('akoolConnectionStatus');
            const akoolIdSet = !!(data.akool_id && data.akool_id.set);
            const akoolSecretSet = !!(data.akool_secret && data.akool_secret.set);

            // Akool ID
            const idStatus = document.getElementById('akoolClientIdStatus');
            const idMasked = document.getElementById('akoolIdMasked');
            const idInput = document.getElementById('akoolClientId');
            if (idStatus) {
                idStatus.innerHTML = akoolIdSet
                    ? '<span class="status-badge status-on" style="background:transparent; color:#10b981; padding:0; margin-left:4px;">(ID ✅)</span>'
                    : '<span class="status-badge status-off" style="background:transparent; color:#ef4444; padding:0; margin-left:4px;">(ID ❌)</span>';
            }
            if (idMasked) idMasked.innerText = akoolIdSet ? '현재 ID: ' + data.akool_id.masked : '';
            if (idInput) {
                const val = akoolIdSet ? (data.akool_id.value || "") : "";
                window._originalApiValues['akoolClientId'] = val;
                idInput.value = val;
            }

            // Akool Secret
            const secStatus = document.getElementById('akoolClientSecretStatus');
            const secMasked = document.getElementById('akoolSecretMasked');
            const secInput = document.getElementById('akoolClientSecret');
            if (secStatus) {
                secStatus.innerHTML = akoolSecretSet
                    ? '<span class="status-badge status-on" style="background:transparent; color:#10b981; padding:0; margin-left:4px;">(Secret ✅)</span>'
                    : '<span class="status-badge status-off" style="background:transparent; color:#ef4444; padding:0; margin-left:4px;">(Secret ❌)</span>';
            }
            if (secMasked) secMasked.innerText = akoolSecretSet ? '현재 Secret: ' + data.akool_secret.masked : '';
            if (secInput) {
                const val = akoolSecretSet ? (data.akool_secret.value || "") : "";
                window._originalApiValues['akoolClientSecret'] = val;
                secInput.value = val;
            }

            if (akoolConn) {
                if (akoolIdSet && akoolSecretSet) {
                    akoolConn.innerHTML = '설정됨';
                    akoolConn.className = 'text-[10px] bg-green-100 dark:bg-green-900/30 px-1.5 rounded text-green-600 dark:text-green-400';
                } else {
                    akoolConn.innerHTML = '미완성';
                    akoolConn.className = 'text-[10px] bg-yellow-100 dark:bg-yellow-900/30 px-1.5 rounded text-yellow-600 dark:text-yellow-400';
                }
            }
        } catch (e) {
            console.error('API 키 로드 오류:', e);
        }
    }

    function updateKeyStatus(keyPrefix, keyData, inputId) {
        const statusEl = document.getElementById(`${keyPrefix}Status`);
        const maskedEl = document.getElementById(`${keyPrefix}KeyMasked`);
        const inputEl = document.getElementById(inputId);

        const isSet = !!(keyData && keyData.set);

        if (isSet) {
            if (statusEl) statusEl.innerHTML = '<span class="status-badge status-on">✅ 설정됨</span>';
            if (maskedEl) maskedEl.innerText = '현재 키: ' + keyData.masked;
            if (inputEl) inputEl.value = keyData.value || "";
        } else {
            if (statusEl) statusEl.innerHTML = `<span class="status-badge status-off">❌ 미설정${keyPrefix === 'youtube' || keyPrefix === 'gemini' ? '' : ' (선택)'}</span>`;
            if (maskedEl) maskedEl.innerText = '';
            if (inputEl) inputEl.value = '';
        }
    }

    // API 키 개별 저장
    async function saveApiKeys() {
        const keys = {};
        const fields = {
            'youtubeApiKey': 'youtube',
            'geminiApiKey': 'gemini',
            'elevenlabsApiKey': 'elevenlabs',
            'replicateApiKey': 'replicate',
            'topviewApiKey': 'topview',
            'akoolClientId': 'akool_id',
            'akoolClientSecret': 'akool_secret'
        };

        for (const [id, apiKey] of Object.entries(fields)) {
            const el = document.getElementById(id);
            const val = el ? el.value.trim() : '';

            // 원래 있던 마스킹된 값(원본)과 비교하여 다를 때만 저장 (즉, 직접 입력한 경우)
            const originalVal = (window._originalApiValues || {})[id];

            if (val && val !== originalVal) {
                keys[apiKey] = val;
            }
        }

        if (Object.keys(keys).length > 0) {
            console.log('🚀 [Settings] 변경된 API 키 저장 시도:', keys);
            try {
                await API.apiKeys.save(keys);
                Utils.showToast('변경된 API 키가 저장되었습니다.', 'success');
                await loadApiKeys();
            } catch (e) {
                console.error('API 키 저장 중 오류:', e);
                Utils.showToast('API 키 저장 실패', 'error');
            }
        }
    }

    // [NEW] Template Image Functions
    async function uploadTemplate(input) {
        if (!input.files || !input.files[0]) return;
        const file = input.files[0];

        const formData = new FormData();
        formData.append('file', file);
        formData.append('type', 'template'); // flag

        Utils.showToast('이미지 업로드 중...', 'info');

        try {
            const res = await fetch('/api/upload/template', {
                method: 'POST',
                body: formData
            });
            const data = await res.json();

            if (res.ok) {
                Utils.showToast('템플릿 업로드 완료', 'success');
                // Update UI
                updateTemplatePreview(data.url);
            } else {
                Utils.showToast('업로드 실패: ' + (data.error || 'Unknown'), 'error');
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('오류 발생', 'error');
        } finally {
            input.value = ''; // Reset input
        }
    }

    async function deleteTemplate() {
        if (!confirm('템플릿 이미지를 삭제하시겠습니까?')) return;

        try {
            const res = await fetch('/api/settings/template', { method: 'DELETE' });
            if (res.ok) {
                Utils.showToast('삭제되었습니다', 'success');
                updateTemplatePreview(null);
            } else {
                Utils.showToast('삭제 실패', 'error');
            }
        } catch (e) {
            console.error(e);
        }
    }

    function updateTemplatePreview(url) {
        const img = document.getElementById('templatePreview');
        const ph = document.getElementById('templatePlaceholder');
        const delBtn = document.getElementById('btnDeleteTemplate');

        if (url) {
            img.src = url;
            img.classList.remove('hidden');
            ph.classList.add('hidden');
            delBtn.classList.remove('hidden');
        } else {
            img.src = '';
            img.classList.add('hidden');
            ph.classList.remove('hidden');
            delBtn.classList.add('hidden');
        }
    }

    // API 연결 상태 확인
    async function checkApiConnection() {
        try {
            const health = await API.health();

            document.getElementById('youtubeConnectionStatus').innerHTML = health.apis?.youtube
                ? '<span class="text-green-600">✅ 연결됨</span>'
                : '<span class="text-red-600">❌ 미연결</span>';

            document.getElementById('geminiConnectionStatus').innerHTML = health.apis?.gemini
                ? '<span class="text-green-600">✅ 연결됨</span>'
                : '<span class="text-red-600">❌ 미연결</span>';

            document.getElementById('elevenlabsConnectionStatus').innerHTML = health.apis?.elevenlabs
                ? '<span class="text-green-600">✅ 연결됨</span>'
                : '<span class="text-yellow-600">⚠️ 미설정 (선택)</span>';

            document.getElementById('replicateConnectionStatus').innerHTML = health.apis?.replicate
                ? '<span class="text-green-600">✅ 가능</span>'
                : '<span class="text-yellow-600">⚠️ 미연결</span>';

        } catch (e) {
            console.error('연결 상태 확인 오류:', e);
        }
    }

    function exportData() {
        const data = {
            analysisData: Utils.storage.get('analysisData'),
            scriptStructure: Utils.storage.get('scriptStructure'),
            fullScript: Utils.storage.get('fullScript'),
            imagePrompts: Utils.storage.get('imagePrompts'),
            exportedAt: new Date().toISOString()
        };

        Utils.downloadFile(JSON.stringify(data, null, 2), 'picadillystudio_backup.json', 'application/json');
        Utils.showToast('데이터를 내보냈습니다', 'success');
    }

    function clearData() {
        if (!confirm('모든 로컬 데이터를 삭제하시겠습니까?\n(API 키는 삭제되지 않습니다)')) return;

        Utils.storage.remove('analysisData');
        Utils.storage.remove('scriptStructure');
        Utils.storage.remove('fullScript');
        Utils.storage.remove('imagePrompts');
        Utils.storage.remove('ttsAudio');

        Utils.showToast('모든 데이터가 삭제되었습니다', 'success');
    }

    // 채널 로드
    async function loadChannels() {
        const list = document.getElementById('channelList');
        try {
            const res = await fetch('/api/channels');
            if (!res.ok) throw new Error('채널 목록 로드 실패');
            const channels = await res.json();

            if (channels.length === 0) {
                list.innerHTML = '<p class="text-gray-500 text-sm text-center py-4">등록된 채널이 없습니다.</p>';
                return;
            }

            // credentials_path가 있으면 인증된 것으로 간주
            list.innerHTML = channels.map(ch => {
                const isAuthenticated = !!ch.credentials_path;
                const statusBadge = isAuthenticated
                    ? '<span class="text-green-600 border border-green-200 bg-green-50 px-2 py-0.5 rounded text-xs">✅ 연결됨</span>'
                    : '<span class="text-gray-500 border border-gray-200 bg-gray-50 px-2 py-0.5 rounded text-xs">❌ 미연결</span>';

                const authBtn = isAuthenticated
                    ? `<button onclick="authenticateChannel(${ch.id}, '${ch.name}')" class="text-blue-500 hover:text-blue-700 text-xs border border-blue-200 px-2 py-1 rounded">🔄 재연결</button>`
                    : `<button onclick="authenticateChannel(${ch.id}, '${ch.name}')" class="text-white bg-blue-500 hover:bg-blue-600 px-3 py-1 rounded text-xs shadow-sm">🔑 로그인</button>`;

                return `
                <div class="flex items-center justify-between p-3 bg-white dark:bg-gray-800 border dark:border-gray-600 rounded-lg shadow-sm">
                    <div>
                        <div class="flex items-center gap-2 mb-1">
                            <span class="font-medium text-gray-800 dark:text-white">${ch.name}</span>
                            <span class="text-xs text-gray-500 font-normal">${ch.handle}</span>
                            ${statusBadge}
                        </div>
                        ${ch.description ? `<p class="text-xs text-gray-500">${ch.description}</p>` : ''}
                    </div>
                    <div class="flex items-center gap-2">
                        ${authBtn}
                        <button onclick="deleteChannel(${ch.id})" class="text-red-500 hover:text-red-700 p-2" title="삭제">
                            🗑️
                        </button>
                    </div>
                </div>
            `}).join('');

        } catch (e) {
            console.error(e);
            list.innerHTML = '<p class="text-red-500 text-sm">목록을 불러오지 못했습니다.</p>';
        }
    }

    // 채널 인증 (OAuth)
    async function authenticateChannel(id, name) {
        if (!confirm(`'${name}' 채널의 유튜브 계정으로 로그인하시겠습니까?\n\n(참고: 새 창이 뜨면 해당 채널의 구글 계정으로 로그인해주세요.)`)) return;

        try {
            // 이 요청은 서버에서 Python 로컬 서버를 통해 브라우저를 띄우므로 시간이 걸릴 수 있음
            Utils.showToast('인증 창이 열립니다. 브라우저를 확인해주세요...', 'info');

            const res = await fetch(`/api/auth/youtube/${id}`);
            const data = await res.json();

            if (res.ok) {
                Utils.showToast(data.message || '인증 완료!', 'success');
                loadChannels();
            } else {
                Utils.showToast(data.detail || '인증 실패', 'error');
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('인증 과정 중 오류가 발생했습니다.', 'error');
        }
    }

    // 채널 추가
    async function addChannel() {

        const nameInput = document.getElementById('newChannelName');
        const handleInput = document.getElementById('newChannelHandle');
        const descInput = document.getElementById('newChannelDesc');

        const name = nameInput.value.trim();
        let handle = handleInput.value.trim();
        const description = descInput.value.trim();

        if (!name || !handle) {
            Utils.showToast('채널명과 핸들을 모두 입력해주세요.', 'warning');
            return;
        }

        if (!handle.startsWith('@')) {
            handle = '@' + handle;
        }

        try {
            const res = await fetch('/api/channels', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name, handle, description })
            });

            if (res.ok) {
                Utils.showToast('채널이 추가되었습니다.', 'success');
                nameInput.value = '';
                handleInput.value = '';
                descInput.value = '';
                loadChannels(); // 목록 갱신
            } else {
                const err = await res.json();
                Utils.showToast(err.detail || '채널 추가 실패', 'error');
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('서버 오류가 발생했습니다.', 'error');
        }
    }

    // 채널 삭제
    async function deleteChannel(id) {
        if (!confirm('정말 이 채널을 삭제하시겠습니까?')) return;

        try {
            const res = await fetch(`/api/channels/${id}`, { method: 'DELETE' });
            if (res.ok) {
                Utils.showToast('채널이 삭제되었습니다.', 'success');
                loadChannels();
            } else {
                Utils.showToast('삭제 실패', 'error');
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('서버 오류', 'error');
        }
    }

    // [NEW] 이미지 스타일 프리셋 관리 (최종 통합 버전)
    const DEFAULT_STYLE_KEYS = ['realistic', 'anime', 'cinematic', 'cartoon', 'oil_painting', 'watercolor', 'sketch', 'pixel_art', '3d'];

    async function loadStylePresets() {
        const list = document.getElementById('stylePresetList');
        if (!list) return;

        try {
            const res = await fetch('/api/settings/style-presets');
            const presets = await res.json();

            list.innerHTML = Object.entries(presets).map(([key, data]) => {
                const prompt = typeof data === 'string' ? data : (data.prompt_value || '');
                const imageUrl = typeof data === 'object' ? data.image_url : null;

                const displayName = {
                    'realistic': '리얼리스틱', 'anime': '애니메이션', 'cinematic': '시네마틱',
                    'cartoon': '카툰', 'oil_painting': '유화', 'watercolor': '수채화',
                    'sketch': '스케치', 'pixel_art': '픽셀아트', '3d': '3D'
                }[key] || key;

                const isDefault = DEFAULT_STYLE_KEYS.includes(key);

                return `
                    <div class="bg-gray-50 dark:bg-gray-800/50 p-3 rounded-md border border-gray-100 dark:border-gray-700 relative group">
                        <div class="flex justify-between items-start mb-2">
                            <div class="flex items-center gap-2">
                                <div class="relative group/img cursor-pointer" onclick="document.getElementById('file_${key}').click()">
                                    ${imageUrl ?
                        `<img id="img_preview_${key}" src="${imageUrl}" class="w-10 h-10 rounded border border-gray-300 object-cover bg-white" title="이미지 변경">`
                        : `<span id="img_preview_${key}" class="w-10 h-10 rounded bg-gray-200 dark:bg-gray-700 flex items-center justify-center text-[10px] text-gray-500 hover:bg-gray-300 transition-colors">No Img</span>`
                    }
                                    <input type="file" id="file_${key}" class="hidden" accept="image/*" onchange="previewStyleImage(this, '${key}')">
                                </div>
                                <div>
                                    <label class="text-sm font-bold text-gray-700 dark:text-gray-200 block leading-none mb-1">${displayName}</label>
                                    <span class="text-[10px] text-gray-400 font-mono">${key}</span>
                                </div>
                            </div>
                            <div class="flex gap-1">
                                <button onclick="toggleEditStylePreset('${key}')" id="edit_btn_${key}" class="text-[10px] bg-yellow-500 text-white px-2 py-1 rounded">✏️ 수정</button>
                                <button onclick="saveOneStylePreset('${key}')" id="save_btn_${key}" class="hidden text-[10px] bg-blue-500 text-white px-2 py-1 rounded">💾 저장</button>
                                ${!isDefault ? `<button onclick="deleteStylePreset('${key}')" class="text-[10px] bg-red-50 text-red-500 border border-red-200 px-2 py-1 rounded">🗑️</button>` : ''}
                            </div>
                        </div>
                        <textarea id="preset_${key}" class="input-field w-full text-[11px] font-mono bg-gray-100 dark:bg-gray-900" rows="2" readonly>${prompt}</textarea>
                    </div>
                `;
            }).join('');
        } catch (e) {
            console.error(e);
            list.innerHTML = '<p class="text-red-500 text-xs">스타일을 불러오지 못했습니다.</p>';
        }
    }

    async function saveOneStylePreset(key) {
        const textarea = document.getElementById(`preset_${key}`);
        if (!textarea) return;
        const val = textarea.value;

        try {
            const res = await fetch('/api/settings/style-presets', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ style_key: key, prompt_value: val })
            });

            if (res.ok) {
                Utils.showToast(`[${key}] 스타일이 저장되었습니다`, 'success');
                // 저장 후 다시 읽기 전용으로
                textarea.readOnly = true;
                textarea.classList.remove('bg-white', 'dark:bg-gray-800');
                textarea.classList.add('bg-gray-100', 'dark:bg-gray-900');
                document.getElementById(`save_btn_${key}`).classList.add('hidden');
                document.getElementById(`edit_btn_${key}`).innerText = '✏️ 수정';
            } else {
                Utils.showToast('저장 실패', 'error');
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('오류 발생', 'error');
        }
    }

    function previewStyleImage(input, key) {
        if (input.files && input.files[0]) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const preview = document.getElementById(`img_preview_${key}`);
                const parent = preview.parentElement;

                // Remove old preview (img or span)
                preview.remove();

                // Create new preview img
                const img = document.createElement('img');
                img.id = `img_preview_${key}`;
                img.src = e.target.result;
                img.className = "w-10 h-10 rounded border border-gray-300 object-cover bg-white";
                img.title = "이미지 변경 (클릭)";

                // Insert as first child of parent (.relative.group/img)
                parent.prepend(img);
            }
            reader.readAsDataURL(input.files[0]);
        }
    }

    function toggleEditStylePreset(key) {
        const textarea = document.getElementById(`preset_${key}`);
        const editBtn = document.getElementById(`edit_btn_${key}`);
        const saveBtn = document.getElementById(`save_btn_${key}`);

        if (textarea.hasAttribute('readonly')) {
            // Enable editing
            textarea.removeAttribute('readonly');
            textarea.classList.remove('bg-gray-100', 'dark:bg-gray-900');
            textarea.classList.add('bg-white', 'dark:bg-gray-800', 'ring-2', 'ring-yellow-400');
            textarea.focus();

            // Toggle buttons
            editBtn.classList.add('hidden');
            saveBtn.classList.remove('hidden');
        } else {
            // Disable editing (cancel)
            textarea.setAttribute('readonly', true);
            textarea.classList.add('bg-gray-100', 'dark:bg-gray-900');
            textarea.classList.remove('bg-white', 'dark:bg-gray-800', 'ring-2', 'ring-yellow-400');

            // Toggle buttons
            editBtn.classList.remove('hidden');
            saveBtn.classList.add('hidden');
        }
    }

    async function saveOneStylePreset(key) {
        const val = document.getElementById(`preset_${key}`).value;
        const fileInput = document.getElementById(`file_${key}`);
        const file = fileInput && fileInput.files[0];

        try {
            let res;
            if (file) {
                // If file exists, use multipart upload endpoint (upsert)
                const formData = new FormData();
                formData.append('style_key', key);
                formData.append('prompt_value', val);
                formData.append('file', file);

                Utils.showToast('이미지 업로드 및 저장 중...', 'info');
                res = await fetch('/api/settings/style-presets/custom', {
                    method: 'POST',
                    body: formData
                });
            } else {
                // Normal JSON update
                res = await fetch('/api/settings/style-presets', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        style_key: key,
                        prompt_value: val,
                        image_url: null // Backend will preserve if null
                    })
                });
            }

            if (res.ok) {
                if (file) {
                    // Clear file input so next save doesn't re-upload unless changed
                    fileInput.value = '';
                }
                Utils.showToast(`[${key}] 스타일이 저장되었습니다`, 'success');

                // Exit edit mode
                const textarea = document.getElementById(`preset_${key}`);
                const editBtn = document.getElementById(`edit_btn_${key}`);
                const saveBtn = document.getElementById(`save_btn_${key}`);

                textarea.setAttribute('readonly', true);
                textarea.classList.add('bg-gray-100', 'dark:bg-gray-900');
                textarea.classList.remove('bg-white', 'dark:bg-gray-800', 'ring-2', 'ring-yellow-400');
                editBtn.classList.remove('hidden');
                saveBtn.classList.add('hidden');
            } else {
                const err = await res.json();
                Utils.showToast(err.detail || '저장 실패', 'error');
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('오류 발생', 'error');
        }
    }

    // [NEW] Add Custom Style
    async function addCustomStylePreset() {
        const nameInput = document.getElementById('customStyleName');
        const promptInput = document.getElementById('customStylePrompt');
        const fileInput = document.getElementById('customStyleImage');
        const name = nameInput.value.trim();
        const prompt = promptInput.value.trim();
        const file = fileInput.files[0];

        if (!name || !prompt) {
            Utils.showToast('이름과 프롬프트를 모두 입력해주세요.', 'warning');
            return;
        }

        const formData = new FormData();
        formData.append('style_key', name);
        formData.append('prompt_value', prompt);
        if (file) {
            formData.append('file', file);
        }

        Utils.showToast('스타일 추가 중...', 'info');

        try {
            const res = await fetch('/api/settings/style-presets/custom', {
                method: 'POST',
                body: formData
            });

            if (res.ok) {
                Utils.showToast('새 스타일이 추가되었습니다!', 'success');
                // Clear inputs
                nameInput.value = '';
                promptInput.value = '';
                fileInput.value = '';
                document.getElementById('customStyleImgName').textContent = '';
                // Reload list
                loadStylePresets();
            } else {
                const err = await res.json();
                Utils.showToast(err.detail || '추가 실패', 'error');
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('서버 오류 발생', 'error');
        }
    }

    // [NEW] Delete Style
    async function deleteStylePreset(key) {
        if (!confirm(`'${key}' 스타일을 정말 삭제하시겠습니까?`)) return;

        try {
            const res = await fetch(`/api/settings/style-presets/${key}`, { method: 'DELETE' });
            if (res.ok) {
                Utils.showToast('삭제되었습니다.', 'success');
                loadStylePresets();
            } else {
                Utils.showToast('삭제 실패', 'error');
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('서버 오류', 'error');
        }
    }

    // [NEW] 대본 스타일 프리셋 관리
    async function loadScriptStylePresets() {
        const list = document.getElementById('scriptStylePresetList');
        try {
            const res = await fetch('/api/settings/script-style-presets');
            const presets = await res.json();

            list.innerHTML = Object.entries(presets).map(([key, val]) => {
                const displayName = {
                    'default': '기본 설정',
                    'news': '뉴스 보도',
                    'story': '옛날 이야기',
                    'senior_story': '시니어 사연',
                    'bgm': '배경음악 중심',
                    'classic_50s': '50년대 클래식영화',
                    'joseon_sageuk': '조선시대 사극',
                    'north_korean_drama': '북한 드라마',
                    'silent_20s': '20년대 무성영화',
                    'camcorder_90s': '90년대 캠코더',
                    'modern_drama': '현대 드라마',
                    'mystery_thriller': '미스터리 스릴러',
                    'horror_suspense': '공포-서스펜스',
                    'melodrama': '멜로드라마',
                    'crime_drama': '범죄 드라마',
                    'cyberpunk_neon': '사이버펑크 네온',
                    'watercolor_analog': '수채화풍 아날로그',
                    'digital_webtoon': '디지털 웹툰',
                    'graphite_sketch': '흑연 드로잉 스케치',
                    'joseon_2d_anime': '조선시대 풍속화 2D',
                    'oriental_ink': '동양 수묵화',
                    'neonsign_citypop': '네온사인 시티팝',
                    'buddhist_minimal': '불교 미니멀리즘',
                    'renaissance_sacred': '르네상스 성화',
                    'cute_animal_char': '귀여운 동물 캐릭터',
                    'wimpy_kid': '윔피키드 스타일',
                    'script_master': '📋 대본 작성 마스터'
                }[key] || key;

                const rows = val.length > 200 ? 8 : val.length > 100 ? 5 : 3;

                return `
                            <div class="bg-gray-50 dark:bg-gray-800/50 p-3 rounded-md border border-gray-100 dark:border-gray-700">
                                <div class="flex justify-between items-center mb-2">
                                    <label class="text-sm font-bold text-gray-700 dark:text-gray-200">${displayName}</label>
                                    <div class="flex gap-1">
                                        <button onclick="toggleEditScriptStylePreset('${key}')" id="script_edit_btn_${key}" class="text-[10px] bg-yellow-500 text-white px-2 py-1 rounded hover:bg-yellow-600 transition-colors">✏️ 수정</button>
                                        <button onclick="saveOneScriptStylePreset('${key}')" id="script_save_btn_${key}" class="hidden text-[10px] bg-blue-500 text-white px-2 py-1 rounded hover:bg-blue-600 transition-colors">💾 저장</button>
                                    </div>
                                </div>
                                <textarea id="script_preset_${key}" class="input-field w-full text-[11px] font-mono leading-tight bg-gray-100 dark:bg-gray-900" rows="${rows}" readonly>${val}</textarea>
                            </div>
                        `;
            }).join('');
        } catch (e) {
            console.error(e);
            list.innerHTML = '<p class="text-red-500 text-xs">대본 스타일을 불러오지 못했습니다.</p>';
        }
    }

    function toggleEditScriptStylePreset(key) {
        const textarea = document.getElementById(`script_preset_${key}`);
        const editBtn = document.getElementById(`script_edit_btn_${key}`);
        const saveBtn = document.getElementById(`script_save_btn_${key}`);

        if (textarea.hasAttribute('readonly')) {
            // Enable editing
            textarea.removeAttribute('readonly');
            textarea.classList.remove('bg-gray-100', 'dark:bg-gray-900');
            textarea.classList.add('bg-white', 'dark:bg-gray-800', 'ring-2', 'ring-yellow-400');
            textarea.focus();

            // Toggle buttons
            editBtn.classList.add('hidden');
            saveBtn.classList.remove('hidden');
        } else {
            // Disable editing (cancel)
            textarea.setAttribute('readonly', true);
            textarea.classList.add('bg-gray-100', 'dark:bg-gray-900');
            textarea.classList.remove('bg-white', 'dark:bg-gray-800', 'ring-2', 'ring-yellow-400');

            // Toggle buttons
            editBtn.classList.remove('hidden');
            saveBtn.classList.add('hidden');
        }
    }

    async function saveOneScriptStylePreset(key) {
        const val = document.getElementById(`script_preset_${key}`).value;
        try {
            const res = await fetch('/api/settings/script-style-presets', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ style_key: key, prompt_value: val })
            });

            if (res.ok) {
                Utils.showToast(`[${key}] 대본 스타일이 저장되었습니다`, 'success');

                // Exit edit mode
                const textarea = document.getElementById(`script_preset_${key}`);
                const editBtn = document.getElementById(`script_edit_btn_${key}`);
                const saveBtn = document.getElementById(`script_save_btn_${key}`);

                textarea.setAttribute('readonly', true);
                textarea.classList.add('bg-gray-100', 'dark:bg-gray-900');
                textarea.classList.remove('bg-white', 'dark:bg-gray-800', 'ring-2', 'ring-yellow-400');
                editBtn.classList.remove('hidden');
                saveBtn.classList.add('hidden');
            } else {
                Utils.showToast('저장 실패', 'error');
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('오류 발생', 'error');
        }
    }

    // [NEW] 썸네일 스타일 프리셋 관리
    const DEFAULT_THUMB_KEYS = ['face', 'text', 'contrast', 'mystery', 'minimal', 'dramatic', 'japanese_viral', 'ghibli', 'wimpy'];

    async function loadThumbnailStylePresets() {
        const list = document.getElementById('thumbnailStylePresetList');
        try {
            const res = await fetch('/api/settings/thumbnail-style-presets');
            const presets = await res.json();

            list.innerHTML = Object.entries(presets).map(([key, data]) => {
                // Compatibility
                const prompt = typeof data === 'string' ? data : (data.prompt_value || '');
                const imageUrl = typeof data === 'object' ? data.image_url : null;

                const displayName = {
                    'face': '얼굴 강조형',
                    'text': '텍스트 중심형',
                    'contrast': '비포/애프터형',
                    'mystery': '미스터리형',
                    'minimal': '미니멀형',
                    'dramatic': '드라마틱형',
                    'japanese_viral': '시니어 롱폼(일본풍)',
                    'ghibli': '지브리 감성',
                    'wimpy': '윔피키드 스타일'
                }[key] || key;

                const isDefault = DEFAULT_THUMB_KEYS.includes(key);
                // Fallback image url if none provided, old way (optional, but new way handles null)
                // If imageUrl is null, we show placeholder. 
                // Previously we had `/static/thumbnail_samples/${key}.png`. We can keep checking that if we want legacy support, 
                // but for now let's rely on data.image_url. If user wants legacy images they need to migrate or we rely on 'No Img'

                return `
                    <div class="bg-gray-50 dark:bg-gray-800/50 p-3 rounded-md border border-gray-100 dark:border-gray-700 relative group">
                        <div class="flex justify-between items-start mb-2">
                             <div class="flex items-center gap-2">
                                <div class="relative group/img cursor-pointer" onclick="document.getElementById('thumb_file_${key}').click()">
                                    ${imageUrl ?
                        `<img id="thumb_img_preview_${key}" src="${imageUrl}" class="w-10 h-10 rounded border border-gray-300 object-cover bg-white" title="이미지 변경 (클릭)">`
                        : `<span id="thumb_img_preview_${key}" class="w-10 h-10 rounded bg-gray-200 dark:bg-gray-700 flex items-center justify-center text-[10px] text-gray-500 hover:bg-gray-300 transition-colors" title="이미지 업로드 (클릭)">No Img</span>`
                    }
                                    <div class="absolute inset-0 bg-black/30 rounded flex items-center justify-center opacity-0 group-hover/img:opacity-100 transition-opacity">
                                        <span class="text-white text-[10px]">📷</span>
                                    </div>
                                    <input type="file" id="thumb_file_${key}" class="hidden" accept="image/*" onchange="previewThumbnailStyleImage(this, '${key}')">
                                </div>
                                <div>
                                    <label class="text-sm font-bold text-gray-700 dark:text-gray-200 block leading-none mb-1">${displayName}</label>
                                    <span class="text-[10px] text-gray-400 font-mono">${key}</span>
                                </div>
                            </div>

                            <div class="flex gap-1">
                                <button onclick="toggleEditThumbnailStylePreset('${key}')" id="thumb_edit_btn_${key}" class="text-[10px] bg-yellow-500 text-white px-2 py-1 rounded hover:bg-yellow-600 transition-colors">✏️ 수정</button>
                                <button onclick="saveOneThumbnailStylePreset('${key}')" id="thumb_save_btn_${key}" class="hidden text-[10px] bg-blue-500 text-white px-2 py-1 rounded hover:bg-blue-600 transition-colors">💾 저장</button>
                                ${!isDefault ?
                        `<button onclick="deleteThumbnailStylePreset('${key}')" class="text-[10px] bg-red-50 text-red-500 border border-red-200 px-2 py-1 rounded hover:bg-red-100 transition-colors" title="삭제">🗑️</button>`
                        : ''
                    }
                            </div>
                        </div>
                        <textarea id="thumbnail_preset_${key}" class="input-field w-full text-[11px] font-mono leading-tight mt-1 bg-gray-100 dark:bg-gray-900" rows="3" readonly>${prompt}</textarea>
                    </div>
                `;
            }).join('');
        } catch (e) {
            console.error(e);
            list.innerHTML = '<p class="text-red-500 text-xs">썸네일 스타일을 불러오지 못했습니다.</p>';
        }
    }

    function previewThumbnailStyleImage(input, key) {
        if (input.files && input.files[0]) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const preview = document.getElementById(`thumb_img_preview_${key}`);
                const parent = preview.parentElement;
                preview.remove();

                const img = document.createElement('img');
                img.id = `thumb_img_preview_${key}`;
                img.src = e.target.result;
                img.className = "w-10 h-10 rounded border border-gray-300 object-cover bg-white";
                img.title = "이미지 변경 (클릭)";

                parent.prepend(img);
            }
            reader.readAsDataURL(input.files[0]);
        }
    }

    function toggleEditThumbnailStylePreset(key) {
        const textarea = document.getElementById(`thumbnail_preset_${key}`);
        const editBtn = document.getElementById(`thumb_edit_btn_${key}`);
        const saveBtn = document.getElementById(`thumb_save_btn_${key}`);

        if (textarea.hasAttribute('readonly')) {
            // Enable editing
            textarea.removeAttribute('readonly');
            textarea.classList.remove('bg-gray-100', 'dark:bg-gray-900');
            textarea.classList.add('bg-white', 'dark:bg-gray-800', 'ring-2', 'ring-yellow-400');
            textarea.focus();

            // Toggle buttons
            editBtn.classList.add('hidden');
            saveBtn.classList.remove('hidden');
        } else {
            // Disable editing (cancel)
            textarea.setAttribute('readonly', true);
            textarea.classList.add('bg-gray-100', 'dark:bg-gray-900');
            textarea.classList.remove('bg-white', 'dark:bg-gray-800', 'ring-2', 'ring-yellow-400');

            // Toggle buttons
            editBtn.classList.remove('hidden');
            saveBtn.classList.add('hidden');
        }
    }

    async function saveOneThumbnailStylePreset(key) {
        const val = document.getElementById(`thumbnail_preset_${key}`).value;
        const fileInput = document.getElementById(`thumb_file_${key}`);
        const file = fileInput && fileInput.files[0];

        try {
            let res;
            if (file) {
                const formData = new FormData();
                formData.append('style_key', key);
                formData.append('prompt_value', val);
                formData.append('file', file);

                Utils.showToast('썸네일 스타일 이미지 업로드 중...', 'info');
                res = await fetch('/api/settings/thumbnail-style-presets/custom', {
                    method: 'POST',
                    body: formData
                });
            } else {
                res = await fetch('/api/settings/thumbnail-style-presets', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        style_key: key,
                        prompt_value: val,
                        image_url: null
                    })
                });
            }

            if (res.ok) {
                if (file) fileInput.value = '';
                Utils.showToast(`[${key}] 썸네일 스타일이 저장되었습니다`, 'success');

                // Exit edit mode
                const textarea = document.getElementById(`thumbnail_preset_${key}`);
                const editBtn = document.getElementById(`thumb_edit_btn_${key}`);
                const saveBtn = document.getElementById(`thumb_save_btn_${key}`);

                textarea.setAttribute('readonly', true);
                textarea.classList.add('bg-gray-100', 'dark:bg-gray-900');
                textarea.classList.remove('bg-white', 'dark:bg-gray-800', 'ring-2', 'ring-yellow-400');
                editBtn.classList.remove('hidden');
                saveBtn.classList.add('hidden');
            } else {
                Utils.showToast('저장 실패', 'error');
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('오류 발생', 'error');
        }
    }

    async function addCustomThumbnailStylePreset() {
        const nameInput = document.getElementById('customThumbStyleName');
        const promptInput = document.getElementById('customThumbStylePrompt');
        const fileInput = document.getElementById('customThumbStyleImage');
        const name = nameInput.value.trim();
        const prompt = promptInput.value.trim();
        const file = fileInput.files[0];

        if (!name || !prompt) {
            Utils.showToast('이름과 프롬프트를 모두 입력해주세요.', 'warning');
            return;
        }

        const formData = new FormData();
        formData.append('style_key', name);
        formData.append('prompt_value', prompt);
        if (file) {
            formData.append('file', file);
        } else {
            // Even if no file, the API expects 'file' field for UploadFile. 
            // We might need to split API or make file optional in `add_custom...`.
            // The python endpoint: `file: UploadFile = File(...)` implies required.
            // But we allow string-only create? 
            // Wait, previous implementation of `custom` endpoint requires file.
            // If user doesn't upload file, we should warn or support it. "Thumbnail must have image" is not strict rule but good for UI.
            // Let's require file for now for Custom, or fallback to regular POST if no file.
        }

        try {
            let res;
            if (file) {
                res = await fetch('/api/settings/thumbnail-style-presets/custom', {
                    method: 'POST',
                    body: formData
                });
            } else {
                // Use normal endpoint creates entry with null image
                res = await fetch('/api/settings/thumbnail-style-presets', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ style_key: name, prompt_value: prompt })
                });
            }

            if (res.ok) {
                Utils.showToast('새 썸네일 스타일이 추가되었습니다!', 'success');
                nameInput.value = '';
                promptInput.value = '';
                fileInput.value = '';
                document.getElementById('customThumbStyleImgName').textContent = '';
                loadThumbnailStylePresets();
            } else {
                const err = await res.json();
                Utils.showToast(err.detail || '추가 실패', 'error');
            }
        } catch (e) {
            console.error(e);
            Utils.showToast('서버 오류 발생', 'error');
        }
    }

    async function deleteThumbnailStylePreset(key) {
        if (!confirm(`'${key}' 스타일을 정말 삭제하시겠습니까?`)) return;

        try {
            const res = await fetch(`/api/settings/thumbnail-style-presets/${key}`, { method: 'DELETE' });
            if (res.ok) {
                Utils.showToast('삭제되었습니다.', 'success');
                loadThumbnailStylePresets();
            } else {
                Utils.showToast('삭제 실패', 'error');
            }
        } catch (e) {
            Utils.showToast('서버 오류', 'error');
        }
    }

    // [NEW] Webtoon Plan Prompt Management
    const DEFAULT_WEBTOON_PLAN_PROMPT = `
# ROLE: Hollywood Trailer Editor & VFX Supervisor
You are creating a high-end cinematic video production plan for a webtoon.
Follow the [USER CINEMATIC MASTER GUIDE] strictly when generating specifications for each scene.

[INPUT DATA (JSON SCENES)]
[[SCENES_JSON]]

[USER CINEMATIC MASTER GUIDE (STRICT ADHERENCE)]
0. Base Master Setting (Common for ALL cuts):
   "Vertical cinematic animation, 9:16 aspect ratio, 1080x1920, smooth camera movement, subtle parallax depth effect, soft volumetric lighting, atmospheric particles, high quality anime webtoon style, dramatic color grading, film grain subtle, slow cinematic motion, emotional pacing."

1. Production Types (scene_type):
   - TYPE 1 (Vertical Long): "Show Space" -> slow upward/downward camera pan, 2.5D depth parallax, foreground separation, glowing light rays.
   - TYPE 2 (Horizontal Wide): "Outpainting or Cinema Crop" -> Expand background to 9:16 or Vertical Crop focusing on faces/eyes, slow push-in, soft rim light.
   - TYPE 3 (Small/Empty): "Fill Space" -> Place center, extend matching background, slow cinematic zoom, minimal motion.
   - TYPE 4 (Transition): "Consistency" -> Fade with particles, slow cross-dissolve, motion blur.
   - TYPE 5 (PSD Depth): "3D Illusion" -> Separate foreground/mid/background, strong parallax, 3D camera move.
   - TYPE 6 (Unified Tone): High-end animated trailer look, soft contrast, warm highlights.

[CORE INSTRUCTIONS]
1. **overall_strategy**: Summarize the production direction in Korean.
2. **bgm_style**: Recommend BGM style in Korean.
3. **scene_specifications**: For each scene, generate:
   - **scene_number**: The number from input.
   - **engine**: "wan" (motion), "akool" (lipsync), or "image" (2D).
   - **effect**: "pan_down", "pan_up", "zoom_in", "zoom_out", "static".
   - **motion**: FULL CINEMATIC PROMPT in English. Combine Master Setting (0) + Type Specific Guide (1-6) + Scene Context.
   - **rationale**: Why this choice (e.g., "Tall image detected, using Type 1 Pan Down").
   - **cropping_advice**: How to frame to 9:16 without losing key info (Korean).

[OUTPUT FORMAT (JSON ONLY)]
{
    "overall_strategy": "Overall direction summary (Korean)",
    "bgm_style": "Recommended BGM style (Korean)",
    "scene_specifications": [
        {
            "scene_number": 1,
            "engine": "wan | akool | image",
            "effect": "zoom_in | pan_down | ...",
            "motion": "Detailed cinematic prompt in English",
            "rationale": "Reason for this setup (Korean)",
            "cropping_advice": "Advice for 9:16 framing (Korean)"
        }
    ]
}

**IMPORTANT**: For NARRATOR (내레이션), always use the voice 'Brian'. Same character = Same voice.
`.trim();

    // [NEW] Default Webtoon Optimization Prompts
    const DEFAULT_WEBTOON_VERTICAL_PROMPT = "Preserve full original composition, fit into 9:16 vertical canvas, no distortion, extend background naturally if needed, maintain original webtoon art style, high resolution, clean edges, no motion, no animation, static illustration";
    // [NEW] Default Webtoon Motion Prompts
    const DEFAULT_WEBTOON_MOTION_PAN = "Slow upward cinematic camera pan, subtle 2.5D parallax depth effect, soft volumetric lighting, floating dust particles, epic dramatic atmosphere, smooth motion, no distortion";
    const DEFAULT_WEBTOON_MOTION_ZOOM = "Slow push-in camera movement, focus on character’s eyes, subtle breathing motion, soft rim lighting, cinematic depth of field, emotional atmosphere";
    const DEFAULT_WEBTOON_MOTION_ACTION = "Strong parallax effect, embers floating in the air, light flicker from fire, slight cinematic camera shake, intense dramatic lighting, high energy atmosphere";

    async function loadWebtoonSettings() {
        try {
            const res = await fetch('/api/settings');
            const data = await res.json();

            // setCheckbox('ws_auto_split', data.webtoon_auto_split ?? true);
            // setCheckbox('ws_smart_pan', data.webtoon_smart_pan ?? true);
            // setCheckbox('ws_convert_zoom', data.webtoon_convert_zoom ?? true);

            // Plan Prompt
            const promptEl = document.getElementById('ws_plan_prompt');
            if (promptEl) {
                promptEl.value = data.webtoon_plan_prompt || DEFAULT_WEBTOON_PLAN_PROMPT;
            }

            // [NEW] Opt Prompts
            const vertEl = document.getElementById('ws_vertical_prompt');
            const horizEl = document.getElementById('ws_horizontal_prompt');
            if (vertEl) vertEl.value = data.webtoon_vertical_prompt || DEFAULT_WEBTOON_VERTICAL_PROMPT;
            if (horizEl) horizEl.value = data.webtoon_horizontal_prompt || DEFAULT_WEBTOON_HORIZONTAL_PROMPT;

            // [NEW] Motion Prompts
            const panEl = document.getElementById('ws_motion_pan');
            const zoomEl = document.getElementById('ws_motion_zoom');
            const actionEl = document.getElementById('ws_motion_action');
            if (panEl) panEl.value = data.webtoon_motion_pan || DEFAULT_WEBTOON_MOTION_PAN;
            if (zoomEl) zoomEl.value = data.webtoon_motion_zoom || DEFAULT_WEBTOON_MOTION_ZOOM;
            if (actionEl) actionEl.value = data.webtoon_motion_action || DEFAULT_WEBTOON_MOTION_ACTION;

            // [NEW] Video Engine
            const engine = data.video_engine || "wan";
            const radio = document.querySelector(`input[name="ws_video_engine"][value="${engine}"]`);
            if (radio) radio.checked = true;

        } catch (e) {
            console.error('웹툰 설정 로드 실패:', e);
        }
    }

    function resetWebtoonPrompt() {
        if (confirm('기본 기획 프롬프트로 초기화하시겠습니까?')) {
            document.getElementById('ws_plan_prompt').value = DEFAULT_WEBTOON_PLAN_PROMPT;
        }
    }

    function resetWebtoonOptPrompts() {
        if (confirm('이미지 최적화 프롬프트를 기본값으로 초기화하시겠습니까?')) {
            document.getElementById('ws_vertical_prompt').value = DEFAULT_WEBTOON_VERTICAL_PROMPT;
            document.getElementById('ws_horizontal_prompt').value = DEFAULT_WEBTOON_HORIZONTAL_PROMPT;
        }
    }

    function resetWebtoonMotionPrompts() {
        if (confirm('모션 프롬프트를 기본값으로 초기화하시겠습니까?')) {
            document.getElementById('ws_motion_pan').value = DEFAULT_WEBTOON_MOTION_PAN;
            document.getElementById('ws_motion_zoom').value = DEFAULT_WEBTOON_MOTION_ZOOM;
            document.getElementById('ws_motion_action').value = DEFAULT_WEBTOON_MOTION_ACTION;
        }
    }

    function setCheckbox(id, val) {
        const el = document.getElementById(id);
        if (el) el.checked = !!val;
    }

    // [MODIFIED] saveAllSettings to include Webtoon Prompt


    // [NEW] setAppMode to handle 'webtoon'
    function setAppMode(mode) {
        document.getElementById('appMode').value = mode;

        const updateBtn = (btnId, active) => {
            const btn = document.getElementById(btnId);
            if (!btn) return;
            if (active) {
                btn.className = "px-4 py-1.5 rounded-md text-xs font-bold transition-all bg-white dark:bg-gray-600 shadow text-gray-800 dark:text-white";
            } else {
                btn.className = "px-4 py-1.5 rounded-md text-xs font-medium text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200";
            }
        };

        updateBtn('btnModeLong', mode === 'longform');
        updateBtn('btnModeShort', mode === 'shorts');
        updateBtn('btnModeWebtoon', mode === 'webtoon');
        updateBtn('btnModeCommerce', mode === 'commerce');
    }

    // [NEW] ElevenLabs Voice List
    async function refreshElevenVoices() {
        const listEl = document.getElementById('elevenVoiceList');
        if (!listEl) return;

        listEl.innerHTML = '<p class="text-[9px] text-gray-400 text-center py-2 animate-pulse">ElevenLabs API 통신 중...</p>';

        try {
            // API call to fetch voices
            const res = await fetch('/api/tts/voices');
            if (!res.ok) throw new Error("API call failed");

            const data = await res.json();

            if (!data || data.length === 0) {
                listEl.innerHTML = '<p class="text-[9px] text-gray-400 text-center py-2">등록된 목소리가 없습니다.</p>';
                return;
            }

            listEl.innerHTML = data.map(v => {
                const gender = v.labels && v.labels.gender ? v.labels.gender : 'Unknown';
                const genderBadge = gender === 'male' ? 'bg-blue-100 text-blue-600' :
                    gender === 'female' ? 'bg-pink-100 text-pink-600' :
                        'bg-gray-100 text-gray-600';

                return `
                    <div class="flex justify-between items-center p-1.5 hover:bg-gray-50 dark:hover:bg-gray-800 rounded border-b border-gray-50 dark:border-gray-800 last:border-0 transition-colors group">
                        <div class="flex flex-col overflow-hidden">
                            <span class="text-[10px] font-bold text-gray-700 dark:text-gray-300 truncate pr-2 group-hover:text-blue-600 transition-colors" title="${v.name}">${v.name}</span>
                            <span class="text-[8px] text-gray-400 font-mono truncate" title="Voice ID: ${v.voice_id}">${v.voice_id}</span>
                        </div>
                        <div class="flex flex-col items-end flex-shrink-0">
                            <span class="text-[8px] ${genderBadge} px-1.5 rounded-full capitalize font-medium">${gender}</span>
                            <span class="text-[8px] text-gray-400">${v.category || ''}</span>
                        </div>
                    </div>
                `;
            }).join('');

        } catch (e) {
            console.error(e);
            listEl.innerHTML = '<p class="text-[9px] text-red-500 text-center py-2">목록 로드 실패 (API Key 확인 필요)</p>';
        }
    }

    function toggleVoiceList(btn) {
        const container = document.getElementById('elevenVoicesContainer');
        if (!container) return;

        if (container.classList.contains('hidden')) {
            container.classList.remove('hidden');
            if (btn) btn.textContent = '목소리 목록 닫기 ▲';
            refreshElevenVoices();
        } else {
            container.classList.add('hidden');
            if (btn) btn.textContent = '목소리 목록 보기 ▼';
        }
    }

    // [FINAL OVERRIDE] Ensure saveAllSettings handles EVERYTHING
    async function saveAllSettings() {
        try {
            // 1. API Keys (Always save first)
            await saveApiKeys();

            // 2. Gather All Global Settings
            const safeVal = (id) => document.getElementById(id)?.value || '';
            const safeCheck = (id) => document.getElementById(id)?.checked ?? false;

            const settings = {
                // Base Settings
                app_mode: safeVal('appMode'),

                // Gemini TTS
                gemini_tts: {
                    voice_name: safeVal('geminiVoice'),
                    language_code: safeVal('geminiLanguage'),
                    style_prompt: safeVal('geminiStylePrompt')
                },

                // Script Styles
                script_styles: {
                    news: safeVal('promptNews'),
                    story: safeVal('promptStory'),
                    script_master: safeVal('promptScriptMaster'),
                    senior_story: safeVal('promptSeniorStory')
                },

                // Webtoon Settings
                // webtoon_auto_split: safeCheck('ws_auto_split'),
                // webtoon_smart_pan: safeCheck('ws_smart_pan'),
                // webtoon_convert_zoom: safeCheck('ws_convert_zoom'),
                // webtoon_smart_pan: safeCheck('ws_smart_pan'),
                // webtoon_convert_zoom: safeCheck('ws_convert_zoom'),
                webtoon_plan_prompt: safeVal('ws_plan_prompt'),
                webtoon_vertical_prompt: safeVal('ws_vertical_prompt'),
                webtoon_horizontal_prompt: safeVal('ws_horizontal_prompt'),
                webtoon_motion_pan: safeVal('ws_motion_pan'),
                webtoon_motion_zoom: safeVal('ws_motion_zoom'),
                webtoon_motion_action: safeVal('ws_motion_action'),
                video_engine: document.querySelector('input[name="ws_video_engine"]:checked')?.value || "wan"
            };

            const res = await fetch('/api/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(settings)
            });

            if (res.ok) {
                const data = await res.json();
                if (data.mode_changed) {
                    Utils.showToast(`✅ 설정 저장 및 모드 전환 완료!`, 'success');
                    setTimeout(() => window.location.reload(), 1500);
                } else {
                    Utils.showToast('✅ 모든 설정이 저장되었습니다', 'success');
                    // Refresh checks
                    await loadApiKeys();
                    await checkApiConnection();
                }
            } else {
                Utils.showToast('저장 실패', 'error');
            }
        } catch (e) {
            console.error('설정 저장 오류:', e);
            Utils.showToast('❌ 설정 저장 중 오류가 발생했습니다.', 'error');
        }
    }

    // [FINAL OVERRIDE] Ensure loadAllSettings calls Webtoon settings
    const originalLoadAllSettings = loadAllSettings;
    // Wait, reusing name causes recursion if we are not careful or if let/const. 
    // Browsers hoist function declarations. The last one overrides.
    // So we just redefine it.

    async function loadAllSettings() {
        try {
            await loadApiKeys();
            await checkApiConnection();

            const res = await fetch('/api/settings');
            const data = await res.json();

            // Base Settings
            if (data.app_mode) setAppMode(data.app_mode);
            if (data.template_image_url) updateTemplatePreview(data.template_image_url);

            // Gemini TTS
            if (data.gemini_tts) {
                if (document.getElementById('geminiVoice')) document.getElementById('geminiVoice').value = data.gemini_tts.voice_name || 'Puck';
                if (document.getElementById('geminiLanguage')) document.getElementById('geminiLanguage').value = data.gemini_tts.language_code || 'ko-KR';
                if (document.getElementById('geminiStylePrompt')) document.getElementById('geminiStylePrompt').value = data.gemini_tts.style_prompt || '';
            }

            // Script Styles
            if (data.script_styles) {
                if (document.getElementById('promptNews')) document.getElementById('promptNews').value = data.script_styles.news || '';
                if (document.getElementById('promptStory')) document.getElementById('promptStory').value = data.script_styles.story || '';
                if (document.getElementById('promptScriptMaster')) document.getElementById('promptScriptMaster').value = data.script_styles.script_master || DEFAULT_SCRIPT_MASTER_PROMPT;
                if (document.getElementById('promptSeniorStory')) document.getElementById('promptSeniorStory').value = data.script_styles.senior_story || '';
            }

            // Webtoon Settings
            await loadWebtoonSettings();

            Utils.showToast('설정을 불러왔습니다.', 'info');
        } catch (e) {
            console.error('설정 로드 실패:', e);
        }
    }

    // 초기화
    document.addEventListener('DOMContentLoaded', () => {
        populateOptions();
        loadAllSettings();
        loadChannels();
        loadStylePresets(); // [NEW] 스타일 프리셋 로드
        loadThumbnailStylePresets();
    });
</script>
{% endblock %}